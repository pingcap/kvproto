syntax = "proto2";
package pdpb;

import "metapb.proto";

message Leader {
    optional string addr  = 1;
    optional int64 pid    = 2;
}

enum CommandType {
    Invalid        = 0;
    Tso            = 1;
    Bootstrap      = 2;
    IsBootstrapped = 3;
    AllocId        = 4;
    GetMeta        = 5;
    PutMeta        = 6;
    DeleteMeta     = 7;
    AskChangePeer  = 8;
    AskSplit       = 9;
}

message TsoRequest {
    optional uint32 number = 1;
}

message Timestamp {
    optional int64 physical = 1;
    optional int64 logical  = 2;
}

message TsoResponse {
    repeated Timestamp timestamps = 1;
}

message BootstrapRequest {
    optional metapb.Store store   = 1;
    optional metapb.Region region = 2;
}

message BootstrapResponse {
    
}

message IsBootstrappedRequest {
    
}

message IsBootstrappedResponse {
    optional bool bootstrapped = 1;
}

enum MetaType {
    InvalidMeta      = 0;
    StoreType        = 1;
    RegionType       = 2;
    PeerType         = 3;
    ClusterType      = 4;
}

message AllocIdRequest {

}

message AllocIdResponse {
    optional uint64 id             = 1;
}

message GetMetaRequest {
    optional MetaType meta_type    = 1;
    optional uint64 store_id       = 2;
    optional bytes region_key      = 3;
    optional uint64 cluster_id     = 4;
}

message GetMetaResponse {
    optional MetaType meta_type     = 1;
    optional metapb.Store store     = 2;
    optional metapb.Region region   = 3;
    optional metapb.Cluster cluster = 4;
}

message PutMetaRequest {
    optional MetaType meta_type     = 1;
    optional metapb.Store store     = 2;
    optional metapb.Cluster cluster = 3;
}

message PutMetaResponse {
    optional MetaType meta_type = 1;
}

message AskChangePeerRequest {
    optional metapb.Region region    = 1;
    // The current leader store id of the region.
    // Pd can first try to send command to this store,
    // if the peer is not leader now, pd will try to
    // find the new leader of the region and then send
    // command again.
    optional uint64 leader_store_id  = 2;
}

message AskChangePeerResponse {
    
}

message AskSplitRequest {
    optional metapb.Region region      = 1;
    optional bytes split_key           = 2;
    optional uint64 leader_store_id    = 3;
}

message AskSplitResponse {
    
}

message RequestHeader {
    // 16 bytes, to distinguish request.  
    optional bytes uuid                = 1;
    optional uint64 cluster_id         = 2;
}

message ResponseHeader {
    // 16 bytes, to distinguish request.  
    optional bytes uuid                = 1;
    optional uint64 cluster_id         = 2;
    optional Error error               = 3;
}

message Request {
    optional RequestHeader header                  = 1;
    optional CommandType cmd_type                  = 2;
    optional TsoRequest tso                        = 3;
    optional BootstrapRequest bootstrap            = 4;
    optional IsBootstrappedRequest is_bootstrapped = 5;
    optional AllocIdRequest alloc_id               = 6;
    optional GetMetaRequest get_meta               = 7;
    optional PutMetaRequest put_meta               = 8;
    optional AskChangePeerRequest ask_change_peer  = 9;
    optional AskSplitRequest ask_split             = 10;
}

message Response {
    optional ResponseHeader header                  = 1;
    optional CommandType cmd_type                   = 2;
    optional TsoResponse tso                        = 3;
    optional BootstrapResponse bootstrap            = 4;
    optional IsBootstrappedResponse is_bootstrapped = 5;
    optional AllocIdResponse alloc_id               = 6;
    optional GetMetaResponse get_meta               = 7;
    optional PutMetaResponse put_meta               = 8;
    optional AskChangePeerResponse ask_change_peer  = 9;
    optional AskSplitResponse ask_split             = 10;
}

message BootstrappedError {
    
}

message Error {
    optional string message                 = 1;
    optional BootstrappedError bootstrapped = 2;
}