// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: brpb.proto

package backup

import (
	"context"
	"fmt"
	"io"
	"math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	encryptionpb "github.com/pingcap/kvproto/pkg/encryptionpb"
	errorpb "github.com/pingcap/kvproto/pkg/errorpb"
	kvrpcpb "github.com/pingcap/kvproto/pkg/kvrpcpb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// sst files compression algorithm
type CompressionType int32

const (
	CompressionType_UNKNOWN CompressionType = 0
	CompressionType_LZ4     CompressionType = 1
	CompressionType_SNAPPY  CompressionType = 2
	CompressionType_ZSTD    CompressionType = 3
)

var CompressionType_name = map[int32]string{
	0: "UNKNOWN",
	1: "LZ4",
	2: "SNAPPY",
	3: "ZSTD",
}

var CompressionType_value = map[string]int32{
	"UNKNOWN": 0,
	"LZ4":     1,
	"SNAPPY":  2,
	"ZSTD":    3,
}

func (x CompressionType) String() string {
	return proto.EnumName(CompressionType_name, int32(x))
}

func (CompressionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{0}
}

// The message save the metadata of a backup.
type BackupMeta struct {
	// ID and version of backuped cluster.
	ClusterId      uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	ClusterVersion string `protobuf:"bytes,2,opt,name=cluster_version,json=clusterVersion,proto3" json:"cluster_version,omitempty"`
	// Save the version of BR running backup jobs.
	BrVersion string `protobuf:"bytes,11,opt,name=br_version,json=brVersion,proto3" json:"br_version,omitempty"`
	// The backupmeta scheme version.
	Version int32 `protobuf:"varint,12,opt,name=version,proto3" json:"version,omitempty"`
	// A set of files that compose a backup.
	// Note: `files` is deprecated, as it bloats backupmeta. It is kept for
	//       compatibility, so new BR can restore older backups.
	Files []*File `protobuf:"bytes,4,rep,name=files,proto3" json:"files,omitempty"`
	// An index to files contains data files.
	FileIndex *MetaFile `protobuf:"bytes,13,opt,name=file_index,json=fileIndex,proto3" json:"file_index,omitempty"`
	// A pair of timestamp specifies a time range of a backup.
	// For full backup, the start_version equals to the end_version,
	// it means point in time.
	// For incremental backup, the time range is specified as
	// (start_version, end_version].
	StartVersion uint64 `protobuf:"varint,5,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	EndVersion   uint64 `protobuf:"varint,6,opt,name=end_version,json=endVersion,proto3" json:"end_version,omitempty"`
	// Table metadata describes database and table info.
	// Note: `schemas` is deprecated, as it bloats backupmeta. It is kept for
	//       compatibility, so new BR can restore older backups.
	Schemas []*Schema `protobuf:"bytes,7,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// An index to files contains Schemas.
	SchemaIndex *MetaFile `protobuf:"bytes,14,opt,name=schema_index,json=schemaIndex,proto3" json:"schema_index,omitempty"`
	// If in raw kv mode, `start_versions`, `end_versions` and `schemas` will be
	// ignored, and the backup data's range is represented by raw_ranges.
	IsRawKv bool `protobuf:"varint,8,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	// Note: `raw_ranges` is deprecated, as it bloats backupmeta. It is kept for
	//       compatibility, so new BR can restore older backups.
	RawRanges []*RawRange `protobuf:"bytes,9,rep,name=raw_ranges,json=rawRanges,proto3" json:"raw_ranges,omitempty"`
	// An index to files contains RawRanges.
	RawRangeIndex *MetaFile `protobuf:"bytes,15,opt,name=raw_range_index,json=rawRangeIndex,proto3" json:"raw_range_index,omitempty"`
	// In incremental backup, DDLs which are completed in
	// (lastBackupTS, backupTS] will be stored here.
	// Note: `raw_ranges` is deprecated, as it bloats backupmeta. It is kept for
	//       compatibility, so new BR can restore older backups.
	Ddls []byte `protobuf:"bytes,10,opt,name=ddls,proto3" json:"ddls,omitempty"`
	// An index to files contains DDLs.
	DdlIndexes *MetaFile `protobuf:"bytes,16,opt,name=ddl_indexes,json=ddlIndexes,proto3" json:"ddl_indexes,omitempty"`
	// the backup result into `backupmeta` file
	BackupResult string `protobuf:"bytes,17,opt,name=backup_result,json=backupResult,proto3" json:"backup_result,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion kvrpcpb.APIVersion `protobuf:"varint,18,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// the placement policy info in backup cluster. we assume the policy won't be too much for one cluster.
	Policies []*PlacementPolicy `protobuf:"bytes,19,rep,name=policies,proto3" json:"policies,omitempty"`
	// new_collations_enabled specifies the config `new_collations_enabled_on_first_bootstrap` in tidb.
	NewCollationsEnabled string   `protobuf:"bytes,20,opt,name=new_collations_enabled,json=newCollationsEnabled,proto3" json:"new_collations_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupMeta) Reset()         { *m = BackupMeta{} }
func (m *BackupMeta) String() string { return proto.CompactTextString(m) }
func (*BackupMeta) ProtoMessage()    {}
func (*BackupMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{0}
}
func (m *BackupMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupMeta.Merge(m, src)
}
func (m *BackupMeta) XXX_Size() int {
	return m.Size()
}
func (m *BackupMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupMeta.DiscardUnknown(m)
}

var xxx_messageInfo_BackupMeta proto.InternalMessageInfo

func (m *BackupMeta) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *BackupMeta) GetClusterVersion() string {
	if m != nil {
		return m.ClusterVersion
	}
	return ""
}

func (m *BackupMeta) GetBrVersion() string {
	if m != nil {
		return m.BrVersion
	}
	return ""
}

func (m *BackupMeta) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BackupMeta) GetFiles() []*File {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *BackupMeta) GetFileIndex() *MetaFile {
	if m != nil {
		return m.FileIndex
	}
	return nil
}

func (m *BackupMeta) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *BackupMeta) GetEndVersion() uint64 {
	if m != nil {
		return m.EndVersion
	}
	return 0
}

func (m *BackupMeta) GetSchemas() []*Schema {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *BackupMeta) GetSchemaIndex() *MetaFile {
	if m != nil {
		return m.SchemaIndex
	}
	return nil
}

func (m *BackupMeta) GetIsRawKv() bool {
	if m != nil {
		return m.IsRawKv
	}
	return false
}

func (m *BackupMeta) GetRawRanges() []*RawRange {
	if m != nil {
		return m.RawRanges
	}
	return nil
}

func (m *BackupMeta) GetRawRangeIndex() *MetaFile {
	if m != nil {
		return m.RawRangeIndex
	}
	return nil
}

func (m *BackupMeta) GetDdls() []byte {
	if m != nil {
		return m.Ddls
	}
	return nil
}

func (m *BackupMeta) GetDdlIndexes() *MetaFile {
	if m != nil {
		return m.DdlIndexes
	}
	return nil
}

func (m *BackupMeta) GetBackupResult() string {
	if m != nil {
		return m.BackupResult
	}
	return ""
}

func (m *BackupMeta) GetApiVersion() kvrpcpb.APIVersion {
	if m != nil {
		return m.ApiVersion
	}
	return kvrpcpb.APIVersion_V1
}

func (m *BackupMeta) GetPolicies() []*PlacementPolicy {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *BackupMeta) GetNewCollationsEnabled() string {
	if m != nil {
		return m.NewCollationsEnabled
	}
	return ""
}

type File struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sha256       []byte `protobuf:"bytes,2,opt,name=sha256,proto3" json:"sha256,omitempty"`
	StartKey     []byte `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey       []byte `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	StartVersion uint64 `protobuf:"varint,5,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	EndVersion   uint64 `protobuf:"varint,6,opt,name=end_version,json=endVersion,proto3" json:"end_version,omitempty"`
	Crc64Xor     uint64 `protobuf:"varint,7,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	TotalKvs     uint64 `protobuf:"varint,8,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes   uint64 `protobuf:"varint,9,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	Cf           string `protobuf:"bytes,10,opt,name=cf,proto3" json:"cf,omitempty"`
	Size_        uint64 `protobuf:"varint,11,opt,name=size,proto3" json:"size,omitempty"`
	// cipher_iv is used for AES cipher
	CipherIv             []byte   `protobuf:"bytes,12,opt,name=cipher_iv,json=cipherIv,proto3" json:"cipher_iv,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{1}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_File.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *File) GetSha256() []byte {
	if m != nil {
		return m.Sha256
	}
	return nil
}

func (m *File) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *File) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *File) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *File) GetEndVersion() uint64 {
	if m != nil {
		return m.EndVersion
	}
	return 0
}

func (m *File) GetCrc64Xor() uint64 {
	if m != nil {
		return m.Crc64Xor
	}
	return 0
}

func (m *File) GetTotalKvs() uint64 {
	if m != nil {
		return m.TotalKvs
	}
	return 0
}

func (m *File) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *File) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *File) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *File) GetCipherIv() []byte {
	if m != nil {
		return m.CipherIv
	}
	return nil
}

// MetaFile describes a multi-level index of data used in backup.
type MetaFile struct {
	// A set of files that contains a MetaFile.
	// It is used as a multi-level index.
	MetaFiles []*File `protobuf:"bytes,1,rep,name=meta_files,json=metaFiles,proto3" json:"meta_files,omitempty"`
	// A set of files that contains user data.
	DataFiles []*File `protobuf:"bytes,2,rep,name=data_files,json=dataFiles,proto3" json:"data_files,omitempty"`
	// A set of files that contains Schemas.
	Schemas []*Schema `protobuf:"bytes,3,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// A set of files that contains RawRanges.
	RawRanges []*RawRange `protobuf:"bytes,4,rep,name=raw_ranges,json=rawRanges,proto3" json:"raw_ranges,omitempty"`
	// A set of files that contains DDLs.
	Ddls                 [][]byte `protobuf:"bytes,5,rep,name=ddls,proto3" json:"ddls,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetaFile) Reset()         { *m = MetaFile{} }
func (m *MetaFile) String() string { return proto.CompactTextString(m) }
func (*MetaFile) ProtoMessage()    {}
func (*MetaFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{2}
}
func (m *MetaFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaFile.Merge(m, src)
}
func (m *MetaFile) XXX_Size() int {
	return m.Size()
}
func (m *MetaFile) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaFile.DiscardUnknown(m)
}

var xxx_messageInfo_MetaFile proto.InternalMessageInfo

func (m *MetaFile) GetMetaFiles() []*File {
	if m != nil {
		return m.MetaFiles
	}
	return nil
}

func (m *MetaFile) GetDataFiles() []*File {
	if m != nil {
		return m.DataFiles
	}
	return nil
}

func (m *MetaFile) GetSchemas() []*Schema {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *MetaFile) GetRawRanges() []*RawRange {
	if m != nil {
		return m.RawRanges
	}
	return nil
}

func (m *MetaFile) GetDdls() [][]byte {
	if m != nil {
		return m.Ddls
	}
	return nil
}

type PlacementPolicy struct {
	Info                 []byte   `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlacementPolicy) Reset()         { *m = PlacementPolicy{} }
func (m *PlacementPolicy) String() string { return proto.CompactTextString(m) }
func (*PlacementPolicy) ProtoMessage()    {}
func (*PlacementPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{3}
}
func (m *PlacementPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementPolicy.Merge(m, src)
}
func (m *PlacementPolicy) XXX_Size() int {
	return m.Size()
}
func (m *PlacementPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementPolicy proto.InternalMessageInfo

func (m *PlacementPolicy) GetInfo() []byte {
	if m != nil {
		return m.Info
	}
	return nil
}

type Schema struct {
	Db              []byte `protobuf:"bytes,1,opt,name=db,proto3" json:"db,omitempty"`
	Table           []byte `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	Crc64Xor        uint64 `protobuf:"varint,3,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	TotalKvs        uint64 `protobuf:"varint,4,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes      uint64 `protobuf:"varint,5,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	TiflashReplicas uint32 `protobuf:"varint,6,opt,name=tiflash_replicas,json=tiflashReplicas,proto3" json:"tiflash_replicas,omitempty"`
	// stats represents the dump stats for a analyzed table, which generate by DumpStatsToJSON
	// https://github.com/pingcap/tidb/blob/e136429d8dc5d70f43cd3f94179b0b9f47595097/statistics/handle/dump.go#L116
	Stats                []byte   `protobuf:"bytes,7,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{4}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

func (m *Schema) GetDb() []byte {
	if m != nil {
		return m.Db
	}
	return nil
}

func (m *Schema) GetTable() []byte {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *Schema) GetCrc64Xor() uint64 {
	if m != nil {
		return m.Crc64Xor
	}
	return 0
}

func (m *Schema) GetTotalKvs() uint64 {
	if m != nil {
		return m.TotalKvs
	}
	return 0
}

func (m *Schema) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *Schema) GetTiflashReplicas() uint32 {
	if m != nil {
		return m.TiflashReplicas
	}
	return 0
}

func (m *Schema) GetStats() []byte {
	if m != nil {
		return m.Stats
	}
	return nil
}

type RawRange struct {
	StartKey             []byte   `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey               []byte   `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Cf                   string   `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawRange) Reset()         { *m = RawRange{} }
func (m *RawRange) String() string { return proto.CompactTextString(m) }
func (*RawRange) ProtoMessage()    {}
func (*RawRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{5}
}
func (m *RawRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawRange.Merge(m, src)
}
func (m *RawRange) XXX_Size() int {
	return m.Size()
}
func (m *RawRange) XXX_DiscardUnknown() {
	xxx_messageInfo_RawRange.DiscardUnknown(m)
}

var xxx_messageInfo_RawRange proto.InternalMessageInfo

func (m *RawRange) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *RawRange) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *RawRange) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

type ClusterIDError struct {
	Current              uint64   `protobuf:"varint,1,opt,name=current,proto3" json:"current,omitempty"`
	Request              uint64   `protobuf:"varint,2,opt,name=request,proto3" json:"request,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterIDError) Reset()         { *m = ClusterIDError{} }
func (m *ClusterIDError) String() string { return proto.CompactTextString(m) }
func (*ClusterIDError) ProtoMessage()    {}
func (*ClusterIDError) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{6}
}
func (m *ClusterIDError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterIDError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterIDError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterIDError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterIDError.Merge(m, src)
}
func (m *ClusterIDError) XXX_Size() int {
	return m.Size()
}
func (m *ClusterIDError) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterIDError.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterIDError proto.InternalMessageInfo

func (m *ClusterIDError) GetCurrent() uint64 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *ClusterIDError) GetRequest() uint64 {
	if m != nil {
		return m.Request
	}
	return 0
}

type Error struct {
	Msg string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// Types that are valid to be assigned to Detail:
	//	*Error_ClusterIdError
	//	*Error_KvError
	//	*Error_RegionError
	Detail               isError_Detail `protobuf_oneof:"detail"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{7}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

type isError_Detail interface {
	isError_Detail()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Error_ClusterIdError struct {
	ClusterIdError *ClusterIDError `protobuf:"bytes,3,opt,name=cluster_id_error,json=clusterIdError,proto3,oneof" json:"cluster_id_error,omitempty"`
}
type Error_KvError struct {
	KvError *kvrpcpb.KeyError `protobuf:"bytes,4,opt,name=kv_error,json=kvError,proto3,oneof" json:"kv_error,omitempty"`
}
type Error_RegionError struct {
	RegionError *errorpb.Error `protobuf:"bytes,5,opt,name=region_error,json=regionError,proto3,oneof" json:"region_error,omitempty"`
}

func (*Error_ClusterIdError) isError_Detail() {}
func (*Error_KvError) isError_Detail()        {}
func (*Error_RegionError) isError_Detail()    {}

func (m *Error) GetDetail() isError_Detail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func (m *Error) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Error) GetClusterIdError() *ClusterIDError {
	if x, ok := m.GetDetail().(*Error_ClusterIdError); ok {
		return x.ClusterIdError
	}
	return nil
}

func (m *Error) GetKvError() *kvrpcpb.KeyError {
	if x, ok := m.GetDetail().(*Error_KvError); ok {
		return x.KvError
	}
	return nil
}

func (m *Error) GetRegionError() *errorpb.Error {
	if x, ok := m.GetDetail().(*Error_RegionError); ok {
		return x.RegionError
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Error) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Error_ClusterIdError)(nil),
		(*Error_KvError)(nil),
		(*Error_RegionError)(nil),
	}
}

type CipherInfo struct {
	CipherType           encryptionpb.EncryptionMethod `protobuf:"varint,1,opt,name=cipher_type,json=cipherType,proto3,enum=encryptionpb.EncryptionMethod" json:"cipher_type,omitempty"`
	CipherKey            []byte                        `protobuf:"bytes,2,opt,name=cipher_key,json=cipherKey,proto3" json:"cipher_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *CipherInfo) Reset()         { *m = CipherInfo{} }
func (m *CipherInfo) String() string { return proto.CompactTextString(m) }
func (*CipherInfo) ProtoMessage()    {}
func (*CipherInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{8}
}
func (m *CipherInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CipherInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CipherInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CipherInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CipherInfo.Merge(m, src)
}
func (m *CipherInfo) XXX_Size() int {
	return m.Size()
}
func (m *CipherInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CipherInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CipherInfo proto.InternalMessageInfo

func (m *CipherInfo) GetCipherType() encryptionpb.EncryptionMethod {
	if m != nil {
		return m.CipherType
	}
	return encryptionpb.EncryptionMethod_UNKNOWN
}

func (m *CipherInfo) GetCipherKey() []byte {
	if m != nil {
		return m.CipherKey
	}
	return nil
}

type BackupRequest struct {
	ClusterId    uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	StartKey     []byte `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey       []byte `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	StartVersion uint64 `protobuf:"varint,4,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	EndVersion   uint64 `protobuf:"varint,5,opt,name=end_version,json=endVersion,proto3" json:"end_version,omitempty"`
	// The I/O rate limit for backup request.
	RateLimit uint64 `protobuf:"varint,7,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	// The concurrency for executing the backup request in every tikv node.
	Concurrency    uint32          `protobuf:"varint,8,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	StorageBackend *StorageBackend `protobuf:"bytes,9,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	// If raw kv mode is enabled, `start_version` and `end_version` will be ignored, and `cf`
	// specifies which cf to backup.
	IsRawKv bool   `protobuf:"varint,10,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	Cf      string `protobuf:"bytes,11,opt,name=cf,proto3" json:"cf,omitempty"`
	// algorithm used for compress sst files
	CompressionType CompressionType `protobuf:"varint,12,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
	// sst compression level, some algorithms support negative compression levels
	CompressionLevel int32 `protobuf:"varint,13,opt,name=compression_level,json=compressionLevel,proto3" json:"compression_level,omitempty"`
	// The cipher_info is Used to encrypt sst
	CipherInfo *CipherInfo `protobuf:"bytes,14,opt,name=cipher_info,json=cipherInfo,proto3" json:"cipher_info,omitempty"`
	// dst_api_version indicates the key-value encoding version used by the
	// generated SST file. Accepted values:
	// 1. "v1": the generated SST files are encoded with api-v1, can be restored
	//    to TiKV clusters whose api version is set to v1.
	// 2. "v2": the generated SST files are encoded with api-v2, can be restored
	//    to TiKV clusters whose api version is set to v2.
	DstApiVersion        kvrpcpb.APIVersion `protobuf:"varint,15,opt,name=dst_api_version,json=dstApiVersion,proto3,enum=kvrpcpb.APIVersion" json:"dst_api_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *BackupRequest) Reset()         { *m = BackupRequest{} }
func (m *BackupRequest) String() string { return proto.CompactTextString(m) }
func (*BackupRequest) ProtoMessage()    {}
func (*BackupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{9}
}
func (m *BackupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupRequest.Merge(m, src)
}
func (m *BackupRequest) XXX_Size() int {
	return m.Size()
}
func (m *BackupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BackupRequest proto.InternalMessageInfo

func (m *BackupRequest) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *BackupRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *BackupRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *BackupRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *BackupRequest) GetEndVersion() uint64 {
	if m != nil {
		return m.EndVersion
	}
	return 0
}

func (m *BackupRequest) GetRateLimit() uint64 {
	if m != nil {
		return m.RateLimit
	}
	return 0
}

func (m *BackupRequest) GetConcurrency() uint32 {
	if m != nil {
		return m.Concurrency
	}
	return 0
}

func (m *BackupRequest) GetStorageBackend() *StorageBackend {
	if m != nil {
		return m.StorageBackend
	}
	return nil
}

func (m *BackupRequest) GetIsRawKv() bool {
	if m != nil {
		return m.IsRawKv
	}
	return false
}

func (m *BackupRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *BackupRequest) GetCompressionType() CompressionType {
	if m != nil {
		return m.CompressionType
	}
	return CompressionType_UNKNOWN
}

func (m *BackupRequest) GetCompressionLevel() int32 {
	if m != nil {
		return m.CompressionLevel
	}
	return 0
}

func (m *BackupRequest) GetCipherInfo() *CipherInfo {
	if m != nil {
		return m.CipherInfo
	}
	return nil
}

func (m *BackupRequest) GetDstApiVersion() kvrpcpb.APIVersion {
	if m != nil {
		return m.DstApiVersion
	}
	return kvrpcpb.APIVersion_V1
}

type StorageBackend struct {
	// Types that are valid to be assigned to Backend:
	//	*StorageBackend_Noop
	//	*StorageBackend_Local
	//	*StorageBackend_S3
	//	*StorageBackend_Gcs
	//	*StorageBackend_CloudDynamic
	//	*StorageBackend_Hdfs
	//	*StorageBackend_AzureBlobStorage
	Backend              isStorageBackend_Backend `protobuf_oneof:"backend"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *StorageBackend) Reset()         { *m = StorageBackend{} }
func (m *StorageBackend) String() string { return proto.CompactTextString(m) }
func (*StorageBackend) ProtoMessage()    {}
func (*StorageBackend) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{10}
}
func (m *StorageBackend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageBackend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageBackend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageBackend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageBackend.Merge(m, src)
}
func (m *StorageBackend) XXX_Size() int {
	return m.Size()
}
func (m *StorageBackend) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageBackend.DiscardUnknown(m)
}

var xxx_messageInfo_StorageBackend proto.InternalMessageInfo

type isStorageBackend_Backend interface {
	isStorageBackend_Backend()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageBackend_Noop struct {
	Noop *Noop `protobuf:"bytes,1,opt,name=noop,proto3,oneof" json:"noop,omitempty"`
}
type StorageBackend_Local struct {
	Local *Local `protobuf:"bytes,2,opt,name=local,proto3,oneof" json:"local,omitempty"`
}
type StorageBackend_S3 struct {
	S3 *S3 `protobuf:"bytes,3,opt,name=s3,proto3,oneof" json:"s3,omitempty"`
}
type StorageBackend_Gcs struct {
	Gcs *GCS `protobuf:"bytes,4,opt,name=gcs,proto3,oneof" json:"gcs,omitempty"`
}
type StorageBackend_CloudDynamic struct {
	CloudDynamic *CloudDynamic `protobuf:"bytes,5,opt,name=cloud_dynamic,json=cloudDynamic,proto3,oneof" json:"cloud_dynamic,omitempty"`
}
type StorageBackend_Hdfs struct {
	Hdfs *HDFS `protobuf:"bytes,6,opt,name=hdfs,proto3,oneof" json:"hdfs,omitempty"`
}
type StorageBackend_AzureBlobStorage struct {
	AzureBlobStorage *AzureBlobStorage `protobuf:"bytes,7,opt,name=azure_blob_storage,json=azureBlobStorage,proto3,oneof" json:"azure_blob_storage,omitempty"`
}

func (*StorageBackend_Noop) isStorageBackend_Backend()             {}
func (*StorageBackend_Local) isStorageBackend_Backend()            {}
func (*StorageBackend_S3) isStorageBackend_Backend()               {}
func (*StorageBackend_Gcs) isStorageBackend_Backend()              {}
func (*StorageBackend_CloudDynamic) isStorageBackend_Backend()     {}
func (*StorageBackend_Hdfs) isStorageBackend_Backend()             {}
func (*StorageBackend_AzureBlobStorage) isStorageBackend_Backend() {}

func (m *StorageBackend) GetBackend() isStorageBackend_Backend {
	if m != nil {
		return m.Backend
	}
	return nil
}

func (m *StorageBackend) GetNoop() *Noop {
	if x, ok := m.GetBackend().(*StorageBackend_Noop); ok {
		return x.Noop
	}
	return nil
}

func (m *StorageBackend) GetLocal() *Local {
	if x, ok := m.GetBackend().(*StorageBackend_Local); ok {
		return x.Local
	}
	return nil
}

func (m *StorageBackend) GetS3() *S3 {
	if x, ok := m.GetBackend().(*StorageBackend_S3); ok {
		return x.S3
	}
	return nil
}

func (m *StorageBackend) GetGcs() *GCS {
	if x, ok := m.GetBackend().(*StorageBackend_Gcs); ok {
		return x.Gcs
	}
	return nil
}

func (m *StorageBackend) GetCloudDynamic() *CloudDynamic {
	if x, ok := m.GetBackend().(*StorageBackend_CloudDynamic); ok {
		return x.CloudDynamic
	}
	return nil
}

func (m *StorageBackend) GetHdfs() *HDFS {
	if x, ok := m.GetBackend().(*StorageBackend_Hdfs); ok {
		return x.Hdfs
	}
	return nil
}

func (m *StorageBackend) GetAzureBlobStorage() *AzureBlobStorage {
	if x, ok := m.GetBackend().(*StorageBackend_AzureBlobStorage); ok {
		return x.AzureBlobStorage
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StorageBackend) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StorageBackend_Noop)(nil),
		(*StorageBackend_Local)(nil),
		(*StorageBackend_S3)(nil),
		(*StorageBackend_Gcs)(nil),
		(*StorageBackend_CloudDynamic)(nil),
		(*StorageBackend_Hdfs)(nil),
		(*StorageBackend_AzureBlobStorage)(nil),
	}
}

// Noop storage backend saves files into void.
type Noop struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Noop) Reset()         { *m = Noop{} }
func (m *Noop) String() string { return proto.CompactTextString(m) }
func (*Noop) ProtoMessage()    {}
func (*Noop) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{11}
}
func (m *Noop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Noop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Noop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Noop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Noop.Merge(m, src)
}
func (m *Noop) XXX_Size() int {
	return m.Size()
}
func (m *Noop) XXX_DiscardUnknown() {
	xxx_messageInfo_Noop.DiscardUnknown(m)
}

var xxx_messageInfo_Noop proto.InternalMessageInfo

// Local storage backend saves files into local disk
type Local struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Local) Reset()         { *m = Local{} }
func (m *Local) String() string { return proto.CompactTextString(m) }
func (*Local) ProtoMessage()    {}
func (*Local) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{12}
}
func (m *Local) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Local) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Local.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Local) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Local.Merge(m, src)
}
func (m *Local) XXX_Size() int {
	return m.Size()
}
func (m *Local) XXX_DiscardUnknown() {
	xxx_messageInfo_Local.DiscardUnknown(m)
}

var xxx_messageInfo_Local proto.InternalMessageInfo

func (m *Local) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// S3 storage backend saves files into S3 compatible storages
// For non-aws providers, endpoint must be provided
type S3 struct {
	Endpoint     string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Region       string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	Bucket       string `protobuf:"bytes,3,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix       string `protobuf:"bytes,4,opt,name=prefix,proto3" json:"prefix,omitempty"`
	StorageClass string `protobuf:"bytes,5,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	// server side encryption
	Sse                  string   `protobuf:"bytes,6,opt,name=sse,proto3" json:"sse,omitempty"`
	Acl                  string   `protobuf:"bytes,7,opt,name=acl,proto3" json:"acl,omitempty"`
	AccessKey            string   `protobuf:"bytes,8,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretAccessKey      string   `protobuf:"bytes,9,opt,name=secret_access_key,json=secretAccessKey,proto3" json:"secret_access_key,omitempty"`
	ForcePathStyle       bool     `protobuf:"varint,10,opt,name=force_path_style,json=forcePathStyle,proto3" json:"force_path_style,omitempty"`
	SseKmsKeyId          string   `protobuf:"bytes,11,opt,name=sse_kms_key_id,json=sseKmsKeyId,proto3" json:"sse_kms_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S3) Reset()         { *m = S3{} }
func (m *S3) String() string { return proto.CompactTextString(m) }
func (*S3) ProtoMessage()    {}
func (*S3) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{13}
}
func (m *S3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3.Merge(m, src)
}
func (m *S3) XXX_Size() int {
	return m.Size()
}
func (m *S3) XXX_DiscardUnknown() {
	xxx_messageInfo_S3.DiscardUnknown(m)
}

var xxx_messageInfo_S3 proto.InternalMessageInfo

func (m *S3) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *S3) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *S3) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *S3) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *S3) GetStorageClass() string {
	if m != nil {
		return m.StorageClass
	}
	return ""
}

func (m *S3) GetSse() string {
	if m != nil {
		return m.Sse
	}
	return ""
}

func (m *S3) GetAcl() string {
	if m != nil {
		return m.Acl
	}
	return ""
}

func (m *S3) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *S3) GetSecretAccessKey() string {
	if m != nil {
		return m.SecretAccessKey
	}
	return ""
}

func (m *S3) GetForcePathStyle() bool {
	if m != nil {
		return m.ForcePathStyle
	}
	return false
}

func (m *S3) GetSseKmsKeyId() string {
	if m != nil {
		return m.SseKmsKeyId
	}
	return ""
}

// GCS storage backend saves files into google cloud storage.
type GCS struct {
	Endpoint     string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Bucket       string `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix       string `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
	StorageClass string `protobuf:"bytes,4,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	// If not empty, applies a predefined set of access controls.
	// See https://cloud.google.com/storage/docs/access-control/lists#predefined-acl
	// for valid values.
	PredefinedAcl string `protobuf:"bytes,5,opt,name=predefined_acl,json=predefinedAcl,proto3" json:"predefined_acl,omitempty"`
	// Service Account Credentials JSON blob
	// You can get one from https://console.cloud.google.com/apis/credentials, and
	// copy the content, set it as string here.
	CredentialsBlob      string   `protobuf:"bytes,6,opt,name=credentials_blob,json=credentialsBlob,proto3" json:"credentials_blob,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GCS) Reset()         { *m = GCS{} }
func (m *GCS) String() string { return proto.CompactTextString(m) }
func (*GCS) ProtoMessage()    {}
func (*GCS) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{14}
}
func (m *GCS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GCS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GCS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCS.Merge(m, src)
}
func (m *GCS) XXX_Size() int {
	return m.Size()
}
func (m *GCS) XXX_DiscardUnknown() {
	xxx_messageInfo_GCS.DiscardUnknown(m)
}

var xxx_messageInfo_GCS proto.InternalMessageInfo

func (m *GCS) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *GCS) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *GCS) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *GCS) GetStorageClass() string {
	if m != nil {
		return m.StorageClass
	}
	return ""
}

func (m *GCS) GetPredefinedAcl() string {
	if m != nil {
		return m.PredefinedAcl
	}
	return ""
}

func (m *GCS) GetCredentialsBlob() string {
	if m != nil {
		return m.CredentialsBlob
	}
	return ""
}

// AzureBlobStorage storage backend saves files into azure blob storage.
type AzureBlobStorage struct {
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Alias: container
	Bucket string `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// Notice: prefix starts without `/`, otherwise the first directory's name is empty.
	Prefix string `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Alias: access_tier.
	// See https://docs.microsoft.com/en-us/azure/storage/blobs/access-tiers-overview
	StorageClass string `protobuf:"bytes,4,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	// if empty, try to read account_name from the node's environment variable $AZURE_STORAGE_ACCOUNT.
	AccountName string `protobuf:"bytes,5,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	// Use shared key to access the azure blob
	// If the node's environment variables($AZURE_CLIENT_ID, $AZURE_TENANT_ID, $AZURE_CLIENT_SECRET) exist,
	// prefer to use token to access the azure blob.
	//
	//   See https://docs.microsoft.com/en-us/azure/storage/common/identity-library-acquire-token?toc=/azure/storage/blobs/toc.json
	//
	// Otherwise, if empty, try to read shared key from the node's environment variable $AZURE_STORAGE_KEY.
	SharedKey            string   `protobuf:"bytes,6,opt,name=shared_key,json=sharedKey,proto3" json:"shared_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AzureBlobStorage) Reset()         { *m = AzureBlobStorage{} }
func (m *AzureBlobStorage) String() string { return proto.CompactTextString(m) }
func (*AzureBlobStorage) ProtoMessage()    {}
func (*AzureBlobStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{15}
}
func (m *AzureBlobStorage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureBlobStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AzureBlobStorage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AzureBlobStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureBlobStorage.Merge(m, src)
}
func (m *AzureBlobStorage) XXX_Size() int {
	return m.Size()
}
func (m *AzureBlobStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureBlobStorage.DiscardUnknown(m)
}

var xxx_messageInfo_AzureBlobStorage proto.InternalMessageInfo

func (m *AzureBlobStorage) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *AzureBlobStorage) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *AzureBlobStorage) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *AzureBlobStorage) GetStorageClass() string {
	if m != nil {
		return m.StorageClass
	}
	return ""
}

func (m *AzureBlobStorage) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *AzureBlobStorage) GetSharedKey() string {
	if m != nil {
		return m.SharedKey
	}
	return ""
}

type Bucket struct {
	Endpoint             string   `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Region               string   `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
	Bucket               string   `protobuf:"bytes,4,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix               string   `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`
	StorageClass         string   `protobuf:"bytes,6,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Bucket) Reset()         { *m = Bucket{} }
func (m *Bucket) String() string { return proto.CompactTextString(m) }
func (*Bucket) ProtoMessage()    {}
func (*Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{16}
}
func (m *Bucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bucket.Merge(m, src)
}
func (m *Bucket) XXX_Size() int {
	return m.Size()
}
func (m *Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_Bucket proto.InternalMessageInfo

func (m *Bucket) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Bucket) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Bucket) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *Bucket) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Bucket) GetStorageClass() string {
	if m != nil {
		return m.StorageClass
	}
	return ""
}

// CloudDynamic allows testing new cloud providers and new fields without changing protobuf definitions
type CloudDynamic struct {
	Bucket               *Bucket           `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	ProviderName         string            `protobuf:"bytes,2,opt,name=provider_name,json=providerName,proto3" json:"provider_name,omitempty"`
	Attrs                map[string]string `protobuf:"bytes,3,rep,name=attrs,proto3" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CloudDynamic) Reset()         { *m = CloudDynamic{} }
func (m *CloudDynamic) String() string { return proto.CompactTextString(m) }
func (*CloudDynamic) ProtoMessage()    {}
func (*CloudDynamic) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{17}
}
func (m *CloudDynamic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudDynamic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudDynamic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudDynamic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudDynamic.Merge(m, src)
}
func (m *CloudDynamic) XXX_Size() int {
	return m.Size()
}
func (m *CloudDynamic) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudDynamic.DiscardUnknown(m)
}

var xxx_messageInfo_CloudDynamic proto.InternalMessageInfo

func (m *CloudDynamic) GetBucket() *Bucket {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *CloudDynamic) GetProviderName() string {
	if m != nil {
		return m.ProviderName
	}
	return ""
}

func (m *CloudDynamic) GetAttrs() map[string]string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// HDFS storage backend saves file into HDFS compatible storages
type HDFS struct {
	//  a URL: hdfs:///some/path or hdfs://host:port/some/path
	Remote               string   `protobuf:"bytes,1,opt,name=remote,proto3" json:"remote,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HDFS) Reset()         { *m = HDFS{} }
func (m *HDFS) String() string { return proto.CompactTextString(m) }
func (*HDFS) ProtoMessage()    {}
func (*HDFS) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{18}
}
func (m *HDFS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HDFS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HDFS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HDFS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HDFS.Merge(m, src)
}
func (m *HDFS) XXX_Size() int {
	return m.Size()
}
func (m *HDFS) XXX_DiscardUnknown() {
	xxx_messageInfo_HDFS.DiscardUnknown(m)
}

var xxx_messageInfo_HDFS proto.InternalMessageInfo

func (m *HDFS) GetRemote() string {
	if m != nil {
		return m.Remote
	}
	return ""
}

type BackupResponse struct {
	Error    *Error  `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	StartKey []byte  `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte  `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Files    []*File `protobuf:"bytes,4,rep,name=files,proto3" json:"files,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion           kvrpcpb.APIVersion `protobuf:"varint,5,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *BackupResponse) Reset()         { *m = BackupResponse{} }
func (m *BackupResponse) String() string { return proto.CompactTextString(m) }
func (*BackupResponse) ProtoMessage()    {}
func (*BackupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{19}
}
func (m *BackupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupResponse.Merge(m, src)
}
func (m *BackupResponse) XXX_Size() int {
	return m.Size()
}
func (m *BackupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BackupResponse proto.InternalMessageInfo

func (m *BackupResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *BackupResponse) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *BackupResponse) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *BackupResponse) GetFiles() []*File {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *BackupResponse) GetApiVersion() kvrpcpb.APIVersion {
	if m != nil {
		return m.ApiVersion
	}
	return kvrpcpb.APIVersion_V1
}

type ExternalStorageRestoreRequest struct {
	StorageBackend       *StorageBackend `protobuf:"bytes,1,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	ObjectName           string          `protobuf:"bytes,2,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	RestoreName          string          `protobuf:"bytes,3,opt,name=restore_name,json=restoreName,proto3" json:"restore_name,omitempty"`
	ContentLength        uint64          `protobuf:"varint,4,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ExternalStorageRestoreRequest) Reset()         { *m = ExternalStorageRestoreRequest{} }
func (m *ExternalStorageRestoreRequest) String() string { return proto.CompactTextString(m) }
func (*ExternalStorageRestoreRequest) ProtoMessage()    {}
func (*ExternalStorageRestoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{20}
}
func (m *ExternalStorageRestoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorageRestoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalStorageRestoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalStorageRestoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorageRestoreRequest.Merge(m, src)
}
func (m *ExternalStorageRestoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorageRestoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorageRestoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorageRestoreRequest proto.InternalMessageInfo

func (m *ExternalStorageRestoreRequest) GetStorageBackend() *StorageBackend {
	if m != nil {
		return m.StorageBackend
	}
	return nil
}

func (m *ExternalStorageRestoreRequest) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *ExternalStorageRestoreRequest) GetRestoreName() string {
	if m != nil {
		return m.RestoreName
	}
	return ""
}

func (m *ExternalStorageRestoreRequest) GetContentLength() uint64 {
	if m != nil {
		return m.ContentLength
	}
	return 0
}

type ExternalStorageRestoreResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExternalStorageRestoreResponse) Reset()         { *m = ExternalStorageRestoreResponse{} }
func (m *ExternalStorageRestoreResponse) String() string { return proto.CompactTextString(m) }
func (*ExternalStorageRestoreResponse) ProtoMessage()    {}
func (*ExternalStorageRestoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{21}
}
func (m *ExternalStorageRestoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorageRestoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalStorageRestoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalStorageRestoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorageRestoreResponse.Merge(m, src)
}
func (m *ExternalStorageRestoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorageRestoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorageRestoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorageRestoreResponse proto.InternalMessageInfo

type ExternalStorageSaveRequest struct {
	StorageBackend       *StorageBackend `protobuf:"bytes,1,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	ObjectName           string          `protobuf:"bytes,2,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	ContentLength        uint64          `protobuf:"varint,3,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ExternalStorageSaveRequest) Reset()         { *m = ExternalStorageSaveRequest{} }
func (m *ExternalStorageSaveRequest) String() string { return proto.CompactTextString(m) }
func (*ExternalStorageSaveRequest) ProtoMessage()    {}
func (*ExternalStorageSaveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{22}
}
func (m *ExternalStorageSaveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorageSaveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalStorageSaveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalStorageSaveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorageSaveRequest.Merge(m, src)
}
func (m *ExternalStorageSaveRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorageSaveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorageSaveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorageSaveRequest proto.InternalMessageInfo

func (m *ExternalStorageSaveRequest) GetStorageBackend() *StorageBackend {
	if m != nil {
		return m.StorageBackend
	}
	return nil
}

func (m *ExternalStorageSaveRequest) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *ExternalStorageSaveRequest) GetContentLength() uint64 {
	if m != nil {
		return m.ContentLength
	}
	return 0
}

type ExternalStorageSaveResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExternalStorageSaveResponse) Reset()         { *m = ExternalStorageSaveResponse{} }
func (m *ExternalStorageSaveResponse) String() string { return proto.CompactTextString(m) }
func (*ExternalStorageSaveResponse) ProtoMessage()    {}
func (*ExternalStorageSaveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{23}
}
func (m *ExternalStorageSaveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorageSaveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalStorageSaveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalStorageSaveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorageSaveResponse.Merge(m, src)
}
func (m *ExternalStorageSaveResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorageSaveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorageSaveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorageSaveResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("backup.CompressionType", CompressionType_name, CompressionType_value)
	proto.RegisterType((*BackupMeta)(nil), "backup.BackupMeta")
	proto.RegisterType((*File)(nil), "backup.File")
	proto.RegisterType((*MetaFile)(nil), "backup.MetaFile")
	proto.RegisterType((*PlacementPolicy)(nil), "backup.PlacementPolicy")
	proto.RegisterType((*Schema)(nil), "backup.Schema")
	proto.RegisterType((*RawRange)(nil), "backup.RawRange")
	proto.RegisterType((*ClusterIDError)(nil), "backup.ClusterIDError")
	proto.RegisterType((*Error)(nil), "backup.Error")
	proto.RegisterType((*CipherInfo)(nil), "backup.CipherInfo")
	proto.RegisterType((*BackupRequest)(nil), "backup.BackupRequest")
	proto.RegisterType((*StorageBackend)(nil), "backup.StorageBackend")
	proto.RegisterType((*Noop)(nil), "backup.Noop")
	proto.RegisterType((*Local)(nil), "backup.Local")
	proto.RegisterType((*S3)(nil), "backup.S3")
	proto.RegisterType((*GCS)(nil), "backup.GCS")
	proto.RegisterType((*AzureBlobStorage)(nil), "backup.AzureBlobStorage")
	proto.RegisterType((*Bucket)(nil), "backup.Bucket")
	proto.RegisterType((*CloudDynamic)(nil), "backup.CloudDynamic")
	proto.RegisterMapType((map[string]string)(nil), "backup.CloudDynamic.AttrsEntry")
	proto.RegisterType((*HDFS)(nil), "backup.HDFS")
	proto.RegisterType((*BackupResponse)(nil), "backup.BackupResponse")
	proto.RegisterType((*ExternalStorageRestoreRequest)(nil), "backup.ExternalStorageRestoreRequest")
	proto.RegisterType((*ExternalStorageRestoreResponse)(nil), "backup.ExternalStorageRestoreResponse")
	proto.RegisterType((*ExternalStorageSaveRequest)(nil), "backup.ExternalStorageSaveRequest")
	proto.RegisterType((*ExternalStorageSaveResponse)(nil), "backup.ExternalStorageSaveResponse")
}

func init() { proto.RegisterFile("brpb.proto", fileDescriptor_483d1f48d58a4885) }

var fileDescriptor_483d1f48d58a4885 = []byte{
	// 2069 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xdd, 0x6e, 0x1b, 0xc7,
	0xf5, 0xd7, 0x92, 0xcb, 0x8f, 0x3d, 0xcb, 0x2f, 0x4f, 0xfc, 0x77, 0x08, 0xf9, 0x6f, 0x99, 0x59,
	0xc3, 0xae, 0x9a, 0x00, 0x4a, 0x2b, 0x39, 0x81, 0x51, 0xa3, 0x08, 0x24, 0x59, 0x89, 0x14, 0x39,
	0xaa, 0x3a, 0x4a, 0x5b, 0xd4, 0x37, 0x8b, 0xe1, 0xee, 0x48, 0xda, 0x72, 0xb9, 0xbb, 0xdd, 0x19,
	0xd2, 0x66, 0xde, 0xa2, 0x77, 0x7d, 0x81, 0xa2, 0x7d, 0x8c, 0xde, 0x14, 0x4d, 0x90, 0x5e, 0x04,
	0xe8, 0x4d, 0x2f, 0x0b, 0xf7, 0x45, 0x8a, 0x33, 0x33, 0xbb, 0x22, 0x65, 0x51, 0x72, 0x8b, 0x22,
	0x57, 0x9c, 0xf9, 0x9d, 0x33, 0x5f, 0xe7, 0xfc, 0xce, 0xc7, 0x12, 0x60, 0x98, 0x67, 0xc3, 0x8d,
	0x2c, 0x4f, 0x65, 0x4a, 0xea, 0x43, 0x16, 0x8c, 0x26, 0xd9, 0x6a, 0x7b, 0x34, 0xcd, 0xb3, 0xa0,
	0x80, 0x57, 0xdb, 0x3c, 0xcf, 0xd3, 0x52, 0x6b, 0x95, 0xf0, 0x24, 0xc8, 0x67, 0x99, 0x8c, 0xd2,
	0xa4, 0xc4, 0x6e, 0x9f, 0xa5, 0x67, 0xa9, 0x1a, 0x7e, 0x88, 0x23, 0x83, 0x76, 0xf3, 0x89, 0x90,
	0x6a, 0xa8, 0x01, 0xef, 0x8f, 0x75, 0x80, 0x1d, 0x75, 0xc6, 0x17, 0x5c, 0x32, 0x72, 0x0f, 0x20,
	0x88, 0x27, 0x42, 0xf2, 0xdc, 0x8f, 0xc2, 0xbe, 0x35, 0xb0, 0xd6, 0x6d, 0xea, 0x18, 0xe4, 0x20,
	0x24, 0x3f, 0x80, 0x6e, 0x21, 0x9e, 0xf2, 0x5c, 0x44, 0x69, 0xd2, 0xaf, 0x0c, 0xac, 0x75, 0x87,
	0x76, 0x0c, 0xfc, 0x4b, 0x8d, 0xe2, 0x3e, 0xc3, 0x0b, 0x1d, 0x57, 0xe9, 0x38, 0xc3, 0x52, 0xdc,
	0x87, 0x46, 0x21, 0x6b, 0x0d, 0xac, 0xf5, 0x1a, 0x2d, 0xa6, 0xc4, 0x83, 0xda, 0x69, 0x14, 0x73,
	0xd1, 0xb7, 0x07, 0xd5, 0x75, 0x77, 0xb3, 0xb5, 0xa1, 0x0d, 0xb0, 0xf1, 0x69, 0x14, 0x73, 0xaa,
	0x45, 0xe4, 0x43, 0x00, 0x1c, 0xf8, 0x51, 0x12, 0xf2, 0x57, 0xfd, 0xf6, 0xc0, 0x5a, 0x77, 0x37,
	0x7b, 0x85, 0x22, 0x3e, 0x43, 0x29, 0x3b, 0xa8, 0x73, 0x80, 0x2a, 0xe4, 0x01, 0xb4, 0x85, 0x64,
	0xb9, 0x2c, 0x2f, 0x54, 0x53, 0x0f, 0x6b, 0x29, 0xb0, 0xb8, 0xd3, 0x7d, 0x70, 0x79, 0x12, 0x96,
	0x2a, 0x75, 0xa5, 0x02, 0x3c, 0x09, 0x0b, 0x85, 0x75, 0x68, 0x88, 0xe0, 0x9c, 0x8f, 0x99, 0xe8,
	0x37, 0xd4, 0xe5, 0x3a, 0xc5, 0x99, 0x27, 0x0a, 0xa6, 0x85, 0x98, 0x6c, 0x41, 0x4b, 0x0f, 0xcd,
	0x15, 0x3b, 0x4b, 0xae, 0xe8, 0x6a, 0x2d, 0x7d, 0xc9, 0x55, 0x70, 0x22, 0xe1, 0xe7, 0xec, 0xa5,
	0x3f, 0x9a, 0xf6, 0x9b, 0x03, 0x6b, 0xbd, 0x49, 0x1b, 0x91, 0xa0, 0xec, 0xe5, 0xe1, 0x14, 0x5f,
	0x8c, 0x82, 0x9c, 0x25, 0x67, 0x5c, 0xf4, 0x1d, 0x75, 0x7a, 0xb9, 0x1d, 0x65, 0x2f, 0x29, 0x0a,
	0xa8, 0x93, 0x9b, 0x91, 0x20, 0x4f, 0xa0, 0x5b, 0x2e, 0x30, 0x97, 0xe8, 0x2e, 0xb9, 0x44, 0xbb,
	0x58, 0xa5, 0xaf, 0x41, 0xc0, 0x0e, 0xc3, 0x58, 0xf4, 0x61, 0x60, 0xad, 0xb7, 0xa8, 0x1a, 0x93,
	0x1f, 0x83, 0x1b, 0x86, 0xb1, 0xde, 0x87, 0x8b, 0x7e, 0x6f, 0xc9, 0x4e, 0x10, 0x86, 0xf1, 0x81,
	0xd6, 0x41, 0x93, 0x6b, 0xb1, 0x9f, 0x73, 0x31, 0x89, 0x65, 0xff, 0x96, 0xe2, 0x40, 0x4b, 0x83,
	0x54, 0x61, 0xe4, 0x31, 0xb8, 0x2c, 0x8b, 0x4a, 0x93, 0x93, 0x81, 0xb5, 0xde, 0xd9, 0x7c, 0x67,
	0xa3, 0xe0, 0xfa, 0xf6, 0xf1, 0x81, 0xb1, 0x3d, 0x05, 0x96, 0x45, 0x85, 0x1f, 0xb6, 0xa0, 0x99,
	0xa5, 0x71, 0x14, 0x44, 0x5c, 0xf4, 0xdf, 0x51, 0xa6, 0x78, 0xb7, 0xb8, 0xca, 0x71, 0xcc, 0x02,
	0x3e, 0xe6, 0x89, 0x3c, 0x46, 0x85, 0x19, 0x2d, 0x15, 0xc9, 0x63, 0xb8, 0x93, 0xf0, 0x97, 0x7e,
	0x90, 0xc6, 0x31, 0xc3, 0x38, 0x11, 0x3e, 0x4f, 0xd8, 0x30, 0xe6, 0x61, 0xff, 0xb6, 0xba, 0xd8,
	0xed, 0x84, 0xbf, 0xdc, 0x2d, 0x85, 0x7b, 0x5a, 0xf6, 0xb9, 0xdd, 0xac, 0xf6, 0x6c, 0x6a, 0x67,
	0x4c, 0x9e, 0x7b, 0xdf, 0x54, 0xc0, 0xc6, 0x67, 0xa2, 0x85, 0x12, 0x36, 0xe6, 0x2a, 0x3a, 0x1c,
	0xaa, 0xc6, 0xe4, 0x0e, 0xd4, 0xc5, 0x39, 0xdb, 0xfc, 0xe8, 0x63, 0x15, 0x0f, 0x2d, 0x6a, 0x66,
	0xe4, 0x2e, 0x38, 0x9a, 0x79, 0x23, 0x3e, 0xeb, 0x57, 0x95, 0xa8, 0xa9, 0x80, 0x43, 0x3e, 0x23,
	0xef, 0x42, 0x03, 0x19, 0x87, 0x22, 0x5b, 0xaf, 0xe2, 0x49, 0x88, 0x82, 0xff, 0x0d, 0x5f, 0x57,
	0xa1, 0x19, 0xe4, 0xc1, 0xc7, 0x8f, 0x5f, 0xa5, 0x79, 0xbf, 0xa1, 0xa4, 0xe5, 0x1c, 0xef, 0x25,
	0x53, 0xc9, 0x62, 0x7f, 0x34, 0x15, 0x8a, 0x6c, 0x36, 0x6d, 0x2a, 0xe0, 0x70, 0x2a, 0x70, 0x67,
	0x2d, 0x1c, 0xce, 0xa4, 0xa2, 0x9b, 0xda, 0x59, 0x41, 0x3b, 0x88, 0x90, 0x0e, 0x54, 0x82, 0x53,
	0xc5, 0x10, 0x87, 0x56, 0x82, 0x53, 0xb4, 0x88, 0x88, 0xbe, 0xe2, 0x2a, 0xce, 0x6d, 0xaa, 0xc6,
	0x78, 0x42, 0x10, 0x65, 0xe7, 0x98, 0x48, 0xa6, 0x2a, 0xc8, 0x5b, 0xb4, 0xa9, 0x81, 0x83, 0xa9,
	0xf7, 0x77, 0x0b, 0x9a, 0x05, 0x6d, 0xc8, 0x07, 0x00, 0x63, 0x2e, 0x99, 0xaf, 0xe3, 0xde, 0xba,
	0x22, 0xee, 0x9d, 0xb1, 0xd1, 0x15, 0xa8, 0x1c, 0xb2, 0x52, 0xb9, 0x72, 0x95, 0x32, 0xca, 0xb5,
	0xf2, 0x5c, 0xc4, 0x56, 0xaf, 0x8f, 0xd8, 0xc5, 0x00, 0xb3, 0x6f, 0x0e, 0xb0, 0x22, 0x4c, 0x6a,
	0x83, 0x6a, 0x11, 0x26, 0xde, 0x43, 0xe8, 0x5e, 0x22, 0x20, 0xaa, 0x45, 0xc9, 0x69, 0xaa, 0xb8,
	0xd2, 0xa2, 0x6a, 0xec, 0x7d, 0x63, 0x41, 0x5d, 0x9f, 0x8f, 0x86, 0x0c, 0x87, 0x46, 0x58, 0x09,
	0x87, 0xe4, 0x36, 0xd4, 0x24, 0x32, 0xcf, 0xb0, 0x48, 0x4f, 0x16, 0x1c, 0x59, 0xbd, 0xce, 0x91,
	0xf6, 0xf5, 0x8e, 0xac, 0xbd, 0xe1, 0xc8, 0x1f, 0x42, 0x4f, 0x46, 0xa7, 0x31, 0x13, 0xe7, 0x7e,
	0xce, 0xb3, 0x38, 0x0a, 0x98, 0x50, 0x44, 0x6a, 0xd3, 0xae, 0xc1, 0xa9, 0x81, 0xf1, 0x6a, 0x42,
	0x32, 0x29, 0x14, 0x95, 0x5a, 0x54, 0x4f, 0xbc, 0x63, 0x68, 0x16, 0xd6, 0x59, 0xe4, 0xba, 0xb5,
	0x9c, 0xeb, 0x95, 0x05, 0xae, 0x6b, 0x2e, 0x55, 0x0b, 0x2e, 0x79, 0xcf, 0xa0, 0xb3, 0x6b, 0xea,
	0xcd, 0xb3, 0x3d, 0xac, 0x72, 0x58, 0x2c, 0x82, 0x49, 0x9e, 0xf3, 0x44, 0x9a, 0x82, 0x54, 0x4c,
	0x51, 0x92, 0xf3, 0xdf, 0x4e, 0xb8, 0x90, 0x6a, 0x53, 0x9b, 0x16, 0x53, 0xef, 0x6f, 0x16, 0xd4,
	0xf4, 0xea, 0x1e, 0x54, 0xc7, 0xe2, 0xcc, 0x04, 0x2b, 0x0e, 0xc9, 0x0e, 0xf4, 0x2e, 0x6a, 0x9c,
	0xaf, 0x2a, 0xa9, 0x3a, 0xdf, 0xdd, 0xbc, 0x53, 0x78, 0x7c, 0xf1, 0x06, 0xfb, 0x2b, 0x65, 0x7d,
	0x3b, 0x08, 0xf5, 0xae, 0x1b, 0xd0, 0x1c, 0x4d, 0xcd, 0x5a, 0x5b, 0xad, 0xbd, 0x55, 0xa6, 0xad,
	0x43, 0x3e, 0x2b, 0x96, 0x35, 0x46, 0x53, 0xad, 0xbf, 0x05, 0xad, 0x9c, 0x9f, 0x45, 0x69, 0x62,
	0xd6, 0xd4, 0xd4, 0x9a, 0xce, 0x46, 0x51, 0xc7, 0x8b, 0x05, 0xae, 0xd6, 0x52, 0xd3, 0x9d, 0x26,
	0xd4, 0x43, 0x2e, 0x59, 0x14, 0x7b, 0x31, 0xc0, 0xae, 0x8e, 0x9d, 0xe4, 0x34, 0x25, 0x9f, 0x80,
	0x6b, 0x42, 0x4b, 0xce, 0x32, 0x9d, 0x87, 0x3a, 0x9b, 0x6b, 0x1b, 0x0b, 0x4d, 0xc0, 0x5e, 0x39,
	0xf9, 0x82, 0xcb, 0xf3, 0x34, 0xa4, 0xa0, 0x97, 0x7c, 0x39, 0xcb, 0xb8, 0xaa, 0xf2, 0x7a, 0x83,
	0x0b, 0x7f, 0x98, 0x68, 0x3d, 0xe4, 0x33, 0xef, 0xaf, 0x36, 0xb4, 0x77, 0x4c, 0x9e, 0x56, 0xe6,
	0xbc, 0xa9, 0x2d, 0x58, 0xf0, 0x7c, 0x65, 0xb9, 0xe7, 0xab, 0xd7, 0x67, 0x39, 0xfb, 0xe6, 0x2c,
	0x57, 0x7b, 0x23, 0xcb, 0xdd, 0xc3, 0xc8, 0x95, 0xdc, 0x8f, 0xa3, 0x71, 0x24, 0x4d, 0x9e, 0x73,
	0x10, 0x79, 0x8e, 0x00, 0x19, 0x80, 0x1b, 0xa4, 0x89, 0x26, 0x4c, 0x30, 0x53, 0xa9, 0xae, 0x4d,
	0xe7, 0x21, 0xf2, 0x09, 0x74, 0x85, 0x4c, 0x73, 0x76, 0xc6, 0x7d, 0xf4, 0x3e, 0x4f, 0x42, 0x95,
	0xf1, 0xe6, 0xd8, 0x70, 0xa2, 0xc5, 0x3b, 0x5a, 0x4a, 0x3b, 0x62, 0x61, 0xbe, 0x58, 0xb8, 0x61,
	0xb1, 0x70, 0x6b, 0x76, 0xbb, 0x65, 0xa6, 0x44, 0xee, 0xa5, 0xe3, 0x2c, 0xe7, 0x02, 0x2f, 0xaf,
	0xfd, 0xd7, 0x52, 0xfe, 0x2b, 0x6b, 0xd8, 0xee, 0x85, 0x1c, 0x9d, 0x45, 0xbb, 0xc1, 0x22, 0x40,
	0x3e, 0x80, 0x5b, 0xf3, 0x7b, 0xc4, 0x7c, 0xca, 0x63, 0xd5, 0x05, 0xd5, 0xe8, 0xfc, 0xe6, 0xcf,
	0x11, 0x27, 0x5b, 0x25, 0x57, 0x54, 0x1e, 0xd2, 0x9d, 0x08, 0x29, 0xcf, 0x2a, 0x49, 0x55, 0xf0,
	0x43, 0x11, 0xec, 0x29, 0x74, 0x43, 0x21, 0xfd, 0xf9, 0xda, 0xdc, 0x5d, 0x5e, 0x9b, 0xdb, 0xa1,
	0x90, 0xdb, 0x65, 0x79, 0xfe, 0xdc, 0x6e, 0xd6, 0x7b, 0x0d, 0x53, 0x33, 0xbf, 0xab, 0x40, 0x67,
	0xd1, 0x7a, 0xc4, 0x03, 0x3b, 0x49, 0xd3, 0x4c, 0x91, 0x68, 0x2e, 0x75, 0x1f, 0xa5, 0x69, 0xb6,
	0xbf, 0x42, 0x95, 0x8c, 0x3c, 0x84, 0x5a, 0x9c, 0x06, 0x2c, 0x56, 0x5c, 0x72, 0x37, 0xdb, 0x85,
	0xd2, 0x73, 0x04, 0xf7, 0x57, 0xa8, 0x96, 0x92, 0xff, 0x87, 0x8a, 0xd8, 0x32, 0xa1, 0x0b, 0xa5,
	0xb3, 0xb6, 0xf6, 0x57, 0x68, 0x45, 0x6c, 0x91, 0xfb, 0x50, 0x3d, 0x0b, 0x84, 0x89, 0x4e, 0xb7,
	0x10, 0x7f, 0xb6, 0x7b, 0xb2, 0xbf, 0x42, 0x51, 0x42, 0x9e, 0x42, 0x3b, 0x88, 0xd3, 0x49, 0xe8,
	0x87, 0xb3, 0x84, 0x8d, 0xa3, 0xc0, 0x04, 0xe5, 0xed, 0x8b, 0x24, 0x90, 0x4e, 0xc2, 0x67, 0x5a,
	0xb6, 0xbf, 0x42, 0x5b, 0xc1, 0xdc, 0x1c, 0x9f, 0x71, 0x1e, 0x9e, 0xea, 0x6c, 0x39, 0xf7, 0x8c,
	0xfd, 0x67, 0x9f, 0xe2, 0xfe, 0x4a, 0x46, 0xf6, 0x81, 0xb0, 0xaf, 0x26, 0x39, 0xf7, 0x87, 0x71,
	0x3a, 0xf4, 0x0d, 0x6b, 0x14, 0x45, 0xdd, 0xcd, 0x7e, 0xb1, 0x62, 0x1b, 0x35, 0x76, 0xe2, 0x74,
	0x68, 0xec, 0xb4, 0xbf, 0x42, 0x7b, 0xec, 0x12, 0xb6, 0xe3, 0x40, 0xc3, 0x70, 0xd3, 0xab, 0x83,
	0x8d, 0xb6, 0xf2, 0xee, 0x42, 0x4d, 0x99, 0x03, 0x4b, 0x0c, 0xda, 0xba, 0x68, 0x47, 0x94, 0xdd,
	0xbf, 0xad, 0x40, 0xe5, 0x64, 0x0b, 0x0b, 0x07, 0x4f, 0xc2, 0x2c, 0x8d, 0x4c, 0xea, 0x74, 0x68,
	0x39, 0xc7, 0x8e, 0x45, 0xe7, 0x1a, 0xd3, 0xc1, 0x9b, 0x19, 0xe2, 0xc3, 0x49, 0x30, 0xe2, 0xd2,
	0xe4, 0x64, 0x33, 0x43, 0x3c, 0xcb, 0xf9, 0x69, 0xf4, 0x4a, 0x59, 0xd4, 0xa1, 0x66, 0xa6, 0xa3,
	0x58, 0x87, 0x4f, 0x10, 0x33, 0xa1, 0xab, 0x8c, 0x83, 0x51, 0xac, 0xc0, 0x5d, 0xc4, 0x30, 0x09,
	0x0b, 0xc1, 0x95, 0xb1, 0x1c, 0x8a, 0x43, 0x44, 0x58, 0x10, 0x2b, 0x63, 0x38, 0x14, 0x87, 0x18,
	0xc8, 0x2c, 0x08, 0xb8, 0x10, 0x2a, 0x55, 0x34, 0xf5, 0x27, 0x83, 0x46, 0x30, 0x5b, 0xbc, 0x0f,
	0xb7, 0x04, 0x0f, 0x72, 0x2e, 0xfd, 0x39, 0x2d, 0x47, 0x69, 0x75, 0xb5, 0x60, 0xbb, 0xd4, 0x5d,
	0x87, 0xde, 0x69, 0x9a, 0x07, 0xdc, 0x47, 0x63, 0xf8, 0x42, 0xce, 0x62, 0x6e, 0x02, 0xb3, 0xa3,
	0xf0, 0x63, 0x26, 0xcf, 0x4f, 0x10, 0x25, 0x0f, 0xa0, 0x23, 0x04, 0xf7, 0x47, 0x63, 0xb5, 0x1f,
	0x26, 0x37, 0x1d, 0xab, 0xae, 0x10, 0xfc, 0x70, 0x8c, 0x9b, 0x1d, 0x84, 0xde, 0xd7, 0x16, 0x54,
	0x3f, 0xdb, 0x3d, 0xb9, 0xc9, 0x9c, 0xc6, 0x6c, 0x95, 0x25, 0x66, 0xab, 0x5e, 0x6f, 0x36, 0xfb,
	0x0a, 0xb3, 0x3d, 0x84, 0x4e, 0x96, 0xf3, 0x90, 0x9f, 0x46, 0x09, 0x0f, 0x7d, 0xb4, 0x97, 0x36,
	0x6e, 0xfb, 0x02, 0xdd, 0x0e, 0x62, 0xac, 0xe2, 0x01, 0x02, 0x89, 0x8c, 0x58, 0x2c, 0x14, 0xdb,
	0x8c, 0xa9, 0xbb, 0x73, 0x38, 0xf2, 0xc9, 0xfb, 0x8b, 0x05, 0xbd, 0xcb, 0x8c, 0xfb, 0xfe, 0xdf,
	0xf5, 0x1e, 0xb4, 0x58, 0x10, 0xa4, 0x93, 0x44, 0xfa, 0xaa, 0x93, 0xd6, 0xaf, 0x72, 0x0d, 0x76,
	0x84, 0x0d, 0xf5, 0x3d, 0x00, 0x71, 0xce, 0x72, 0xae, 0x0b, 0x87, 0x7e, 0x8d, 0xa3, 0x11, 0x2c,
	0x51, 0xbf, 0xb3, 0xa0, 0xbe, 0xa3, 0x6f, 0xf2, 0x76, 0x24, 0xaf, 0x2e, 0x21, 0xb9, 0xbd, 0xe4,
	0x55, 0xb5, 0xeb, 0x5f, 0x55, 0x7f, 0xf3, 0x55, 0xd8, 0x73, 0xb4, 0xe6, 0x73, 0x06, 0x79, 0x54,
	0x9e, 0x62, 0x99, 0x72, 0x6f, 0x62, 0x5e, 0xdf, 0xbc, 0x3c, 0xf5, 0x01, 0xb4, 0xb3, 0x3c, 0x9d,
	0x46, 0x21, 0xcf, 0xb5, 0x3d, 0xb4, 0xa9, 0x5b, 0x05, 0xa8, 0x0c, 0xf2, 0x11, 0xd4, 0x98, 0x94,
	0x79, 0xd1, 0xc9, 0xde, 0xbf, 0x2a, 0x4b, 0x6d, 0x6c, 0xa3, 0xc6, 0x5e, 0x22, 0xf3, 0x19, 0xd5,
	0xda, 0xab, 0x4f, 0x00, 0x2e, 0x40, 0x8c, 0xba, 0xa2, 0x39, 0x73, 0x28, 0x0e, 0xb1, 0xad, 0x9b,
	0xb2, 0x78, 0x52, 0x9c, 0xa9, 0x27, 0x3f, 0xa9, 0x3c, 0xb1, 0xbc, 0x35, 0xb0, 0x31, 0x9b, 0x69,
	0x1b, 0x8e, 0x53, 0x59, 0x7c, 0xf0, 0x98, 0x19, 0x52, 0xa9, 0x53, 0x74, 0x09, 0x22, 0x4b, 0x13,
	0x81, 0xd1, 0x54, 0xd3, 0xed, 0x8d, 0xb5, 0x98, 0xb7, 0x55, 0x3b, 0x43, 0xb5, 0xec, 0xbf, 0x6c,
	0x16, 0xde, 0xe6, 0x7f, 0x81, 0x4b, 0x9f, 0x93, 0xb5, 0xb7, 0xfa, 0x9c, 0xf4, 0xbe, 0xb5, 0xe0,
	0xde, 0xde, 0x2b, 0xc9, 0xf3, 0x84, 0xc5, 0x26, 0x22, 0x28, 0x47, 0xc7, 0xf2, 0xa2, 0xfb, 0xb9,
	0xa2, 0x43, 0xb0, 0xfe, 0xa3, 0x0e, 0xe1, 0x3e, 0xb8, 0xe9, 0xf0, 0x37, 0x3c, 0x90, 0xf3, 0xee,
	0x05, 0x0d, 0x29, 0xe7, 0xbe, 0x87, 0xed, 0xa1, 0x3a, 0x53, 0x6b, 0x68, 0xb6, 0xba, 0x06, 0x53,
	0x2a, 0x0f, 0xa1, 0x13, 0xa4, 0x89, 0xe4, 0x89, 0xf4, 0x63, 0x9e, 0x9c, 0xc9, 0x73, 0xd3, 0x2e,
	0xb5, 0x0d, 0xfa, 0x5c, 0x81, 0xde, 0x00, 0xd6, 0x96, 0x3d, 0x46, 0x3b, 0xc9, 0xfb, 0x83, 0x05,
	0xab, 0x97, 0x54, 0x4e, 0xd8, 0xf4, 0x7b, 0x7c, 0xec, 0x9b, 0x2f, 0xa9, 0x5e, 0xf5, 0x92, 0x7b,
	0x70, 0xf7, 0xca, 0x6b, 0xea, 0x67, 0xbc, 0xff, 0x53, 0xe8, 0x5e, 0xea, 0x94, 0x88, 0x0b, 0x8d,
	0x5f, 0x1c, 0x1d, 0x1e, 0xfd, 0xec, 0x57, 0x47, 0xbd, 0x15, 0xd2, 0x80, 0xea, 0xf3, 0x17, 0x8f,
	0x7b, 0x16, 0x01, 0xa8, 0x9f, 0x1c, 0x6d, 0x1f, 0x1f, 0xff, 0xba, 0x57, 0x21, 0x4d, 0xb0, 0x5f,
	0x9c, 0x7c, 0xf9, 0xac, 0x57, 0xdd, 0xdc, 0x83, 0xba, 0x26, 0x2f, 0x79, 0x0a, 0xe6, 0x4f, 0x36,
	0xf2, 0x7f, 0x65, 0x7c, 0xce, 0x37, 0xbf, 0xab, 0x77, 0x2e, 0xc3, 0xc6, 0x90, 0x2b, 0x3f, 0xb2,
	0x36, 0xff, 0x6c, 0x41, 0xf7, 0xd2, 0x2d, 0xc9, 0x0b, 0xfc, 0x2a, 0x51, 0x36, 0x27, 0x0f, 0xcb,
	0x08, 0xb8, 0x8e, 0x60, 0xab, 0x8f, 0x6e, 0x52, 0x2b, 0x4e, 0x24, 0x3f, 0x07, 0x5b, 0xb0, 0x29,
	0x27, 0xde, 0x92, 0x15, 0x73, 0x9e, 0x5c, 0x7d, 0x70, 0xad, 0x4e, 0xb1, 0xe5, 0xce, 0xa3, 0x7f,
	0xfc, 0xa9, 0x69, 0x7d, 0xfd, 0x7a, 0xcd, 0xfa, 0xee, 0xf5, 0x9a, 0xf5, 0xcf, 0xd7, 0x6b, 0xd6,
	0xef, 0xff, 0xb5, 0xb6, 0x02, 0xbd, 0x34, 0x3f, 0xdb, 0x90, 0xd1, 0x68, 0xba, 0x31, 0x9a, 0xaa,
	0x7f, 0x0a, 0x87, 0x75, 0xf5, 0xb3, 0xf5, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x83, 0x25, 0x9c,
	0x8f, 0x9f, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BackupClient is the client API for Backup service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackupClient interface {
	Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (Backup_BackupClient, error)
}

type backupClient struct {
	cc *grpc.ClientConn
}

func NewBackupClient(cc *grpc.ClientConn) BackupClient {
	return &backupClient{cc}
}

func (c *backupClient) Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (Backup_BackupClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Backup_serviceDesc.Streams[0], "/backup.Backup/backup", opts...)
	if err != nil {
		return nil, err
	}
	x := &backupBackupClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Backup_BackupClient interface {
	Recv() (*BackupResponse, error)
	grpc.ClientStream
}

type backupBackupClient struct {
	grpc.ClientStream
}

func (x *backupBackupClient) Recv() (*BackupResponse, error) {
	m := new(BackupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BackupServer is the server API for Backup service.
type BackupServer interface {
	Backup(*BackupRequest, Backup_BackupServer) error
}

// UnimplementedBackupServer can be embedded to have forward compatible implementations.
type UnimplementedBackupServer struct {
}

func (*UnimplementedBackupServer) Backup(req *BackupRequest, srv Backup_BackupServer) error {
	return status.Errorf(codes.Unimplemented, "method Backup not implemented")
}

func RegisterBackupServer(s *grpc.Server, srv BackupServer) {
	s.RegisterService(&_Backup_serviceDesc, srv)
}

func _Backup_Backup_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BackupRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackupServer).Backup(m, &backupBackupServer{stream})
}

type Backup_BackupServer interface {
	Send(*BackupResponse) error
	grpc.ServerStream
}

type backupBackupServer struct {
	grpc.ServerStream
}

func (x *backupBackupServer) Send(m *BackupResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Backup_serviceDesc = grpc.ServiceDesc{
	ServiceName: "backup.Backup",
	HandlerType: (*BackupServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "backup",
			Handler:       _Backup_Backup_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "brpb.proto",
}

// ExternalStorageClient is the client API for ExternalStorage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExternalStorageClient interface {
	// Restore to a file
	Restore(ctx context.Context, in *ExternalStorageRestoreRequest, opts ...grpc.CallOption) (*ExternalStorageRestoreResponse, error)
	// Save a file to storage
	Save(ctx context.Context, in *ExternalStorageSaveRequest, opts ...grpc.CallOption) (*ExternalStorageSaveResponse, error)
}

type externalStorageClient struct {
	cc *grpc.ClientConn
}

func NewExternalStorageClient(cc *grpc.ClientConn) ExternalStorageClient {
	return &externalStorageClient{cc}
}

func (c *externalStorageClient) Restore(ctx context.Context, in *ExternalStorageRestoreRequest, opts ...grpc.CallOption) (*ExternalStorageRestoreResponse, error) {
	out := new(ExternalStorageRestoreResponse)
	err := c.cc.Invoke(ctx, "/backup.ExternalStorage/restore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalStorageClient) Save(ctx context.Context, in *ExternalStorageSaveRequest, opts ...grpc.CallOption) (*ExternalStorageSaveResponse, error) {
	out := new(ExternalStorageSaveResponse)
	err := c.cc.Invoke(ctx, "/backup.ExternalStorage/save", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExternalStorageServer is the server API for ExternalStorage service.
type ExternalStorageServer interface {
	// Restore to a file
	Restore(context.Context, *ExternalStorageRestoreRequest) (*ExternalStorageRestoreResponse, error)
	// Save a file to storage
	Save(context.Context, *ExternalStorageSaveRequest) (*ExternalStorageSaveResponse, error)
}

// UnimplementedExternalStorageServer can be embedded to have forward compatible implementations.
type UnimplementedExternalStorageServer struct {
}

func (*UnimplementedExternalStorageServer) Restore(ctx context.Context, req *ExternalStorageRestoreRequest) (*ExternalStorageRestoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restore not implemented")
}
func (*UnimplementedExternalStorageServer) Save(ctx context.Context, req *ExternalStorageSaveRequest) (*ExternalStorageSaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}

func RegisterExternalStorageServer(s *grpc.Server, srv ExternalStorageServer) {
	s.RegisterService(&_ExternalStorage_serviceDesc, srv)
}

func _ExternalStorage_Restore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExternalStorageRestoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalStorageServer).Restore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backup.ExternalStorage/Restore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalStorageServer).Restore(ctx, req.(*ExternalStorageRestoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalStorage_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExternalStorageSaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalStorageServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backup.ExternalStorage/Save",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalStorageServer).Save(ctx, req.(*ExternalStorageSaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExternalStorage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "backup.ExternalStorage",
	HandlerType: (*ExternalStorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "restore",
			Handler:    _ExternalStorage_Restore_Handler,
		},
		{
			MethodName: "save",
			Handler:    _ExternalStorage_Save_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brpb.proto",
}

func (m *BackupMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewCollationsEnabled) > 0 {
		i -= len(m.NewCollationsEnabled)
		copy(dAtA[i:], m.NewCollationsEnabled)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.NewCollationsEnabled)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Policies) > 0 {
		for iNdEx := len(m.Policies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Policies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.ApiVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ApiVersion))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.BackupResult) > 0 {
		i -= len(m.BackupResult)
		copy(dAtA[i:], m.BackupResult)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.BackupResult)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.DdlIndexes != nil {
		{
			size, err := m.DdlIndexes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.RawRangeIndex != nil {
		{
			size, err := m.RawRangeIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.SchemaIndex != nil {
		{
			size, err := m.SchemaIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.FileIndex != nil {
		{
			size, err := m.FileIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Version != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x60
	}
	if len(m.BrVersion) > 0 {
		i -= len(m.BrVersion)
		copy(dAtA[i:], m.BrVersion)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.BrVersion)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Ddls) > 0 {
		i -= len(m.Ddls)
		copy(dAtA[i:], m.Ddls)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Ddls)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.RawRanges) > 0 {
		for iNdEx := len(m.RawRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.IsRawKv {
		i--
		if m.IsRawKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.EndVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.EndVersion))
		i--
		dAtA[i] = 0x30
	}
	if m.StartVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.StartVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ClusterVersion) > 0 {
		i -= len(m.ClusterVersion)
		copy(dAtA[i:], m.ClusterVersion)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ClusterVersion)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClusterId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ClusterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CipherIv) > 0 {
		i -= len(m.CipherIv)
		copy(dAtA[i:], m.CipherIv)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.CipherIv)))
		i--
		dAtA[i] = 0x62
	}
	if m.Size_ != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Cf) > 0 {
		i -= len(m.Cf)
		copy(dAtA[i:], m.Cf)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Cf)))
		i--
		dAtA[i] = 0x52
	}
	if m.TotalBytes != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TotalBytes))
		i--
		dAtA[i] = 0x48
	}
	if m.TotalKvs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TotalKvs))
		i--
		dAtA[i] = 0x40
	}
	if m.Crc64Xor != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Crc64Xor))
		i--
		dAtA[i] = 0x38
	}
	if m.EndVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.EndVersion))
		i--
		dAtA[i] = 0x30
	}
	if m.StartVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.StartVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sha256) > 0 {
		i -= len(m.Sha256)
		copy(dAtA[i:], m.Sha256)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Sha256)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetaFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ddls) > 0 {
		for iNdEx := len(m.Ddls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ddls[iNdEx])
			copy(dAtA[i:], m.Ddls[iNdEx])
			i = encodeVarintBrpb(dAtA, i, uint64(len(m.Ddls[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RawRanges) > 0 {
		for iNdEx := len(m.RawRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DataFiles) > 0 {
		for iNdEx := len(m.DataFiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataFiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MetaFiles) > 0 {
		for iNdEx := len(m.MetaFiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MetaFiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlacementPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Stats) > 0 {
		i -= len(m.Stats)
		copy(dAtA[i:], m.Stats)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Stats)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TiflashReplicas != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TiflashReplicas))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalBytes != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TotalBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalKvs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TotalKvs))
		i--
		dAtA[i] = 0x20
	}
	if m.Crc64Xor != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Crc64Xor))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Db) > 0 {
		i -= len(m.Db)
		copy(dAtA[i:], m.Db)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Db)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cf) > 0 {
		i -= len(m.Cf)
		copy(dAtA[i:], m.Cf)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Cf)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterIDError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterIDError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterIDError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Request))
		i--
		dAtA[i] = 0x10
	}
	if m.Current != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Current))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Detail != nil {
		{
			size := m.Detail.Size()
			i -= size
			if _, err := m.Detail.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Error_ClusterIdError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_ClusterIdError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClusterIdError != nil {
		{
			size, err := m.ClusterIdError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Error_KvError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_KvError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KvError != nil {
		{
			size, err := m.KvError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Error_RegionError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_RegionError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegionError != nil {
		{
			size, err := m.RegionError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CipherInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CipherInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CipherInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CipherKey) > 0 {
		i -= len(m.CipherKey)
		copy(dAtA[i:], m.CipherKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.CipherKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.CipherType != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CipherType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DstApiVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.DstApiVersion))
		i--
		dAtA[i] = 0x78
	}
	if m.CipherInfo != nil {
		{
			size, err := m.CipherInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.CompressionLevel != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompressionLevel))
		i--
		dAtA[i] = 0x68
	}
	if m.CompressionType != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompressionType))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Cf) > 0 {
		i -= len(m.Cf)
		copy(dAtA[i:], m.Cf)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Cf)))
		i--
		dAtA[i] = 0x5a
	}
	if m.IsRawKv {
		i--
		if m.IsRawKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.StorageBackend != nil {
		{
			size, err := m.StorageBackend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Concurrency != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Concurrency))
		i--
		dAtA[i] = 0x40
	}
	if m.RateLimit != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.RateLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.EndVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.EndVersion))
		i--
		dAtA[i] = 0x28
	}
	if m.StartVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.StartVersion))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClusterId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ClusterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StorageBackend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageBackend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Backend != nil {
		{
			size := m.Backend.Size()
			i -= size
			if _, err := m.Backend.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StorageBackend_Noop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_Noop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Noop != nil {
		{
			size, err := m.Noop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_Local) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_Local) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Local != nil {
		{
			size, err := m.Local.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_S3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_S3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.S3 != nil {
		{
			size, err := m.S3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_Gcs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_Gcs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gcs != nil {
		{
			size, err := m.Gcs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_CloudDynamic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_CloudDynamic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloudDynamic != nil {
		{
			size, err := m.CloudDynamic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_Hdfs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_Hdfs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Hdfs != nil {
		{
			size, err := m.Hdfs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_AzureBlobStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_AzureBlobStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureBlobStorage != nil {
		{
			size, err := m.AzureBlobStorage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Noop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Noop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Noop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Local) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Local) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Local) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SseKmsKeyId) > 0 {
		i -= len(m.SseKmsKeyId)
		copy(dAtA[i:], m.SseKmsKeyId)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.SseKmsKeyId)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ForcePathStyle {
		i--
		if m.ForcePathStyle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.SecretAccessKey) > 0 {
		i -= len(m.SecretAccessKey)
		copy(dAtA[i:], m.SecretAccessKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.SecretAccessKey)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Acl) > 0 {
		i -= len(m.Acl)
		copy(dAtA[i:], m.Acl)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Acl)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Sse) > 0 {
		i -= len(m.Sse)
		copy(dAtA[i:], m.Sse)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Sse)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StorageClass) > 0 {
		i -= len(m.StorageClass)
		copy(dAtA[i:], m.StorageClass)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StorageClass)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CredentialsBlob) > 0 {
		i -= len(m.CredentialsBlob)
		copy(dAtA[i:], m.CredentialsBlob)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.CredentialsBlob)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PredefinedAcl) > 0 {
		i -= len(m.PredefinedAcl)
		copy(dAtA[i:], m.PredefinedAcl)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.PredefinedAcl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StorageClass) > 0 {
		i -= len(m.StorageClass)
		copy(dAtA[i:], m.StorageClass)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StorageClass)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureBlobStorage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureBlobStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureBlobStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SharedKey) > 0 {
		i -= len(m.SharedKey)
		copy(dAtA[i:], m.SharedKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.SharedKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AccountName) > 0 {
		i -= len(m.AccountName)
		copy(dAtA[i:], m.AccountName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.AccountName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StorageClass) > 0 {
		i -= len(m.StorageClass)
		copy(dAtA[i:], m.StorageClass)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StorageClass)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StorageClass) > 0 {
		i -= len(m.StorageClass)
		copy(dAtA[i:], m.StorageClass)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StorageClass)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudDynamic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudDynamic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudDynamic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Attrs) > 0 {
		for k := range m.Attrs {
			v := m.Attrs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBrpb(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBrpb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBrpb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ProviderName) > 0 {
		i -= len(m.ProviderName)
		copy(dAtA[i:], m.ProviderName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ProviderName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Bucket != nil {
		{
			size, err := m.Bucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HDFS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDFS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HDFS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Remote) > 0 {
		i -= len(m.Remote)
		copy(dAtA[i:], m.Remote)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Remote)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BackupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ApiVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ApiVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorageRestoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorageRestoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorageRestoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ContentLength != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ContentLength))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RestoreName) > 0 {
		i -= len(m.RestoreName)
		copy(dAtA[i:], m.RestoreName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.RestoreName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageBackend != nil {
		{
			size, err := m.StorageBackend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorageRestoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorageRestoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorageRestoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorageSaveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorageSaveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorageSaveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ContentLength != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ContentLength))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageBackend != nil {
		{
			size, err := m.StorageBackend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorageSaveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorageSaveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorageSaveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintBrpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovBrpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BackupMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovBrpb(uint64(m.ClusterId))
	}
	l = len(m.ClusterVersion)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.StartVersion != 0 {
		n += 1 + sovBrpb(uint64(m.StartVersion))
	}
	if m.EndVersion != 0 {
		n += 1 + sovBrpb(uint64(m.EndVersion))
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.IsRawKv {
		n += 2
	}
	if len(m.RawRanges) > 0 {
		for _, e := range m.RawRanges {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	l = len(m.Ddls)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.BrVersion)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovBrpb(uint64(m.Version))
	}
	if m.FileIndex != nil {
		l = m.FileIndex.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.SchemaIndex != nil {
		l = m.SchemaIndex.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.RawRangeIndex != nil {
		l = m.RawRangeIndex.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.DdlIndexes != nil {
		l = m.DdlIndexes.Size()
		n += 2 + l + sovBrpb(uint64(l))
	}
	l = len(m.BackupResult)
	if l > 0 {
		n += 2 + l + sovBrpb(uint64(l))
	}
	if m.ApiVersion != 0 {
		n += 2 + sovBrpb(uint64(m.ApiVersion))
	}
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 2 + l + sovBrpb(uint64(l))
		}
	}
	l = len(m.NewCollationsEnabled)
	if l > 0 {
		n += 2 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Sha256)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovBrpb(uint64(m.StartVersion))
	}
	if m.EndVersion != 0 {
		n += 1 + sovBrpb(uint64(m.EndVersion))
	}
	if m.Crc64Xor != 0 {
		n += 1 + sovBrpb(uint64(m.Crc64Xor))
	}
	if m.TotalKvs != 0 {
		n += 1 + sovBrpb(uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovBrpb(uint64(m.TotalBytes))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovBrpb(uint64(m.Size_))
	}
	l = len(m.CipherIv)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetaFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MetaFiles) > 0 {
		for _, e := range m.MetaFiles {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.DataFiles) > 0 {
		for _, e := range m.DataFiles {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.RawRanges) > 0 {
		for _, e := range m.RawRanges {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.Ddls) > 0 {
		for _, b := range m.Ddls {
			l = len(b)
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Db)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Crc64Xor != 0 {
		n += 1 + sovBrpb(uint64(m.Crc64Xor))
	}
	if m.TotalKvs != 0 {
		n += 1 + sovBrpb(uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovBrpb(uint64(m.TotalBytes))
	}
	if m.TiflashReplicas != 0 {
		n += 1 + sovBrpb(uint64(m.TiflashReplicas))
	}
	l = len(m.Stats)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterIDError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Current != 0 {
		n += 1 + sovBrpb(uint64(m.Current))
	}
	if m.Request != 0 {
		n += 1 + sovBrpb(uint64(m.Request))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Detail != nil {
		n += m.Detail.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error_ClusterIdError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterIdError != nil {
		l = m.ClusterIdError.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *Error_KvError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KvError != nil {
		l = m.KvError.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *Error_RegionError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *CipherInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CipherType != 0 {
		n += 1 + sovBrpb(uint64(m.CipherType))
	}
	l = len(m.CipherKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovBrpb(uint64(m.ClusterId))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovBrpb(uint64(m.StartVersion))
	}
	if m.EndVersion != 0 {
		n += 1 + sovBrpb(uint64(m.EndVersion))
	}
	if m.RateLimit != 0 {
		n += 1 + sovBrpb(uint64(m.RateLimit))
	}
	if m.Concurrency != 0 {
		n += 1 + sovBrpb(uint64(m.Concurrency))
	}
	if m.StorageBackend != nil {
		l = m.StorageBackend.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.IsRawKv {
		n += 2
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.CompressionType != 0 {
		n += 1 + sovBrpb(uint64(m.CompressionType))
	}
	if m.CompressionLevel != 0 {
		n += 1 + sovBrpb(uint64(m.CompressionLevel))
	}
	if m.CipherInfo != nil {
		l = m.CipherInfo.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.DstApiVersion != 0 {
		n += 1 + sovBrpb(uint64(m.DstApiVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageBackend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Backend != nil {
		n += m.Backend.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageBackend_Noop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Noop != nil {
		l = m.Noop.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_Local) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_S3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.S3 != nil {
		l = m.S3.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_Gcs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gcs != nil {
		l = m.Gcs.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_CloudDynamic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudDynamic != nil {
		l = m.CloudDynamic.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_Hdfs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hdfs != nil {
		l = m.Hdfs.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_AzureBlobStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureBlobStorage != nil {
		l = m.AzureBlobStorage.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *Noop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Local) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StorageClass)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Sse)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Acl)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.SecretAccessKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.ForcePathStyle {
		n += 2
	}
	l = len(m.SseKmsKeyId)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GCS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StorageClass)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.PredefinedAcl)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.CredentialsBlob)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AzureBlobStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StorageClass)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.AccountName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.SharedKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Bucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StorageClass)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloudDynamic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != nil {
		l = m.Bucket.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.ProviderName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Attrs) > 0 {
		for k, v := range m.Attrs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBrpb(uint64(len(k))) + 1 + len(v) + sovBrpb(uint64(len(v)))
			n += mapEntrySize + 1 + sovBrpb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HDFS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Remote)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.ApiVersion != 0 {
		n += 1 + sovBrpb(uint64(m.ApiVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalStorageRestoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageBackend != nil {
		l = m.StorageBackend.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.RestoreName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.ContentLength != 0 {
		n += 1 + sovBrpb(uint64(m.ContentLength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalStorageRestoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalStorageSaveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageBackend != nil {
		l = m.StorageBackend.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.ContentLength != 0 {
		n += 1 + sovBrpb(uint64(m.ContentLength))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalStorageSaveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBrpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBrpb(x uint64) (n int) {
	return sovBrpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackupMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndVersion", wireType)
			}
			m.EndVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &Schema{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRawKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRawKv = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawRanges = append(m.RawRanges, &RawRange{})
			if err := m.RawRanges[len(m.RawRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddls", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ddls = append(m.Ddls[:0], dAtA[iNdEx:postIndex]...)
			if m.Ddls == nil {
				m.Ddls = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileIndex == nil {
				m.FileIndex = &MetaFile{}
			}
			if err := m.FileIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaIndex == nil {
				m.SchemaIndex = &MetaFile{}
			}
			if err := m.SchemaIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawRangeIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RawRangeIndex == nil {
				m.RawRangeIndex = &MetaFile{}
			}
			if err := m.RawRangeIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DdlIndexes == nil {
				m.DdlIndexes = &MetaFile{}
			}
			if err := m.DdlIndexes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupResult", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupResult = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			m.ApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiVersion |= kvrpcpb.APIVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &PlacementPolicy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewCollationsEnabled", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewCollationsEnabled = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256 = append(m.Sha256[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha256 == nil {
				m.Sha256 = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndVersion", wireType)
			}
			m.EndVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc64Xor", wireType)
			}
			m.Crc64Xor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc64Xor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalKvs", wireType)
			}
			m.TotalKvs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalKvs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherIv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherIv = append(m.CipherIv[:0], dAtA[iNdEx:postIndex]...)
			if m.CipherIv == nil {
				m.CipherIv = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaFiles = append(m.MetaFiles, &File{})
			if err := m.MetaFiles[len(m.MetaFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFiles = append(m.DataFiles, &File{})
			if err := m.DataFiles[len(m.DataFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &Schema{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawRanges = append(m.RawRanges, &RawRange{})
			if err := m.RawRanges[len(m.RawRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddls", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ddls = append(m.Ddls, make([]byte, postIndex-iNdEx))
			copy(m.Ddls[len(m.Ddls)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlacementPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlacementPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info[:0], dAtA[iNdEx:postIndex]...)
			if m.Info == nil {
				m.Info = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Db = append(m.Db[:0], dAtA[iNdEx:postIndex]...)
			if m.Db == nil {
				m.Db = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = append(m.Table[:0], dAtA[iNdEx:postIndex]...)
			if m.Table == nil {
				m.Table = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc64Xor", wireType)
			}
			m.Crc64Xor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc64Xor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalKvs", wireType)
			}
			m.TotalKvs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalKvs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TiflashReplicas", wireType)
			}
			m.TiflashReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TiflashReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats[:0], dAtA[iNdEx:postIndex]...)
			if m.Stats == nil {
				m.Stats = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterIDError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterIDError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterIDError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Current |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			m.Request = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Request |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIdError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClusterIDError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &Error_ClusterIdError{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &kvrpcpb.KeyError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &Error_KvError{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &errorpb.Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &Error_RegionError{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CipherInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CipherInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CipherInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherType", wireType)
			}
			m.CipherType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CipherType |= encryptionpb.EncryptionMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherKey = append(m.CipherKey[:0], dAtA[iNdEx:postIndex]...)
			if m.CipherKey == nil {
				m.CipherKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndVersion", wireType)
			}
			m.EndVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimit", wireType)
			}
			m.RateLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			m.Concurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Concurrency |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageBackend == nil {
				m.StorageBackend = &StorageBackend{}
			}
			if err := m.StorageBackend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRawKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRawKv = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionType", wireType)
			}
			m.CompressionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionType |= CompressionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionLevel", wireType)
			}
			m.CompressionLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CipherInfo == nil {
				m.CipherInfo = &CipherInfo{}
			}
			if err := m.CipherInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstApiVersion", wireType)
			}
			m.DstApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstApiVersion |= kvrpcpb.APIVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageBackend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageBackend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageBackend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Noop{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_Noop{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Local{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_Local{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &S3{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_S3{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCS{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_Gcs{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudDynamic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudDynamic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_CloudDynamic{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HDFS{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_Hdfs{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureBlobStorage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureBlobStorage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_AzureBlobStorage{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Noop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Noop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Noop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Local) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Local: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Local: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sse", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sse = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretAccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretAccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePathStyle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForcePathStyle = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SseKmsKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SseKmsKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredefinedAcl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredefinedAcl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialsBlob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialsBlob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureBlobStorage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureBlobStorage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureBlobStorage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharedKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudDynamic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudDynamic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudDynamic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bucket == nil {
				m.Bucket = &Bucket{}
			}
			if err := m.Bucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBrpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBrpb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBrpb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBrpb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBrpb
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBrpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBrpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attrs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HDFS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDFS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDFS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			m.ApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiVersion |= kvrpcpb.APIVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorageRestoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalStorageRestoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalStorageRestoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageBackend == nil {
				m.StorageBackend = &StorageBackend{}
			}
			if err := m.StorageBackend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RestoreName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentLength", wireType)
			}
			m.ContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorageRestoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalStorageRestoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalStorageRestoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorageSaveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalStorageSaveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalStorageSaveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageBackend == nil {
				m.StorageBackend = &StorageBackend{}
			}
			if err := m.StorageBackend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentLength", wireType)
			}
			m.ContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorageSaveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalStorageSaveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalStorageSaveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBrpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBrpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBrpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBrpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBrpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBrpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBrpb = fmt.Errorf("proto: unexpected end of group")
)
