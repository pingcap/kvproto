// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: brpb.proto

package backup

import (
	"context"
	"fmt"
	"io"
	"math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	encryptionpb "github.com/pingcap/kvproto/pkg/encryptionpb"
	errorpb "github.com/pingcap/kvproto/pkg/errorpb"
	kvrpcpb "github.com/pingcap/kvproto/pkg/kvrpcpb"
	metapb "github.com/pingcap/kvproto/pkg/metapb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PrepareSnapshotBackupRequestType int32

const (
	// Update the lease of suspending some commands (Which may impact the
	// disk snapshot backup) to be proposed.
	// As long as the lease is kept, those commands may not be proposed.
	// If the client has gone, the lease will be destroyed after its TTL.
	PrepareSnapshotBackupRequestType_UpdateLease PrepareSnapshotBackupRequestType = 0
	// Wait a region apply to the last index.
	PrepareSnapshotBackupRequestType_WaitApply PrepareSnapshotBackupRequestType = 1
	// Hint before closing the stream. Server will go back to normal after this.
	// This should also return a final "UpdateLeaseResult" to the client, which
	// indices whether the last lease is valid.
	PrepareSnapshotBackupRequestType_Finish PrepareSnapshotBackupRequestType = 2
)

var PrepareSnapshotBackupRequestType_name = map[int32]string{
	0: "UpdateLease",
	1: "WaitApply",
	2: "Finish",
}

var PrepareSnapshotBackupRequestType_value = map[string]int32{
	"UpdateLease": 0,
	"WaitApply":   1,
	"Finish":      2,
}

func (x PrepareSnapshotBackupRequestType) String() string {
	return proto.EnumName(PrepareSnapshotBackupRequestType_name, int32(x))
}

func (PrepareSnapshotBackupRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{0}
}

type PrepareSnapshotBackupEventType int32

const (
	// A region has finished wait apply.
	PrepareSnapshotBackupEventType_WaitApplyDone PrepareSnapshotBackupEventType = 0
	// A lease has been updated.
	PrepareSnapshotBackupEventType_UpdateLeaseResult PrepareSnapshotBackupEventType = 1
)

var PrepareSnapshotBackupEventType_name = map[int32]string{
	0: "WaitApplyDone",
	1: "UpdateLeaseResult",
}

var PrepareSnapshotBackupEventType_value = map[string]int32{
	"WaitApplyDone":     0,
	"UpdateLeaseResult": 1,
}

func (x PrepareSnapshotBackupEventType) String() string {
	return proto.EnumName(PrepareSnapshotBackupEventType_name, int32(x))
}

func (PrepareSnapshotBackupEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{1}
}

// sst files or log files compression algorithm
// for log files, unknown means not use compression algorithm
type CompressionType int32

const (
	CompressionType_UNKNOWN CompressionType = 0
	CompressionType_LZ4     CompressionType = 1
	CompressionType_SNAPPY  CompressionType = 2
	CompressionType_ZSTD    CompressionType = 3
)

var CompressionType_name = map[int32]string{
	0: "UNKNOWN",
	1: "LZ4",
	2: "SNAPPY",
	3: "ZSTD",
}

var CompressionType_value = map[string]int32{
	"UNKNOWN": 0,
	"LZ4":     1,
	"SNAPPY":  2,
	"ZSTD":    3,
}

func (x CompressionType) String() string {
	return proto.EnumName(CompressionType_name, int32(x))
}

func (CompressionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{2}
}

// BackupMpde represents the mode of this whole backup request to the cluster.
// and we need to store it in `backupmeta`.
type BackupMode int32

const (
	// scan and generate precise SST file of a backup range.
	// then we don't need to do anything in future restore.
	// Note: this mode will cost the CPU resource of TiKV.
	BackupMode_SCAN BackupMode = 0
	// check and upload the coarse overlap SST files of a backup range.
	// then we need to use a merge iterator to filter unexpected kv in future restore.
	// Note: this mode will save the CPU resource of TiKV.
	BackupMode_FILE BackupMode = 1
)

var BackupMode_name = map[int32]string{
	0: "SCAN",
	1: "FILE",
}

var BackupMode_value = map[string]int32{
	"SCAN": 0,
	"FILE": 1,
}

func (x BackupMode) String() string {
	return proto.EnumName(BackupMode_name, int32(x))
}

func (BackupMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{3}
}

type MetaVersion int32

const (
	MetaVersion_V1 MetaVersion = 0
	MetaVersion_V2 MetaVersion = 1
)

var MetaVersion_name = map[int32]string{
	0: "V1",
	1: "V2",
}

var MetaVersion_value = map[string]int32{
	"V1": 0,
	"V2": 1,
}

func (x MetaVersion) String() string {
	return proto.EnumName(MetaVersion_name, int32(x))
}

func (MetaVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{4}
}

type FileType int32

const (
	FileType_Delete FileType = 0
	FileType_Put    FileType = 1
)

var FileType_name = map[int32]string{
	0: "Delete",
	1: "Put",
}

var FileType_value = map[string]int32{
	"Delete": 0,
	"Put":    1,
}

func (x FileType) String() string {
	return proto.EnumName(FileType_name, int32(x))
}

func (FileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{5}
}

type MigrationVersion int32

const (
	// The initial version. Somehow "UNKNOWN".
	MigrationVersion_M0 MigrationVersion = 0
	// Added `creator` and `version`.
	MigrationVersion_M1 MigrationVersion = 1
)

var MigrationVersion_name = map[int32]string{
	0: "M0",
	1: "M1",
}

var MigrationVersion_value = map[string]int32{
	"M0": 0,
	"M1": 1,
}

func (x MigrationVersion) String() string {
	return proto.EnumName(MigrationVersion_name, int32(x))
}

func (MigrationVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{6}
}

type PrepareSnapshotBackupRequest struct {
	// The type of the request.
	Ty PrepareSnapshotBackupRequestType `protobuf:"varint,1,opt,name=ty,proto3,enum=backup.PrepareSnapshotBackupRequestType" json:"ty,omitempty"`
	// The regions related to the request.
	// If the request is "UpdateLease" or "Finish", it should be empty.
	Regions []*metapb.Region `protobuf:"bytes,2,rep,name=regions,proto3" json:"regions,omitempty"`
	// The lease duration for "UpdateLease" request.
	LeaseInSeconds uint64 `protobuf:"varint,3,opt,name=lease_in_seconds,json=leaseInSeconds,proto3" json:"lease_in_seconds,omitempty"`
}

func (m *PrepareSnapshotBackupRequest) Reset()         { *m = PrepareSnapshotBackupRequest{} }
func (m *PrepareSnapshotBackupRequest) String() string { return proto.CompactTextString(m) }
func (*PrepareSnapshotBackupRequest) ProtoMessage()    {}
func (*PrepareSnapshotBackupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{0}
}
func (m *PrepareSnapshotBackupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareSnapshotBackupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareSnapshotBackupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareSnapshotBackupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareSnapshotBackupRequest.Merge(m, src)
}
func (m *PrepareSnapshotBackupRequest) XXX_Size() int {
	return m.Size()
}
func (m *PrepareSnapshotBackupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareSnapshotBackupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareSnapshotBackupRequest proto.InternalMessageInfo

func (m *PrepareSnapshotBackupRequest) GetTy() PrepareSnapshotBackupRequestType {
	if m != nil {
		return m.Ty
	}
	return PrepareSnapshotBackupRequestType_UpdateLease
}

func (m *PrepareSnapshotBackupRequest) GetRegions() []*metapb.Region {
	if m != nil {
		return m.Regions
	}
	return nil
}

func (m *PrepareSnapshotBackupRequest) GetLeaseInSeconds() uint64 {
	if m != nil {
		return m.LeaseInSeconds
	}
	return 0
}

type PrepareSnapshotBackupResponse struct {
	// The type of the event.
	Ty PrepareSnapshotBackupEventType `protobuf:"varint,1,opt,name=ty,proto3,enum=backup.PrepareSnapshotBackupEventType" json:"ty,omitempty"`
	// The region bind to the type.
	// For "WaitApplyDone".
	Region *metapb.Region `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	// The error of the execution.
	Error *errorpb.Error `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	// Whether the last lease is valid.
	// For "UpdateLease" and "Finish".
	LastLeaseIsValid bool `protobuf:"varint,4,opt,name=last_lease_is_valid,json=lastLeaseIsValid,proto3" json:"last_lease_is_valid,omitempty"`
}

func (m *PrepareSnapshotBackupResponse) Reset()         { *m = PrepareSnapshotBackupResponse{} }
func (m *PrepareSnapshotBackupResponse) String() string { return proto.CompactTextString(m) }
func (*PrepareSnapshotBackupResponse) ProtoMessage()    {}
func (*PrepareSnapshotBackupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{1}
}
func (m *PrepareSnapshotBackupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareSnapshotBackupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareSnapshotBackupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareSnapshotBackupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareSnapshotBackupResponse.Merge(m, src)
}
func (m *PrepareSnapshotBackupResponse) XXX_Size() int {
	return m.Size()
}
func (m *PrepareSnapshotBackupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareSnapshotBackupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareSnapshotBackupResponse proto.InternalMessageInfo

func (m *PrepareSnapshotBackupResponse) GetTy() PrepareSnapshotBackupEventType {
	if m != nil {
		return m.Ty
	}
	return PrepareSnapshotBackupEventType_WaitApplyDone
}

func (m *PrepareSnapshotBackupResponse) GetRegion() *metapb.Region {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *PrepareSnapshotBackupResponse) GetError() *errorpb.Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *PrepareSnapshotBackupResponse) GetLastLeaseIsValid() bool {
	if m != nil {
		return m.LastLeaseIsValid
	}
	return false
}

// The message save the metadata of a backup.
type BackupMeta struct {
	// ID and version of backuped cluster.
	ClusterId      uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	ClusterVersion string `protobuf:"bytes,2,opt,name=cluster_version,json=clusterVersion,proto3" json:"cluster_version,omitempty"`
	// Save the version of BR running backup jobs.
	BrVersion string `protobuf:"bytes,11,opt,name=br_version,json=brVersion,proto3" json:"br_version,omitempty"`
	// The backupmeta scheme version.
	Version int32 `protobuf:"varint,12,opt,name=version,proto3" json:"version,omitempty"`
	// A set of files that compose a backup.
	// Note: `files` is deprecated, as it bloats backupmeta. It is kept for
	//       compatibility, so new BR can restore older backups.
	Files []*File `protobuf:"bytes,4,rep,name=files,proto3" json:"files,omitempty"`
	// An index to files contains data files.
	FileIndex *MetaFile `protobuf:"bytes,13,opt,name=file_index,json=fileIndex,proto3" json:"file_index,omitempty"`
	// A pair of timestamp specifies a time range of a backup.
	// For full backup, the start_version equals to the end_version,
	// it means point in time.
	// For incremental backup, the time range is specified as
	// (start_version, end_version].
	StartVersion uint64 `protobuf:"varint,5,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	EndVersion   uint64 `protobuf:"varint,6,opt,name=end_version,json=endVersion,proto3" json:"end_version,omitempty"`
	// Table metadata describes database and table info.
	// Note: `schemas` is deprecated, as it bloats backupmeta. It is kept for
	//       compatibility, so new BR can restore older backups.
	Schemas []*Schema `protobuf:"bytes,7,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// An index to files contains Schemas.
	SchemaIndex *MetaFile `protobuf:"bytes,14,opt,name=schema_index,json=schemaIndex,proto3" json:"schema_index,omitempty"`
	// If in raw kv mode, `start_versions`, `end_versions` and `schemas` will be
	// ignored, and the backup data's range is represented by raw_ranges.
	IsRawKv bool `protobuf:"varint,8,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	// Note: `raw_ranges` is deprecated, as it bloats backupmeta. It is kept for
	//       compatibility, so new BR can restore older backups.
	RawRanges []*RawRange `protobuf:"bytes,9,rep,name=raw_ranges,json=rawRanges,proto3" json:"raw_ranges,omitempty"`
	// An index to files contains RawRanges.
	RawRangeIndex *MetaFile `protobuf:"bytes,15,opt,name=raw_range_index,json=rawRangeIndex,proto3" json:"raw_range_index,omitempty"`
	// In incremental backup, DDLs which are completed in
	// (lastBackupTS, backupTS] will be stored here.
	// Note: `raw_ranges` is deprecated, as it bloats backupmeta. It is kept for
	//       compatibility, so new BR can restore older backups.
	Ddls []byte `protobuf:"bytes,10,opt,name=ddls,proto3" json:"ddls,omitempty"`
	// An index to files contains DDLs.
	DdlIndexes *MetaFile `protobuf:"bytes,16,opt,name=ddl_indexes,json=ddlIndexes,proto3" json:"ddl_indexes,omitempty"`
	// the backup result into `backupmeta` file
	BackupResult string `protobuf:"bytes,17,opt,name=backup_result,json=backupResult,proto3" json:"backup_result,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion kvrpcpb.APIVersion `protobuf:"varint,18,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// the placement policy info in backup cluster. we assume the policy won't be too much for one cluster.
	Policies []*PlacementPolicy `protobuf:"bytes,19,rep,name=policies,proto3" json:"policies,omitempty"`
	// new_collations_enabled specifies the config `new_collations_enabled_on_first_bootstrap` in tidb.
	NewCollationsEnabled string `protobuf:"bytes,20,opt,name=new_collations_enabled,json=newCollationsEnabled,proto3" json:"new_collations_enabled,omitempty"`
	// If in txn kv mode, `schemas` will be ignored, the backup data's range is as same as normal backup.
	IsTxnKv bool `protobuf:"varint,21,opt,name=is_txn_kv,json=isTxnKv,proto3" json:"is_txn_kv,omitempty"`
	// maintain the id mapping from upstream cluster to downstream cluster.
	DbMaps []*PitrDBMap `protobuf:"bytes,22,rep,name=db_maps,json=dbMaps,proto3" json:"db_maps,omitempty"`
	Mode   BackupMode   `protobuf:"varint,23,opt,name=mode,proto3,enum=backup.BackupMode" json:"mode,omitempty"`
	// record the backup range and the correspond SST files when using file-copy backup.
	Ranges []*BackupRange `protobuf:"bytes,24,rep,name=ranges,proto3" json:"ranges,omitempty"`
	// record the size of the backup data files and meta files
	BackupSize uint64 `protobuf:"varint,25,opt,name=backup_size,json=backupSize,proto3" json:"backup_size,omitempty"`
}

func (m *BackupMeta) Reset()         { *m = BackupMeta{} }
func (m *BackupMeta) String() string { return proto.CompactTextString(m) }
func (*BackupMeta) ProtoMessage()    {}
func (*BackupMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{2}
}
func (m *BackupMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupMeta.Merge(m, src)
}
func (m *BackupMeta) XXX_Size() int {
	return m.Size()
}
func (m *BackupMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupMeta.DiscardUnknown(m)
}

var xxx_messageInfo_BackupMeta proto.InternalMessageInfo

func (m *BackupMeta) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *BackupMeta) GetClusterVersion() string {
	if m != nil {
		return m.ClusterVersion
	}
	return ""
}

func (m *BackupMeta) GetBrVersion() string {
	if m != nil {
		return m.BrVersion
	}
	return ""
}

func (m *BackupMeta) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *BackupMeta) GetFiles() []*File {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *BackupMeta) GetFileIndex() *MetaFile {
	if m != nil {
		return m.FileIndex
	}
	return nil
}

func (m *BackupMeta) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *BackupMeta) GetEndVersion() uint64 {
	if m != nil {
		return m.EndVersion
	}
	return 0
}

func (m *BackupMeta) GetSchemas() []*Schema {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *BackupMeta) GetSchemaIndex() *MetaFile {
	if m != nil {
		return m.SchemaIndex
	}
	return nil
}

func (m *BackupMeta) GetIsRawKv() bool {
	if m != nil {
		return m.IsRawKv
	}
	return false
}

func (m *BackupMeta) GetRawRanges() []*RawRange {
	if m != nil {
		return m.RawRanges
	}
	return nil
}

func (m *BackupMeta) GetRawRangeIndex() *MetaFile {
	if m != nil {
		return m.RawRangeIndex
	}
	return nil
}

func (m *BackupMeta) GetDdls() []byte {
	if m != nil {
		return m.Ddls
	}
	return nil
}

func (m *BackupMeta) GetDdlIndexes() *MetaFile {
	if m != nil {
		return m.DdlIndexes
	}
	return nil
}

func (m *BackupMeta) GetBackupResult() string {
	if m != nil {
		return m.BackupResult
	}
	return ""
}

func (m *BackupMeta) GetApiVersion() kvrpcpb.APIVersion {
	if m != nil {
		return m.ApiVersion
	}
	return kvrpcpb.APIVersion_V1
}

func (m *BackupMeta) GetPolicies() []*PlacementPolicy {
	if m != nil {
		return m.Policies
	}
	return nil
}

func (m *BackupMeta) GetNewCollationsEnabled() string {
	if m != nil {
		return m.NewCollationsEnabled
	}
	return ""
}

func (m *BackupMeta) GetIsTxnKv() bool {
	if m != nil {
		return m.IsTxnKv
	}
	return false
}

func (m *BackupMeta) GetDbMaps() []*PitrDBMap {
	if m != nil {
		return m.DbMaps
	}
	return nil
}

func (m *BackupMeta) GetMode() BackupMode {
	if m != nil {
		return m.Mode
	}
	return BackupMode_SCAN
}

func (m *BackupMeta) GetRanges() []*BackupRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *BackupMeta) GetBackupSize() uint64 {
	if m != nil {
		return m.BackupSize
	}
	return 0
}

type BackupRange struct {
	StartKey []byte  `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte  `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Files    []*File `protobuf:"bytes,3,rep,name=files,proto3" json:"files,omitempty"`
}

func (m *BackupRange) Reset()         { *m = BackupRange{} }
func (m *BackupRange) String() string { return proto.CompactTextString(m) }
func (*BackupRange) ProtoMessage()    {}
func (*BackupRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{3}
}
func (m *BackupRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupRange.Merge(m, src)
}
func (m *BackupRange) XXX_Size() int {
	return m.Size()
}
func (m *BackupRange) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupRange.DiscardUnknown(m)
}

var xxx_messageInfo_BackupRange proto.InternalMessageInfo

func (m *BackupRange) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *BackupRange) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *BackupRange) GetFiles() []*File {
	if m != nil {
		return m.Files
	}
	return nil
}

type File struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sha256       []byte `protobuf:"bytes,2,opt,name=sha256,proto3" json:"sha256,omitempty"`
	StartKey     []byte `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey       []byte `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	StartVersion uint64 `protobuf:"varint,5,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	EndVersion   uint64 `protobuf:"varint,6,opt,name=end_version,json=endVersion,proto3" json:"end_version,omitempty"`
	Crc64Xor     uint64 `protobuf:"varint,7,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	TotalKvs     uint64 `protobuf:"varint,8,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes   uint64 `protobuf:"varint,9,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	Cf           string `protobuf:"bytes,10,opt,name=cf,proto3" json:"cf,omitempty"`
	Size_        uint64 `protobuf:"varint,11,opt,name=size,proto3" json:"size,omitempty"`
	// cipher_iv is used for AES cipher
	CipherIv []byte `protobuf:"bytes,12,opt,name=cipher_iv,json=cipherIv,proto3" json:"cipher_iv,omitempty"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{4}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_File.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *File) GetSha256() []byte {
	if m != nil {
		return m.Sha256
	}
	return nil
}

func (m *File) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *File) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *File) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *File) GetEndVersion() uint64 {
	if m != nil {
		return m.EndVersion
	}
	return 0
}

func (m *File) GetCrc64Xor() uint64 {
	if m != nil {
		return m.Crc64Xor
	}
	return 0
}

func (m *File) GetTotalKvs() uint64 {
	if m != nil {
		return m.TotalKvs
	}
	return 0
}

func (m *File) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *File) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *File) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *File) GetCipherIv() []byte {
	if m != nil {
		return m.CipherIv
	}
	return nil
}

// MetaFile describes a multi-level index of data used in backup.
type MetaFile struct {
	// A set of files that contains a MetaFile.
	// It is used as a multi-level index.
	MetaFiles []*File `protobuf:"bytes,1,rep,name=meta_files,json=metaFiles,proto3" json:"meta_files,omitempty"`
	// A set of files that contains user data.
	DataFiles []*File `protobuf:"bytes,2,rep,name=data_files,json=dataFiles,proto3" json:"data_files,omitempty"`
	// A set of files that contains Schemas.
	Schemas []*Schema `protobuf:"bytes,3,rep,name=schemas,proto3" json:"schemas,omitempty"`
	// A set of files that contains RawRanges.
	RawRanges []*RawRange `protobuf:"bytes,4,rep,name=raw_ranges,json=rawRanges,proto3" json:"raw_ranges,omitempty"`
	// A set of files that contains BackupRanges.
	BackupRanges []*BackupRange `protobuf:"bytes,6,rep,name=backup_ranges,json=backupRanges,proto3" json:"backup_ranges,omitempty"`
	// A set of files that contains DDLs.
	Ddls [][]byte `protobuf:"bytes,5,rep,name=ddls,proto3" json:"ddls,omitempty"`
}

func (m *MetaFile) Reset()         { *m = MetaFile{} }
func (m *MetaFile) String() string { return proto.CompactTextString(m) }
func (*MetaFile) ProtoMessage()    {}
func (*MetaFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{5}
}
func (m *MetaFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaFile.Merge(m, src)
}
func (m *MetaFile) XXX_Size() int {
	return m.Size()
}
func (m *MetaFile) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaFile.DiscardUnknown(m)
}

var xxx_messageInfo_MetaFile proto.InternalMessageInfo

func (m *MetaFile) GetMetaFiles() []*File {
	if m != nil {
		return m.MetaFiles
	}
	return nil
}

func (m *MetaFile) GetDataFiles() []*File {
	if m != nil {
		return m.DataFiles
	}
	return nil
}

func (m *MetaFile) GetSchemas() []*Schema {
	if m != nil {
		return m.Schemas
	}
	return nil
}

func (m *MetaFile) GetRawRanges() []*RawRange {
	if m != nil {
		return m.RawRanges
	}
	return nil
}

func (m *MetaFile) GetBackupRanges() []*BackupRange {
	if m != nil {
		return m.BackupRanges
	}
	return nil
}

func (m *MetaFile) GetDdls() [][]byte {
	if m != nil {
		return m.Ddls
	}
	return nil
}

type PlacementPolicy struct {
	Info []byte `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *PlacementPolicy) Reset()         { *m = PlacementPolicy{} }
func (m *PlacementPolicy) String() string { return proto.CompactTextString(m) }
func (*PlacementPolicy) ProtoMessage()    {}
func (*PlacementPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{6}
}
func (m *PlacementPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementPolicy.Merge(m, src)
}
func (m *PlacementPolicy) XXX_Size() int {
	return m.Size()
}
func (m *PlacementPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementPolicy proto.InternalMessageInfo

func (m *PlacementPolicy) GetInfo() []byte {
	if m != nil {
		return m.Info
	}
	return nil
}

type StatsBlock struct {
	// The physical id which the stats json data belongs to.
	PhysicalId int64 `protobuf:"varint,1,opt,name=physical_id,json=physicalId,proto3" json:"physical_id,omitempty"`
	// The marshal data of the part of json_table. Currently it is the partition table.
	JsonTable []byte `protobuf:"bytes,2,opt,name=json_table,json=jsonTable,proto3" json:"json_table,omitempty"`
}

func (m *StatsBlock) Reset()         { *m = StatsBlock{} }
func (m *StatsBlock) String() string { return proto.CompactTextString(m) }
func (*StatsBlock) ProtoMessage()    {}
func (*StatsBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{7}
}
func (m *StatsBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatsBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatsBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatsBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatsBlock.Merge(m, src)
}
func (m *StatsBlock) XXX_Size() int {
	return m.Size()
}
func (m *StatsBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_StatsBlock.DiscardUnknown(m)
}

var xxx_messageInfo_StatsBlock proto.InternalMessageInfo

func (m *StatsBlock) GetPhysicalId() int64 {
	if m != nil {
		return m.PhysicalId
	}
	return 0
}

func (m *StatsBlock) GetJsonTable() []byte {
	if m != nil {
		return m.JsonTable
	}
	return nil
}

type StatsFile struct {
	// A set of files that contains json_tables.
	Blocks []*StatsBlock `protobuf:"bytes,1,rep,name=blocks,proto3" json:"blocks,omitempty"`
}

func (m *StatsFile) Reset()         { *m = StatsFile{} }
func (m *StatsFile) String() string { return proto.CompactTextString(m) }
func (*StatsFile) ProtoMessage()    {}
func (*StatsFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{8}
}
func (m *StatsFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatsFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatsFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatsFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatsFile.Merge(m, src)
}
func (m *StatsFile) XXX_Size() int {
	return m.Size()
}
func (m *StatsFile) XXX_DiscardUnknown() {
	xxx_messageInfo_StatsFile.DiscardUnknown(m)
}

var xxx_messageInfo_StatsFile proto.InternalMessageInfo

func (m *StatsFile) GetBlocks() []*StatsBlock {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type StatsFileIndex struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Sha256 []byte `protobuf:"bytes,2,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// the size of the file content encrypted
	SizeEnc uint64 `protobuf:"varint,3,opt,name=size_enc,json=sizeEnc,proto3" json:"size_enc,omitempty"`
	// the size of the original file content
	SizeOri uint64 `protobuf:"varint,4,opt,name=size_ori,json=sizeOri,proto3" json:"size_ori,omitempty"`
	// cipher_iv is used for AES cipher
	CipherIv []byte `protobuf:"bytes,5,opt,name=cipher_iv,json=cipherIv,proto3" json:"cipher_iv,omitempty"`
	// If the size of the stats is very small, save the data into the metafile
	InlineData []byte `protobuf:"bytes,6,opt,name=inline_data,json=inlineData,proto3" json:"inline_data,omitempty"`
}

func (m *StatsFileIndex) Reset()         { *m = StatsFileIndex{} }
func (m *StatsFileIndex) String() string { return proto.CompactTextString(m) }
func (*StatsFileIndex) ProtoMessage()    {}
func (*StatsFileIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{9}
}
func (m *StatsFileIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatsFileIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatsFileIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatsFileIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatsFileIndex.Merge(m, src)
}
func (m *StatsFileIndex) XXX_Size() int {
	return m.Size()
}
func (m *StatsFileIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_StatsFileIndex.DiscardUnknown(m)
}

var xxx_messageInfo_StatsFileIndex proto.InternalMessageInfo

func (m *StatsFileIndex) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StatsFileIndex) GetSha256() []byte {
	if m != nil {
		return m.Sha256
	}
	return nil
}

func (m *StatsFileIndex) GetSizeEnc() uint64 {
	if m != nil {
		return m.SizeEnc
	}
	return 0
}

func (m *StatsFileIndex) GetSizeOri() uint64 {
	if m != nil {
		return m.SizeOri
	}
	return 0
}

func (m *StatsFileIndex) GetCipherIv() []byte {
	if m != nil {
		return m.CipherIv
	}
	return nil
}

func (m *StatsFileIndex) GetInlineData() []byte {
	if m != nil {
		return m.InlineData
	}
	return nil
}

type Schema struct {
	Db              []byte `protobuf:"bytes,1,opt,name=db,proto3" json:"db,omitempty"`
	Table           []byte `protobuf:"bytes,2,opt,name=table,proto3" json:"table,omitempty"`
	Crc64Xor        uint64 `protobuf:"varint,3,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	TotalKvs        uint64 `protobuf:"varint,4,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes      uint64 `protobuf:"varint,5,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	TiflashReplicas uint32 `protobuf:"varint,6,opt,name=tiflash_replicas,json=tiflashReplicas,proto3" json:"tiflash_replicas,omitempty"`
	// stats represents the dump stats for a analyzed table, which generate by DumpStatsToJSON
	// https://github.com/pingcap/tidb/blob/e136429d8dc5d70f43cd3f94179b0b9f47595097/statistics/handle/dump.go#L116
	Stats []byte `protobuf:"bytes,7,opt,name=stats,proto3" json:"stats,omitempty"`
	// An index of files that contains stats data
	StatsIndex []*StatsFileIndex `protobuf:"bytes,8,rep,name=stats_index,json=statsIndex,proto3" json:"stats_index,omitempty"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{10}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

func (m *Schema) GetDb() []byte {
	if m != nil {
		return m.Db
	}
	return nil
}

func (m *Schema) GetTable() []byte {
	if m != nil {
		return m.Table
	}
	return nil
}

func (m *Schema) GetCrc64Xor() uint64 {
	if m != nil {
		return m.Crc64Xor
	}
	return 0
}

func (m *Schema) GetTotalKvs() uint64 {
	if m != nil {
		return m.TotalKvs
	}
	return 0
}

func (m *Schema) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *Schema) GetTiflashReplicas() uint32 {
	if m != nil {
		return m.TiflashReplicas
	}
	return 0
}

func (m *Schema) GetStats() []byte {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *Schema) GetStatsIndex() []*StatsFileIndex {
	if m != nil {
		return m.StatsIndex
	}
	return nil
}

type IDMap struct {
	UpstreamId   int64 `protobuf:"varint,1,opt,name=upstream_id,json=upstreamId,proto3" json:"upstream_id,omitempty"`
	DownstreamId int64 `protobuf:"varint,2,opt,name=downstream_id,json=downstreamId,proto3" json:"downstream_id,omitempty"`
}

func (m *IDMap) Reset()         { *m = IDMap{} }
func (m *IDMap) String() string { return proto.CompactTextString(m) }
func (*IDMap) ProtoMessage()    {}
func (*IDMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{11}
}
func (m *IDMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IDMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IDMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDMap.Merge(m, src)
}
func (m *IDMap) XXX_Size() int {
	return m.Size()
}
func (m *IDMap) XXX_DiscardUnknown() {
	xxx_messageInfo_IDMap.DiscardUnknown(m)
}

var xxx_messageInfo_IDMap proto.InternalMessageInfo

func (m *IDMap) GetUpstreamId() int64 {
	if m != nil {
		return m.UpstreamId
	}
	return 0
}

func (m *IDMap) GetDownstreamId() int64 {
	if m != nil {
		return m.DownstreamId
	}
	return 0
}

type PitrTableMap struct {
	Name       string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IdMap      *IDMap   `protobuf:"bytes,2,opt,name=id_map,json=idMap,proto3" json:"id_map,omitempty"`
	Partitions []*IDMap `protobuf:"bytes,3,rep,name=partitions,proto3" json:"partitions,omitempty"`
}

func (m *PitrTableMap) Reset()         { *m = PitrTableMap{} }
func (m *PitrTableMap) String() string { return proto.CompactTextString(m) }
func (*PitrTableMap) ProtoMessage()    {}
func (*PitrTableMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{12}
}
func (m *PitrTableMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PitrTableMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PitrTableMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PitrTableMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PitrTableMap.Merge(m, src)
}
func (m *PitrTableMap) XXX_Size() int {
	return m.Size()
}
func (m *PitrTableMap) XXX_DiscardUnknown() {
	xxx_messageInfo_PitrTableMap.DiscardUnknown(m)
}

var xxx_messageInfo_PitrTableMap proto.InternalMessageInfo

func (m *PitrTableMap) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PitrTableMap) GetIdMap() *IDMap {
	if m != nil {
		return m.IdMap
	}
	return nil
}

func (m *PitrTableMap) GetPartitions() []*IDMap {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type PitrDBMap struct {
	Name   string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IdMap  *IDMap          `protobuf:"bytes,2,opt,name=id_map,json=idMap,proto3" json:"id_map,omitempty"`
	Tables []*PitrTableMap `protobuf:"bytes,3,rep,name=tables,proto3" json:"tables,omitempty"`
}

func (m *PitrDBMap) Reset()         { *m = PitrDBMap{} }
func (m *PitrDBMap) String() string { return proto.CompactTextString(m) }
func (*PitrDBMap) ProtoMessage()    {}
func (*PitrDBMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{13}
}
func (m *PitrDBMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PitrDBMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PitrDBMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PitrDBMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PitrDBMap.Merge(m, src)
}
func (m *PitrDBMap) XXX_Size() int {
	return m.Size()
}
func (m *PitrDBMap) XXX_DiscardUnknown() {
	xxx_messageInfo_PitrDBMap.DiscardUnknown(m)
}

var xxx_messageInfo_PitrDBMap proto.InternalMessageInfo

func (m *PitrDBMap) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PitrDBMap) GetIdMap() *IDMap {
	if m != nil {
		return m.IdMap
	}
	return nil
}

func (m *PitrDBMap) GetTables() []*PitrTableMap {
	if m != nil {
		return m.Tables
	}
	return nil
}

type RawRange struct {
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Cf       string `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
}

func (m *RawRange) Reset()         { *m = RawRange{} }
func (m *RawRange) String() string { return proto.CompactTextString(m) }
func (*RawRange) ProtoMessage()    {}
func (*RawRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{14}
}
func (m *RawRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawRange.Merge(m, src)
}
func (m *RawRange) XXX_Size() int {
	return m.Size()
}
func (m *RawRange) XXX_DiscardUnknown() {
	xxx_messageInfo_RawRange.DiscardUnknown(m)
}

var xxx_messageInfo_RawRange proto.InternalMessageInfo

func (m *RawRange) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *RawRange) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *RawRange) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

type ClusterIDError struct {
	Current uint64 `protobuf:"varint,1,opt,name=current,proto3" json:"current,omitempty"`
	Request uint64 `protobuf:"varint,2,opt,name=request,proto3" json:"request,omitempty"`
}

func (m *ClusterIDError) Reset()         { *m = ClusterIDError{} }
func (m *ClusterIDError) String() string { return proto.CompactTextString(m) }
func (*ClusterIDError) ProtoMessage()    {}
func (*ClusterIDError) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{15}
}
func (m *ClusterIDError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterIDError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterIDError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterIDError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterIDError.Merge(m, src)
}
func (m *ClusterIDError) XXX_Size() int {
	return m.Size()
}
func (m *ClusterIDError) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterIDError.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterIDError proto.InternalMessageInfo

func (m *ClusterIDError) GetCurrent() uint64 {
	if m != nil {
		return m.Current
	}
	return 0
}

func (m *ClusterIDError) GetRequest() uint64 {
	if m != nil {
		return m.Request
	}
	return 0
}

type Error struct {
	Msg string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	// Types that are valid to be assigned to Detail:
	//	*Error_ClusterIdError
	//	*Error_KvError
	//	*Error_RegionError
	Detail isError_Detail `protobuf_oneof:"detail"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{16}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

type isError_Detail interface {
	isError_Detail()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Error_ClusterIdError struct {
	ClusterIdError *ClusterIDError `protobuf:"bytes,3,opt,name=cluster_id_error,json=clusterIdError,proto3,oneof" json:"cluster_id_error,omitempty"`
}
type Error_KvError struct {
	KvError *kvrpcpb.KeyError `protobuf:"bytes,4,opt,name=kv_error,json=kvError,proto3,oneof" json:"kv_error,omitempty"`
}
type Error_RegionError struct {
	RegionError *errorpb.Error `protobuf:"bytes,5,opt,name=region_error,json=regionError,proto3,oneof" json:"region_error,omitempty"`
}

func (*Error_ClusterIdError) isError_Detail() {}
func (*Error_KvError) isError_Detail()        {}
func (*Error_RegionError) isError_Detail()    {}

func (m *Error) GetDetail() isError_Detail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func (m *Error) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Error) GetClusterIdError() *ClusterIDError {
	if x, ok := m.GetDetail().(*Error_ClusterIdError); ok {
		return x.ClusterIdError
	}
	return nil
}

func (m *Error) GetKvError() *kvrpcpb.KeyError {
	if x, ok := m.GetDetail().(*Error_KvError); ok {
		return x.KvError
	}
	return nil
}

func (m *Error) GetRegionError() *errorpb.Error {
	if x, ok := m.GetDetail().(*Error_RegionError); ok {
		return x.RegionError
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Error) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Error_ClusterIdError)(nil),
		(*Error_KvError)(nil),
		(*Error_RegionError)(nil),
	}
}

type StreamBackupTaskSecurityConfig struct {
	// Types that are valid to be assigned to Encryption:
	//	*StreamBackupTaskSecurityConfig_PlaintextDataKey
	//	*StreamBackupTaskSecurityConfig_MasterKeyConfig
	Encryption isStreamBackupTaskSecurityConfig_Encryption `protobuf_oneof:"encryption"`
}

func (m *StreamBackupTaskSecurityConfig) Reset()         { *m = StreamBackupTaskSecurityConfig{} }
func (m *StreamBackupTaskSecurityConfig) String() string { return proto.CompactTextString(m) }
func (*StreamBackupTaskSecurityConfig) ProtoMessage()    {}
func (*StreamBackupTaskSecurityConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{17}
}
func (m *StreamBackupTaskSecurityConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamBackupTaskSecurityConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamBackupTaskSecurityConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamBackupTaskSecurityConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamBackupTaskSecurityConfig.Merge(m, src)
}
func (m *StreamBackupTaskSecurityConfig) XXX_Size() int {
	return m.Size()
}
func (m *StreamBackupTaskSecurityConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamBackupTaskSecurityConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StreamBackupTaskSecurityConfig proto.InternalMessageInfo

type isStreamBackupTaskSecurityConfig_Encryption interface {
	isStreamBackupTaskSecurityConfig_Encryption()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StreamBackupTaskSecurityConfig_PlaintextDataKey struct {
	PlaintextDataKey *CipherInfo `protobuf:"bytes,1,opt,name=plaintext_data_key,json=plaintextDataKey,proto3,oneof" json:"plaintext_data_key,omitempty"`
}
type StreamBackupTaskSecurityConfig_MasterKeyConfig struct {
	MasterKeyConfig *MasterKeyConfig `protobuf:"bytes,2,opt,name=master_key_config,json=masterKeyConfig,proto3,oneof" json:"master_key_config,omitempty"`
}

func (*StreamBackupTaskSecurityConfig_PlaintextDataKey) isStreamBackupTaskSecurityConfig_Encryption() {
}
func (*StreamBackupTaskSecurityConfig_MasterKeyConfig) isStreamBackupTaskSecurityConfig_Encryption() {
}

func (m *StreamBackupTaskSecurityConfig) GetEncryption() isStreamBackupTaskSecurityConfig_Encryption {
	if m != nil {
		return m.Encryption
	}
	return nil
}

func (m *StreamBackupTaskSecurityConfig) GetPlaintextDataKey() *CipherInfo {
	if x, ok := m.GetEncryption().(*StreamBackupTaskSecurityConfig_PlaintextDataKey); ok {
		return x.PlaintextDataKey
	}
	return nil
}

func (m *StreamBackupTaskSecurityConfig) GetMasterKeyConfig() *MasterKeyConfig {
	if x, ok := m.GetEncryption().(*StreamBackupTaskSecurityConfig_MasterKeyConfig); ok {
		return x.MasterKeyConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StreamBackupTaskSecurityConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StreamBackupTaskSecurityConfig_PlaintextDataKey)(nil),
		(*StreamBackupTaskSecurityConfig_MasterKeyConfig)(nil),
	}
}

type CipherInfo struct {
	CipherType encryptionpb.EncryptionMethod `protobuf:"varint,1,opt,name=cipher_type,json=cipherType,proto3,enum=encryptionpb.EncryptionMethod" json:"cipher_type,omitempty"`
	CipherKey  []byte                        `protobuf:"bytes,2,opt,name=cipher_key,json=cipherKey,proto3" json:"cipher_key,omitempty"`
}

func (m *CipherInfo) Reset()         { *m = CipherInfo{} }
func (m *CipherInfo) String() string { return proto.CompactTextString(m) }
func (*CipherInfo) ProtoMessage()    {}
func (*CipherInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{18}
}
func (m *CipherInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CipherInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CipherInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CipherInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CipherInfo.Merge(m, src)
}
func (m *CipherInfo) XXX_Size() int {
	return m.Size()
}
func (m *CipherInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CipherInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CipherInfo proto.InternalMessageInfo

func (m *CipherInfo) GetCipherType() encryptionpb.EncryptionMethod {
	if m != nil {
		return m.CipherType
	}
	return encryptionpb.EncryptionMethod_UNKNOWN
}

func (m *CipherInfo) GetCipherKey() []byte {
	if m != nil {
		return m.CipherKey
	}
	return nil
}

type MasterKeyConfig struct {
	EncryptionType encryptionpb.EncryptionMethod `protobuf:"varint,1,opt,name=encryption_type,json=encryptionType,proto3,enum=encryptionpb.EncryptionMethod" json:"encryption_type,omitempty"`
	MasterKeys     []*encryptionpb.MasterKey     `protobuf:"bytes,2,rep,name=master_keys,json=masterKeys,proto3" json:"master_keys,omitempty"`
}

func (m *MasterKeyConfig) Reset()         { *m = MasterKeyConfig{} }
func (m *MasterKeyConfig) String() string { return proto.CompactTextString(m) }
func (*MasterKeyConfig) ProtoMessage()    {}
func (*MasterKeyConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{19}
}
func (m *MasterKeyConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MasterKeyConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MasterKeyConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MasterKeyConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MasterKeyConfig.Merge(m, src)
}
func (m *MasterKeyConfig) XXX_Size() int {
	return m.Size()
}
func (m *MasterKeyConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MasterKeyConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MasterKeyConfig proto.InternalMessageInfo

func (m *MasterKeyConfig) GetEncryptionType() encryptionpb.EncryptionMethod {
	if m != nil {
		return m.EncryptionType
	}
	return encryptionpb.EncryptionMethod_UNKNOWN
}

func (m *MasterKeyConfig) GetMasterKeys() []*encryptionpb.MasterKey {
	if m != nil {
		return m.MasterKeys
	}
	return nil
}

type BackupRequest struct {
	ClusterId    uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	StartKey     []byte `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey       []byte `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	StartVersion uint64 `protobuf:"varint,4,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	EndVersion   uint64 `protobuf:"varint,5,opt,name=end_version,json=endVersion,proto3" json:"end_version,omitempty"`
	// The I/O rate limit for backup request.
	RateLimit uint64 `protobuf:"varint,7,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	// The concurrency for executing the backup request in every tikv node.
	Concurrency    uint32          `protobuf:"varint,8,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	StorageBackend *StorageBackend `protobuf:"bytes,9,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	// If raw kv mode is enabled, `start_version` and `end_version` will be ignored, and `cf`
	// specifies which cf to backup.
	IsRawKv bool   `protobuf:"varint,10,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	Cf      string `protobuf:"bytes,11,opt,name=cf,proto3" json:"cf,omitempty"`
	// algorithm used for compress sst files
	CompressionType CompressionType `protobuf:"varint,12,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
	// sst compression level, some algorithms support negative compression levels
	CompressionLevel int32 `protobuf:"varint,13,opt,name=compression_level,json=compressionLevel,proto3" json:"compression_level,omitempty"`
	// The cipher_info is Used to encrypt sst
	CipherInfo *CipherInfo `protobuf:"bytes,14,opt,name=cipher_info,json=cipherInfo,proto3" json:"cipher_info,omitempty"`
	// dst_api_version indicates the key-value encoding version used by the
	// generated SST file. Accepted values:
	// 1. "v1": the generated SST files are encoded with api-v1, can be restored
	//    to TiKV clusters whose api version is set to v1.
	// 2. "v2": the generated SST files are encoded with api-v2, can be restored
	//    to TiKV clusters whose api version is set to v2.
	DstApiVersion kvrpcpb.APIVersion `protobuf:"varint,15,opt,name=dst_api_version,json=dstApiVersion,proto3,enum=kvrpcpb.APIVersion" json:"dst_api_version,omitempty"`
	// with checkpoint, some subintervals of the range have been backed up and recorded.
	// only the remaining sub ranges of the range need to be backed up this time.
	SubRanges []*kvrpcpb.KeyRange `protobuf:"bytes,16,rep,name=sub_ranges,json=subRanges,proto3" json:"sub_ranges,omitempty"`
	// replica_read indicates whether to use replica read for backup.
	// If it is false, the backup will only read data from leader.
	// If it is true, the backup will read data from both leader and follower.
	ReplicaRead bool       `protobuf:"varint,17,opt,name=replica_read,json=replicaRead,proto3" json:"replica_read,omitempty"`
	Mode        BackupMode `protobuf:"varint,18,opt,name=mode,proto3,enum=backup.BackupMode" json:"mode,omitempty"`
	// unique_id represents the handle of this backup. after we implement file-copy backup.
	// we need generate some internal states during the whole backup precedure.
	// this unique id is help to find the state effictively.
	UniqueId string           `protobuf:"bytes,19,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	Context  *kvrpcpb.Context `protobuf:"bytes,20,opt,name=context,proto3" json:"context,omitempty"`
}

func (m *BackupRequest) Reset()         { *m = BackupRequest{} }
func (m *BackupRequest) String() string { return proto.CompactTextString(m) }
func (*BackupRequest) ProtoMessage()    {}
func (*BackupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{20}
}
func (m *BackupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupRequest.Merge(m, src)
}
func (m *BackupRequest) XXX_Size() int {
	return m.Size()
}
func (m *BackupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BackupRequest proto.InternalMessageInfo

func (m *BackupRequest) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *BackupRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *BackupRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *BackupRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *BackupRequest) GetEndVersion() uint64 {
	if m != nil {
		return m.EndVersion
	}
	return 0
}

func (m *BackupRequest) GetRateLimit() uint64 {
	if m != nil {
		return m.RateLimit
	}
	return 0
}

func (m *BackupRequest) GetConcurrency() uint32 {
	if m != nil {
		return m.Concurrency
	}
	return 0
}

func (m *BackupRequest) GetStorageBackend() *StorageBackend {
	if m != nil {
		return m.StorageBackend
	}
	return nil
}

func (m *BackupRequest) GetIsRawKv() bool {
	if m != nil {
		return m.IsRawKv
	}
	return false
}

func (m *BackupRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *BackupRequest) GetCompressionType() CompressionType {
	if m != nil {
		return m.CompressionType
	}
	return CompressionType_UNKNOWN
}

func (m *BackupRequest) GetCompressionLevel() int32 {
	if m != nil {
		return m.CompressionLevel
	}
	return 0
}

func (m *BackupRequest) GetCipherInfo() *CipherInfo {
	if m != nil {
		return m.CipherInfo
	}
	return nil
}

func (m *BackupRequest) GetDstApiVersion() kvrpcpb.APIVersion {
	if m != nil {
		return m.DstApiVersion
	}
	return kvrpcpb.APIVersion_V1
}

func (m *BackupRequest) GetSubRanges() []*kvrpcpb.KeyRange {
	if m != nil {
		return m.SubRanges
	}
	return nil
}

func (m *BackupRequest) GetReplicaRead() bool {
	if m != nil {
		return m.ReplicaRead
	}
	return false
}

func (m *BackupRequest) GetMode() BackupMode {
	if m != nil {
		return m.Mode
	}
	return BackupMode_SCAN
}

func (m *BackupRequest) GetUniqueId() string {
	if m != nil {
		return m.UniqueId
	}
	return ""
}

func (m *BackupRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

type StreamBackupTaskInfo struct {
	// The storage for backup, parsed by BR.
	Storage *StorageBackend `protobuf:"bytes,1,opt,name=storage,proto3" json:"storage,omitempty"`
	// The time range for backing up.
	StartTs uint64 `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	EndTs   uint64 `protobuf:"varint,3,opt,name=end_ts,json=endTs,proto3" json:"end_ts,omitempty"`
	// Misc meta data.
	// The name of the task, also the ID of the task.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// The table filter of the task.
	// Only for displaying the task info.
	TableFilter []string `protobuf:"bytes,5,rep,name=table_filter,json=tableFilter,proto3" json:"table_filter,omitempty"`
	// compression type
	CompressionType CompressionType `protobuf:"varint,6,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
	// security config for backup files
	SecurityConfig *StreamBackupTaskSecurityConfig `protobuf:"bytes,7,opt,name=security_config,json=securityConfig,proto3" json:"security_config,omitempty"`
}

func (m *StreamBackupTaskInfo) Reset()         { *m = StreamBackupTaskInfo{} }
func (m *StreamBackupTaskInfo) String() string { return proto.CompactTextString(m) }
func (*StreamBackupTaskInfo) ProtoMessage()    {}
func (*StreamBackupTaskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{21}
}
func (m *StreamBackupTaskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamBackupTaskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamBackupTaskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamBackupTaskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamBackupTaskInfo.Merge(m, src)
}
func (m *StreamBackupTaskInfo) XXX_Size() int {
	return m.Size()
}
func (m *StreamBackupTaskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamBackupTaskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StreamBackupTaskInfo proto.InternalMessageInfo

func (m *StreamBackupTaskInfo) GetStorage() *StorageBackend {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *StreamBackupTaskInfo) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *StreamBackupTaskInfo) GetEndTs() uint64 {
	if m != nil {
		return m.EndTs
	}
	return 0
}

func (m *StreamBackupTaskInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StreamBackupTaskInfo) GetTableFilter() []string {
	if m != nil {
		return m.TableFilter
	}
	return nil
}

func (m *StreamBackupTaskInfo) GetCompressionType() CompressionType {
	if m != nil {
		return m.CompressionType
	}
	return CompressionType_UNKNOWN
}

func (m *StreamBackupTaskInfo) GetSecurityConfig() *StreamBackupTaskSecurityConfig {
	if m != nil {
		return m.SecurityConfig
	}
	return nil
}

type StorageBackend struct {
	// Types that are valid to be assigned to Backend:
	//	*StorageBackend_Noop
	//	*StorageBackend_Local
	//	*StorageBackend_S3
	//	*StorageBackend_Gcs
	//	*StorageBackend_CloudDynamic
	//	*StorageBackend_Hdfs
	//	*StorageBackend_AzureBlobStorage
	Backend isStorageBackend_Backend `protobuf_oneof:"backend"`
}

func (m *StorageBackend) Reset()         { *m = StorageBackend{} }
func (m *StorageBackend) String() string { return proto.CompactTextString(m) }
func (*StorageBackend) ProtoMessage()    {}
func (*StorageBackend) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{22}
}
func (m *StorageBackend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageBackend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageBackend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageBackend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageBackend.Merge(m, src)
}
func (m *StorageBackend) XXX_Size() int {
	return m.Size()
}
func (m *StorageBackend) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageBackend.DiscardUnknown(m)
}

var xxx_messageInfo_StorageBackend proto.InternalMessageInfo

type isStorageBackend_Backend interface {
	isStorageBackend_Backend()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StorageBackend_Noop struct {
	Noop *Noop `protobuf:"bytes,1,opt,name=noop,proto3,oneof" json:"noop,omitempty"`
}
type StorageBackend_Local struct {
	Local *Local `protobuf:"bytes,2,opt,name=local,proto3,oneof" json:"local,omitempty"`
}
type StorageBackend_S3 struct {
	S3 *S3 `protobuf:"bytes,3,opt,name=s3,proto3,oneof" json:"s3,omitempty"`
}
type StorageBackend_Gcs struct {
	Gcs *GCS `protobuf:"bytes,4,opt,name=gcs,proto3,oneof" json:"gcs,omitempty"`
}
type StorageBackend_CloudDynamic struct {
	CloudDynamic *CloudDynamic `protobuf:"bytes,5,opt,name=cloud_dynamic,json=cloudDynamic,proto3,oneof" json:"cloud_dynamic,omitempty"`
}
type StorageBackend_Hdfs struct {
	Hdfs *HDFS `protobuf:"bytes,6,opt,name=hdfs,proto3,oneof" json:"hdfs,omitempty"`
}
type StorageBackend_AzureBlobStorage struct {
	AzureBlobStorage *AzureBlobStorage `protobuf:"bytes,7,opt,name=azure_blob_storage,json=azureBlobStorage,proto3,oneof" json:"azure_blob_storage,omitempty"`
}

func (*StorageBackend_Noop) isStorageBackend_Backend()             {}
func (*StorageBackend_Local) isStorageBackend_Backend()            {}
func (*StorageBackend_S3) isStorageBackend_Backend()               {}
func (*StorageBackend_Gcs) isStorageBackend_Backend()              {}
func (*StorageBackend_CloudDynamic) isStorageBackend_Backend()     {}
func (*StorageBackend_Hdfs) isStorageBackend_Backend()             {}
func (*StorageBackend_AzureBlobStorage) isStorageBackend_Backend() {}

func (m *StorageBackend) GetBackend() isStorageBackend_Backend {
	if m != nil {
		return m.Backend
	}
	return nil
}

func (m *StorageBackend) GetNoop() *Noop {
	if x, ok := m.GetBackend().(*StorageBackend_Noop); ok {
		return x.Noop
	}
	return nil
}

func (m *StorageBackend) GetLocal() *Local {
	if x, ok := m.GetBackend().(*StorageBackend_Local); ok {
		return x.Local
	}
	return nil
}

func (m *StorageBackend) GetS3() *S3 {
	if x, ok := m.GetBackend().(*StorageBackend_S3); ok {
		return x.S3
	}
	return nil
}

func (m *StorageBackend) GetGcs() *GCS {
	if x, ok := m.GetBackend().(*StorageBackend_Gcs); ok {
		return x.Gcs
	}
	return nil
}

func (m *StorageBackend) GetCloudDynamic() *CloudDynamic {
	if x, ok := m.GetBackend().(*StorageBackend_CloudDynamic); ok {
		return x.CloudDynamic
	}
	return nil
}

func (m *StorageBackend) GetHdfs() *HDFS {
	if x, ok := m.GetBackend().(*StorageBackend_Hdfs); ok {
		return x.Hdfs
	}
	return nil
}

func (m *StorageBackend) GetAzureBlobStorage() *AzureBlobStorage {
	if x, ok := m.GetBackend().(*StorageBackend_AzureBlobStorage); ok {
		return x.AzureBlobStorage
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StorageBackend) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StorageBackend_Noop)(nil),
		(*StorageBackend_Local)(nil),
		(*StorageBackend_S3)(nil),
		(*StorageBackend_Gcs)(nil),
		(*StorageBackend_CloudDynamic)(nil),
		(*StorageBackend_Hdfs)(nil),
		(*StorageBackend_AzureBlobStorage)(nil),
	}
}

// Noop storage backend saves files into void.
type Noop struct {
}

func (m *Noop) Reset()         { *m = Noop{} }
func (m *Noop) String() string { return proto.CompactTextString(m) }
func (*Noop) ProtoMessage()    {}
func (*Noop) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{23}
}
func (m *Noop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Noop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Noop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Noop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Noop.Merge(m, src)
}
func (m *Noop) XXX_Size() int {
	return m.Size()
}
func (m *Noop) XXX_DiscardUnknown() {
	xxx_messageInfo_Noop.DiscardUnknown(m)
}

var xxx_messageInfo_Noop proto.InternalMessageInfo

// Local storage backend saves files into local disk
type Local struct {
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *Local) Reset()         { *m = Local{} }
func (m *Local) String() string { return proto.CompactTextString(m) }
func (*Local) ProtoMessage()    {}
func (*Local) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{24}
}
func (m *Local) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Local) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Local.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Local) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Local.Merge(m, src)
}
func (m *Local) XXX_Size() int {
	return m.Size()
}
func (m *Local) XXX_DiscardUnknown() {
	xxx_messageInfo_Local.DiscardUnknown(m)
}

var xxx_messageInfo_Local proto.InternalMessageInfo

func (m *Local) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// S3 storage backend saves files into S3 compatible storages
// For non-aws providers, endpoint must be provided
type S3 struct {
	Endpoint     string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Region       string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	Bucket       string `protobuf:"bytes,3,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix       string `protobuf:"bytes,4,opt,name=prefix,proto3" json:"prefix,omitempty"`
	StorageClass string `protobuf:"bytes,5,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	// server side encryption
	Sse               string `protobuf:"bytes,6,opt,name=sse,proto3" json:"sse,omitempty"`
	Acl               string `protobuf:"bytes,7,opt,name=acl,proto3" json:"acl,omitempty"`
	AccessKey         string `protobuf:"bytes,8,opt,name=access_key,json=accessKey,proto3" json:"access_key,omitempty"`
	SecretAccessKey   string `protobuf:"bytes,9,opt,name=secret_access_key,json=secretAccessKey,proto3" json:"secret_access_key,omitempty"`
	ForcePathStyle    bool   `protobuf:"varint,10,opt,name=force_path_style,json=forcePathStyle,proto3" json:"force_path_style,omitempty"`
	SseKmsKeyId       string `protobuf:"bytes,11,opt,name=sse_kms_key_id,json=sseKmsKeyId,proto3" json:"sse_kms_key_id,omitempty"`
	RoleArn           string `protobuf:"bytes,12,opt,name=role_arn,json=roleArn,proto3" json:"role_arn,omitempty"`
	ExternalId        string `protobuf:"bytes,13,opt,name=external_id,json=externalId,proto3" json:"external_id,omitempty"`
	ObjectLockEnabled bool   `protobuf:"varint,14,opt,name=object_lock_enabled,json=objectLockEnabled,proto3" json:"object_lock_enabled,omitempty"`
	SessionToken      string `protobuf:"bytes,15,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	Provider          string `protobuf:"bytes,16,opt,name=provider,proto3" json:"provider,omitempty"`
	Profile           string `protobuf:"bytes,17,opt,name=profile,proto3" json:"profile,omitempty"`
}

func (m *S3) Reset()         { *m = S3{} }
func (m *S3) String() string { return proto.CompactTextString(m) }
func (*S3) ProtoMessage()    {}
func (*S3) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{25}
}
func (m *S3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3.Merge(m, src)
}
func (m *S3) XXX_Size() int {
	return m.Size()
}
func (m *S3) XXX_DiscardUnknown() {
	xxx_messageInfo_S3.DiscardUnknown(m)
}

var xxx_messageInfo_S3 proto.InternalMessageInfo

func (m *S3) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *S3) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *S3) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *S3) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *S3) GetStorageClass() string {
	if m != nil {
		return m.StorageClass
	}
	return ""
}

func (m *S3) GetSse() string {
	if m != nil {
		return m.Sse
	}
	return ""
}

func (m *S3) GetAcl() string {
	if m != nil {
		return m.Acl
	}
	return ""
}

func (m *S3) GetAccessKey() string {
	if m != nil {
		return m.AccessKey
	}
	return ""
}

func (m *S3) GetSecretAccessKey() string {
	if m != nil {
		return m.SecretAccessKey
	}
	return ""
}

func (m *S3) GetForcePathStyle() bool {
	if m != nil {
		return m.ForcePathStyle
	}
	return false
}

func (m *S3) GetSseKmsKeyId() string {
	if m != nil {
		return m.SseKmsKeyId
	}
	return ""
}

func (m *S3) GetRoleArn() string {
	if m != nil {
		return m.RoleArn
	}
	return ""
}

func (m *S3) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

func (m *S3) GetObjectLockEnabled() bool {
	if m != nil {
		return m.ObjectLockEnabled
	}
	return false
}

func (m *S3) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

func (m *S3) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *S3) GetProfile() string {
	if m != nil {
		return m.Profile
	}
	return ""
}

// GCS storage backend saves files into google cloud storage.
type GCS struct {
	Endpoint     string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Bucket       string `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix       string `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
	StorageClass string `protobuf:"bytes,4,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	// If not empty, applies a predefined set of access controls.
	// See https://cloud.google.com/storage/docs/access-control/lists#predefined-acl
	// for valid values.
	PredefinedAcl string `protobuf:"bytes,5,opt,name=predefined_acl,json=predefinedAcl,proto3" json:"predefined_acl,omitempty"`
	// Service Account Credentials JSON blob
	// You can get one from https://console.cloud.google.com/apis/credentials, and
	// copy the content, set it as string here.
	CredentialsBlob string `protobuf:"bytes,6,opt,name=credentials_blob,json=credentialsBlob,proto3" json:"credentials_blob,omitempty"`
}

func (m *GCS) Reset()         { *m = GCS{} }
func (m *GCS) String() string { return proto.CompactTextString(m) }
func (*GCS) ProtoMessage()    {}
func (*GCS) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{26}
}
func (m *GCS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GCS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GCS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCS.Merge(m, src)
}
func (m *GCS) XXX_Size() int {
	return m.Size()
}
func (m *GCS) XXX_DiscardUnknown() {
	xxx_messageInfo_GCS.DiscardUnknown(m)
}

var xxx_messageInfo_GCS proto.InternalMessageInfo

func (m *GCS) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *GCS) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *GCS) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *GCS) GetStorageClass() string {
	if m != nil {
		return m.StorageClass
	}
	return ""
}

func (m *GCS) GetPredefinedAcl() string {
	if m != nil {
		return m.PredefinedAcl
	}
	return ""
}

func (m *GCS) GetCredentialsBlob() string {
	if m != nil {
		return m.CredentialsBlob
	}
	return ""
}

// The encryption algorithm must be AES256.
type AzureCustomerKey struct {
	// A Base64-encoded AES-256 encryption key value.
	EncryptionKey string `protobuf:"bytes,1,opt,name=encryption_key,json=encryptionKey,proto3" json:"encryption_key,omitempty"`
	// The Base64-encoded SHA256 of the encryption key.
	EncryptionKeySha256 string `protobuf:"bytes,2,opt,name=encryption_key_sha256,json=encryptionKeySha256,proto3" json:"encryption_key_sha256,omitempty"`
}

func (m *AzureCustomerKey) Reset()         { *m = AzureCustomerKey{} }
func (m *AzureCustomerKey) String() string { return proto.CompactTextString(m) }
func (*AzureCustomerKey) ProtoMessage()    {}
func (*AzureCustomerKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{27}
}
func (m *AzureCustomerKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureCustomerKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AzureCustomerKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AzureCustomerKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureCustomerKey.Merge(m, src)
}
func (m *AzureCustomerKey) XXX_Size() int {
	return m.Size()
}
func (m *AzureCustomerKey) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureCustomerKey.DiscardUnknown(m)
}

var xxx_messageInfo_AzureCustomerKey proto.InternalMessageInfo

func (m *AzureCustomerKey) GetEncryptionKey() string {
	if m != nil {
		return m.EncryptionKey
	}
	return ""
}

func (m *AzureCustomerKey) GetEncryptionKeySha256() string {
	if m != nil {
		return m.EncryptionKeySha256
	}
	return ""
}

// AzureBlobStorage storage backend saves files into azure blob storage.
type AzureBlobStorage struct {
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Alias: container
	Bucket string `protobuf:"bytes,2,opt,name=bucket,proto3" json:"bucket,omitempty"`
	// Notice: prefix starts without `/`, otherwise the first directory's name is empty.
	Prefix string `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Alias: access_tier.
	// See https://docs.microsoft.com/en-us/azure/storage/blobs/access-tiers-overview
	StorageClass string `protobuf:"bytes,4,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
	// if empty, try to read account_name from the node's environment variable $AZURE_STORAGE_ACCOUNT.
	AccountName string `protobuf:"bytes,5,opt,name=account_name,json=accountName,proto3" json:"account_name,omitempty"`
	// There are 3 kinds of credentials, and the priority order is
	//   `SAS > Shared key > Azure AD (env) > Shared key (env)`.
	//
	// 1. Use shared key to access the azure blob
	// If the node's environment variables($AZURE_CLIENT_ID, $AZURE_TENANT_ID, $AZURE_CLIENT_SECRET) exist,
	// prefer to use token to access the azure blob.
	//
	//   See https://learn.microsoft.com/en-us/rest/api/storageservices/authorize-with-shared-key
	//
	// Otherwise, if empty, try to read shared key from the node's environment variable $AZURE_STORAGE_KEY.
	SharedKey string `protobuf:"bytes,6,opt,name=shared_key,json=sharedKey,proto3" json:"shared_key,omitempty"`
	// 2. Use Azure AD (Azure Active Directory) to access the azure blob
	//
	//   See https://learn.microsoft.com/en-us/rest/api/storageservices/authorize-with-azure-active-directory
	//
	// The Azure AD would generate the token, which tasks some time.
	// So it is not recommanded to generate the token in each request.
	// // AzureActiveDirectory azure_ad = #;
	//
	// 3. Use SAS (shared access signature)
	//
	//   See https://learn.microsoft.com/en-us/rest/api/storageservices/delegate-access-with-shared-access-signature
	//
	AccessSig string `protobuf:"bytes,8,opt,name=access_sig,json=accessSig,proto3" json:"access_sig,omitempty"`
	// Server Side Encryption, 2 types in total:
	//
	// 1. Specify an encryption scope for uploaded blobs.
	//
	//   See https://learn.microsoft.com/en-us/azure/storage/blobs/encryption-scope-manage?tabs=powershell#upload-a-blob-with-an-encryption-scope
	//
	EncryptionScope string `protobuf:"bytes,9,opt,name=encryption_scope,json=encryptionScope,proto3" json:"encryption_scope,omitempty"`
	// 2. Provide an encryption key on a request to blob storage.
	//
	//   See https://learn.microsoft.com/en-us/azure/storage/blobs/encryption-customer-provided-keys
	//
	EncryptionKey *AzureCustomerKey `protobuf:"bytes,10,opt,name=encryption_key,json=encryptionKey,proto3" json:"encryption_key,omitempty"`
}

func (m *AzureBlobStorage) Reset()         { *m = AzureBlobStorage{} }
func (m *AzureBlobStorage) String() string { return proto.CompactTextString(m) }
func (*AzureBlobStorage) ProtoMessage()    {}
func (*AzureBlobStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{28}
}
func (m *AzureBlobStorage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureBlobStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AzureBlobStorage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AzureBlobStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureBlobStorage.Merge(m, src)
}
func (m *AzureBlobStorage) XXX_Size() int {
	return m.Size()
}
func (m *AzureBlobStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureBlobStorage.DiscardUnknown(m)
}

var xxx_messageInfo_AzureBlobStorage proto.InternalMessageInfo

func (m *AzureBlobStorage) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *AzureBlobStorage) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *AzureBlobStorage) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *AzureBlobStorage) GetStorageClass() string {
	if m != nil {
		return m.StorageClass
	}
	return ""
}

func (m *AzureBlobStorage) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *AzureBlobStorage) GetSharedKey() string {
	if m != nil {
		return m.SharedKey
	}
	return ""
}

func (m *AzureBlobStorage) GetAccessSig() string {
	if m != nil {
		return m.AccessSig
	}
	return ""
}

func (m *AzureBlobStorage) GetEncryptionScope() string {
	if m != nil {
		return m.EncryptionScope
	}
	return ""
}

func (m *AzureBlobStorage) GetEncryptionKey() *AzureCustomerKey {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

type Bucket struct {
	Endpoint     string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Region       string `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
	Bucket       string `protobuf:"bytes,4,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix       string `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`
	StorageClass string `protobuf:"bytes,6,opt,name=storage_class,json=storageClass,proto3" json:"storage_class,omitempty"`
}

func (m *Bucket) Reset()         { *m = Bucket{} }
func (m *Bucket) String() string { return proto.CompactTextString(m) }
func (*Bucket) ProtoMessage()    {}
func (*Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{29}
}
func (m *Bucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bucket.Merge(m, src)
}
func (m *Bucket) XXX_Size() int {
	return m.Size()
}
func (m *Bucket) XXX_DiscardUnknown() {
	xxx_messageInfo_Bucket.DiscardUnknown(m)
}

var xxx_messageInfo_Bucket proto.InternalMessageInfo

func (m *Bucket) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Bucket) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Bucket) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *Bucket) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *Bucket) GetStorageClass() string {
	if m != nil {
		return m.StorageClass
	}
	return ""
}

// CloudDynamic allows testing new cloud providers and new fields without changing protobuf definitions
type CloudDynamic struct {
	Bucket       *Bucket           `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	ProviderName string            `protobuf:"bytes,2,opt,name=provider_name,json=providerName,proto3" json:"provider_name,omitempty"`
	Attrs        map[string]string `protobuf:"bytes,3,rep,name=attrs,proto3" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CloudDynamic) Reset()         { *m = CloudDynamic{} }
func (m *CloudDynamic) String() string { return proto.CompactTextString(m) }
func (*CloudDynamic) ProtoMessage()    {}
func (*CloudDynamic) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{30}
}
func (m *CloudDynamic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudDynamic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudDynamic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudDynamic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudDynamic.Merge(m, src)
}
func (m *CloudDynamic) XXX_Size() int {
	return m.Size()
}
func (m *CloudDynamic) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudDynamic.DiscardUnknown(m)
}

var xxx_messageInfo_CloudDynamic proto.InternalMessageInfo

func (m *CloudDynamic) GetBucket() *Bucket {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *CloudDynamic) GetProviderName() string {
	if m != nil {
		return m.ProviderName
	}
	return ""
}

func (m *CloudDynamic) GetAttrs() map[string]string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// HDFS storage backend saves file into HDFS compatible storages
type HDFS struct {
	//  a URL: hdfs:///some/path or hdfs://host:port/some/path
	Remote string `protobuf:"bytes,1,opt,name=remote,proto3" json:"remote,omitempty"`
}

func (m *HDFS) Reset()         { *m = HDFS{} }
func (m *HDFS) String() string { return proto.CompactTextString(m) }
func (*HDFS) ProtoMessage()    {}
func (*HDFS) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{31}
}
func (m *HDFS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HDFS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HDFS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HDFS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HDFS.Merge(m, src)
}
func (m *HDFS) XXX_Size() int {
	return m.Size()
}
func (m *HDFS) XXX_DiscardUnknown() {
	xxx_messageInfo_HDFS.DiscardUnknown(m)
}

var xxx_messageInfo_HDFS proto.InternalMessageInfo

func (m *HDFS) GetRemote() string {
	if m != nil {
		return m.Remote
	}
	return ""
}

type BackupResponse struct {
	Error    *Error  `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	StartKey []byte  `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte  `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Files    []*File `protobuf:"bytes,4,rep,name=files,proto3" json:"files,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion kvrpcpb.APIVersion `protobuf:"varint,5,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
}

func (m *BackupResponse) Reset()         { *m = BackupResponse{} }
func (m *BackupResponse) String() string { return proto.CompactTextString(m) }
func (*BackupResponse) ProtoMessage()    {}
func (*BackupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{32}
}
func (m *BackupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupResponse.Merge(m, src)
}
func (m *BackupResponse) XXX_Size() int {
	return m.Size()
}
func (m *BackupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BackupResponse proto.InternalMessageInfo

func (m *BackupResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *BackupResponse) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *BackupResponse) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *BackupResponse) GetFiles() []*File {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *BackupResponse) GetApiVersion() kvrpcpb.APIVersion {
	if m != nil {
		return m.ApiVersion
	}
	return kvrpcpb.APIVersion_V1
}

type CleanupRequest struct {
	// unique_id represents the unique handle of the whole backup predecure.
	// it generated in prepare request and corrosponed to one specific backup.
	UniqueId string `protobuf:"bytes,1,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
}

func (m *CleanupRequest) Reset()         { *m = CleanupRequest{} }
func (m *CleanupRequest) String() string { return proto.CompactTextString(m) }
func (*CleanupRequest) ProtoMessage()    {}
func (*CleanupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{33}
}
func (m *CleanupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CleanupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CleanupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CleanupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CleanupRequest.Merge(m, src)
}
func (m *CleanupRequest) XXX_Size() int {
	return m.Size()
}
func (m *CleanupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CleanupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CleanupRequest proto.InternalMessageInfo

func (m *CleanupRequest) GetUniqueId() string {
	if m != nil {
		return m.UniqueId
	}
	return ""
}

type CleanupResponse struct {
	Error   *Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Success bool   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *CleanupResponse) Reset()         { *m = CleanupResponse{} }
func (m *CleanupResponse) String() string { return proto.CompactTextString(m) }
func (*CleanupResponse) ProtoMessage()    {}
func (*CleanupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{34}
}
func (m *CleanupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CleanupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CleanupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CleanupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CleanupResponse.Merge(m, src)
}
func (m *CleanupResponse) XXX_Size() int {
	return m.Size()
}
func (m *CleanupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CleanupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CleanupResponse proto.InternalMessageInfo

func (m *CleanupResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CleanupResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type PrepareRequest struct {
	// whether save state to the storage.
	SaveToStorage bool `protobuf:"varint,1,opt,name=save_to_storage,json=saveToStorage,proto3" json:"save_to_storage,omitempty"`
}

func (m *PrepareRequest) Reset()         { *m = PrepareRequest{} }
func (m *PrepareRequest) String() string { return proto.CompactTextString(m) }
func (*PrepareRequest) ProtoMessage()    {}
func (*PrepareRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{35}
}
func (m *PrepareRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareRequest.Merge(m, src)
}
func (m *PrepareRequest) XXX_Size() int {
	return m.Size()
}
func (m *PrepareRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareRequest proto.InternalMessageInfo

func (m *PrepareRequest) GetSaveToStorage() bool {
	if m != nil {
		return m.SaveToStorage
	}
	return false
}

type PrepareResponse struct {
	Error *Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// unique_id represents the unique handle of the whole backup predecure.
	// if unique_id = 0 means prepare failed.
	// if unique_id > 0 means prepare success and all states saved with this unique info.
	UniqueId         string `protobuf:"bytes,2,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	CollectFileCount uint64 `protobuf:"varint,3,opt,name=collect_file_count,json=collectFileCount,proto3" json:"collect_file_count,omitempty"`
	CollectFileSize  uint64 `protobuf:"varint,4,opt,name=collect_file_size,json=collectFileSize,proto3" json:"collect_file_size,omitempty"`
}

func (m *PrepareResponse) Reset()         { *m = PrepareResponse{} }
func (m *PrepareResponse) String() string { return proto.CompactTextString(m) }
func (*PrepareResponse) ProtoMessage()    {}
func (*PrepareResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{36}
}
func (m *PrepareResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareResponse.Merge(m, src)
}
func (m *PrepareResponse) XXX_Size() int {
	return m.Size()
}
func (m *PrepareResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareResponse proto.InternalMessageInfo

func (m *PrepareResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *PrepareResponse) GetUniqueId() string {
	if m != nil {
		return m.UniqueId
	}
	return ""
}

func (m *PrepareResponse) GetCollectFileCount() uint64 {
	if m != nil {
		return m.CollectFileCount
	}
	return 0
}

func (m *PrepareResponse) GetCollectFileSize() uint64 {
	if m != nil {
		return m.CollectFileSize
	}
	return 0
}

type CheckAdminRequest struct {
}

func (m *CheckAdminRequest) Reset()         { *m = CheckAdminRequest{} }
func (m *CheckAdminRequest) String() string { return proto.CompactTextString(m) }
func (*CheckAdminRequest) ProtoMessage()    {}
func (*CheckAdminRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{37}
}
func (m *CheckAdminRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckAdminRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckAdminRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckAdminRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckAdminRequest.Merge(m, src)
}
func (m *CheckAdminRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckAdminRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckAdminRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckAdminRequest proto.InternalMessageInfo

type CheckAdminResponse struct {
	Error           *Error         `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Region          *metapb.Region `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
	HasPendingAdmin bool           `protobuf:"varint,3,opt,name=has_pending_admin,json=hasPendingAdmin,proto3" json:"has_pending_admin,omitempty"`
}

func (m *CheckAdminResponse) Reset()         { *m = CheckAdminResponse{} }
func (m *CheckAdminResponse) String() string { return proto.CompactTextString(m) }
func (*CheckAdminResponse) ProtoMessage()    {}
func (*CheckAdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{38}
}
func (m *CheckAdminResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckAdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckAdminResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckAdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckAdminResponse.Merge(m, src)
}
func (m *CheckAdminResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckAdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckAdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckAdminResponse proto.InternalMessageInfo

func (m *CheckAdminResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CheckAdminResponse) GetRegion() *metapb.Region {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *CheckAdminResponse) GetHasPendingAdmin() bool {
	if m != nil {
		return m.HasPendingAdmin
	}
	return false
}

type ExternalStorageRestoreRequest struct {
	StorageBackend *StorageBackend `protobuf:"bytes,1,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	ObjectName     string          `protobuf:"bytes,2,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	RestoreName    string          `protobuf:"bytes,3,opt,name=restore_name,json=restoreName,proto3" json:"restore_name,omitempty"`
	ContentLength  uint64          `protobuf:"varint,4,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
}

func (m *ExternalStorageRestoreRequest) Reset()         { *m = ExternalStorageRestoreRequest{} }
func (m *ExternalStorageRestoreRequest) String() string { return proto.CompactTextString(m) }
func (*ExternalStorageRestoreRequest) ProtoMessage()    {}
func (*ExternalStorageRestoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{39}
}
func (m *ExternalStorageRestoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorageRestoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalStorageRestoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalStorageRestoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorageRestoreRequest.Merge(m, src)
}
func (m *ExternalStorageRestoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorageRestoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorageRestoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorageRestoreRequest proto.InternalMessageInfo

func (m *ExternalStorageRestoreRequest) GetStorageBackend() *StorageBackend {
	if m != nil {
		return m.StorageBackend
	}
	return nil
}

func (m *ExternalStorageRestoreRequest) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *ExternalStorageRestoreRequest) GetRestoreName() string {
	if m != nil {
		return m.RestoreName
	}
	return ""
}

func (m *ExternalStorageRestoreRequest) GetContentLength() uint64 {
	if m != nil {
		return m.ContentLength
	}
	return 0
}

type ExternalStorageRestoreResponse struct {
}

func (m *ExternalStorageRestoreResponse) Reset()         { *m = ExternalStorageRestoreResponse{} }
func (m *ExternalStorageRestoreResponse) String() string { return proto.CompactTextString(m) }
func (*ExternalStorageRestoreResponse) ProtoMessage()    {}
func (*ExternalStorageRestoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{40}
}
func (m *ExternalStorageRestoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorageRestoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalStorageRestoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalStorageRestoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorageRestoreResponse.Merge(m, src)
}
func (m *ExternalStorageRestoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorageRestoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorageRestoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorageRestoreResponse proto.InternalMessageInfo

type ExternalStorageSaveRequest struct {
	StorageBackend *StorageBackend `protobuf:"bytes,1,opt,name=storage_backend,json=storageBackend,proto3" json:"storage_backend,omitempty"`
	ObjectName     string          `protobuf:"bytes,2,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	ContentLength  uint64          `protobuf:"varint,3,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
}

func (m *ExternalStorageSaveRequest) Reset()         { *m = ExternalStorageSaveRequest{} }
func (m *ExternalStorageSaveRequest) String() string { return proto.CompactTextString(m) }
func (*ExternalStorageSaveRequest) ProtoMessage()    {}
func (*ExternalStorageSaveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{41}
}
func (m *ExternalStorageSaveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorageSaveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalStorageSaveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalStorageSaveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorageSaveRequest.Merge(m, src)
}
func (m *ExternalStorageSaveRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorageSaveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorageSaveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorageSaveRequest proto.InternalMessageInfo

func (m *ExternalStorageSaveRequest) GetStorageBackend() *StorageBackend {
	if m != nil {
		return m.StorageBackend
	}
	return nil
}

func (m *ExternalStorageSaveRequest) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *ExternalStorageSaveRequest) GetContentLength() uint64 {
	if m != nil {
		return m.ContentLength
	}
	return 0
}

type ExternalStorageSaveResponse struct {
}

func (m *ExternalStorageSaveResponse) Reset()         { *m = ExternalStorageSaveResponse{} }
func (m *ExternalStorageSaveResponse) String() string { return proto.CompactTextString(m) }
func (*ExternalStorageSaveResponse) ProtoMessage()    {}
func (*ExternalStorageSaveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{42}
}
func (m *ExternalStorageSaveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalStorageSaveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalStorageSaveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalStorageSaveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalStorageSaveResponse.Merge(m, src)
}
func (m *ExternalStorageSaveResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExternalStorageSaveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalStorageSaveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalStorageSaveResponse proto.InternalMessageInfo

type Metadata struct {
	// deprecated after(in) v6.3.0 TiKV cluster
	Files       []*DataFileInfo  `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
	FileGroups  []*DataFileGroup `protobuf:"bytes,6,rep,name=file_groups,json=fileGroups,proto3" json:"file_groups,omitempty"`
	StoreId     int64            `protobuf:"varint,2,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
	ResolvedTs  uint64           `protobuf:"varint,3,opt,name=resolved_ts,json=resolvedTs,proto3" json:"resolved_ts,omitempty"`
	MaxTs       uint64           `protobuf:"varint,4,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	MinTs       uint64           `protobuf:"varint,5,opt,name=min_ts,json=minTs,proto3" json:"min_ts,omitempty"`
	MetaVersion MetaVersion      `protobuf:"varint,7,opt,name=meta_version,json=metaVersion,proto3,enum=backup.MetaVersion" json:"meta_version,omitempty"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{43}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetFiles() []*DataFileInfo {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *Metadata) GetFileGroups() []*DataFileGroup {
	if m != nil {
		return m.FileGroups
	}
	return nil
}

func (m *Metadata) GetStoreId() int64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

func (m *Metadata) GetResolvedTs() uint64 {
	if m != nil {
		return m.ResolvedTs
	}
	return 0
}

func (m *Metadata) GetMaxTs() uint64 {
	if m != nil {
		return m.MaxTs
	}
	return 0
}

func (m *Metadata) GetMinTs() uint64 {
	if m != nil {
		return m.MinTs
	}
	return 0
}

func (m *Metadata) GetMetaVersion() MetaVersion {
	if m != nil {
		return m.MetaVersion
	}
	return MetaVersion_V1
}

// DataFileGroup is the merged file info in log-backup
type DataFileGroup struct {
	// Path of the file.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Partitions of the file.
	DataFilesInfo []*DataFileInfo `protobuf:"bytes,2,rep,name=data_files_info,json=dataFilesInfo,proto3" json:"data_files_info,omitempty"`
	/// Below are extra information of the file, for better filtering files.
	// The min ts of the keys in the file.
	MinTs uint64 `protobuf:"varint,3,opt,name=min_ts,json=minTs,proto3" json:"min_ts,omitempty"`
	// The max ts of the keys in the file.
	MaxTs uint64 `protobuf:"varint,4,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	// The resolved ts of the region when saving the file.
	MinResolvedTs uint64 `protobuf:"varint,5,opt,name=min_resolved_ts,json=minResolvedTs,proto3" json:"min_resolved_ts,omitempty"`
	// The file length after compressed.
	Length uint64 `protobuf:"varint,6,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *DataFileGroup) Reset()         { *m = DataFileGroup{} }
func (m *DataFileGroup) String() string { return proto.CompactTextString(m) }
func (*DataFileGroup) ProtoMessage()    {}
func (*DataFileGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{44}
}
func (m *DataFileGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataFileGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataFileGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataFileGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataFileGroup.Merge(m, src)
}
func (m *DataFileGroup) XXX_Size() int {
	return m.Size()
}
func (m *DataFileGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_DataFileGroup.DiscardUnknown(m)
}

var xxx_messageInfo_DataFileGroup proto.InternalMessageInfo

func (m *DataFileGroup) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *DataFileGroup) GetDataFilesInfo() []*DataFileInfo {
	if m != nil {
		return m.DataFilesInfo
	}
	return nil
}

func (m *DataFileGroup) GetMinTs() uint64 {
	if m != nil {
		return m.MinTs
	}
	return 0
}

func (m *DataFileGroup) GetMaxTs() uint64 {
	if m != nil {
		return m.MaxTs
	}
	return 0
}

func (m *DataFileGroup) GetMinResolvedTs() uint64 {
	if m != nil {
		return m.MinResolvedTs
	}
	return 0
}

func (m *DataFileGroup) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

type DataFileInfo struct {
	// Checksum of the plaintext file, i.e., pre-compression, pre-encryption.
	Sha256 []byte `protobuf:"bytes,1,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// Path of the file.
	Path            string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	NumberOfEntries int64  `protobuf:"varint,3,opt,name=number_of_entries,json=numberOfEntries,proto3" json:"number_of_entries,omitempty"`
	/// Below are extra information of the file, for better filtering files.
	// The min ts of the keys in the file.
	MinTs uint64 `protobuf:"varint,4,opt,name=min_ts,json=minTs,proto3" json:"min_ts,omitempty"`
	// The max ts of the keys in the file.
	MaxTs uint64 `protobuf:"varint,5,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	// The resolved ts of the region when saving the file.
	ResolvedTs uint64 `protobuf:"varint,6,opt,name=resolved_ts,json=resolvedTs,proto3" json:"resolved_ts,omitempty"`
	// The region of the file.
	RegionId int64 `protobuf:"varint,7,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// The key range of the file.
	// Encoded and starts with 'z'(internal key).
	StartKey []byte `protobuf:"bytes,8,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,9,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// The column family of the file.
	Cf string `protobuf:"bytes,10,opt,name=cf,proto3" json:"cf,omitempty"`
	// The operation type of the file.
	Type FileType `protobuf:"varint,11,opt,name=type,proto3,enum=backup.FileType" json:"type,omitempty"`
	// Whether the data file contains meta keys(m prefixed keys) only.
	IsMeta bool `protobuf:"varint,12,opt,name=is_meta,json=isMeta,proto3" json:"is_meta,omitempty"`
	// The table ID of the file contains, when `is_meta` is true, would be ignored.
	TableId int64 `protobuf:"varint,13,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// The file length.
	Length uint64 `protobuf:"varint,14,opt,name=length,proto3" json:"length,omitempty"`
	// The minimal begin ts in default cf if this file is write cf.
	MinBeginTsInDefaultCf uint64 `protobuf:"varint,15,opt,name=min_begin_ts_in_default_cf,json=minBeginTsInDefaultCf,proto3" json:"min_begin_ts_in_default_cf,omitempty"`
	// Offset of the partition. compatible with V1 and V2.
	RangeOffset uint64 `protobuf:"varint,16,opt,name=range_offset,json=rangeOffset,proto3" json:"range_offset,omitempty"`
	// The range length of the merged file, if it exists.
	RangeLength uint64 `protobuf:"varint,17,opt,name=range_length,json=rangeLength,proto3" json:"range_length,omitempty"`
	// The compression type for the file.
	CompressionType CompressionType `protobuf:"varint,18,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
	// The CRC64XOR of all contents of the file.
	// In older versions, this might be empty.
	Crc64Xor uint64 `protobuf:"varint,19,opt,name=crc64xor,proto3" json:"crc64xor,omitempty"`
	// The original region range the log file belongs to.
	// In older versions, this might be empty.
	// This may not be accurative: file may contain keys less than this.
	RegionStartKey []byte `protobuf:"bytes,20,opt,name=region_start_key,json=regionStartKey,proto3" json:"region_start_key,omitempty"`
	// The original region range the log file belongs to.
	// In older versions, this might be empty.
	// This may not be accurative: file may contain keys greater than this.
	RegionEndKey []byte `protobuf:"bytes,21,opt,name=region_end_key,json=regionEndKey,proto3" json:"region_end_key,omitempty"`
	// The region epoch that the log file belongs to.
	// In older versions, this might be empty.
	// If a region get split or merged during observing, the file may contain multi epoches.
	// This may not be complete: file may contain records from other versions.
	//
	// If there is exactly one epoch,
	// `region_start_key` and `region_end_key` must match this epoch.
	RegionEpoch []*metapb.RegionEpoch `protobuf:"bytes,22,rep,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
	// Encryption information of this data file, not set if plaintext.
	FileEncryptionInfo *encryptionpb.FileEncryptionInfo `protobuf:"bytes,23,opt,name=file_encryption_info,json=fileEncryptionInfo,proto3" json:"file_encryption_info,omitempty"`
}

func (m *DataFileInfo) Reset()         { *m = DataFileInfo{} }
func (m *DataFileInfo) String() string { return proto.CompactTextString(m) }
func (*DataFileInfo) ProtoMessage()    {}
func (*DataFileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{45}
}
func (m *DataFileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataFileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataFileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataFileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataFileInfo.Merge(m, src)
}
func (m *DataFileInfo) XXX_Size() int {
	return m.Size()
}
func (m *DataFileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DataFileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DataFileInfo proto.InternalMessageInfo

func (m *DataFileInfo) GetSha256() []byte {
	if m != nil {
		return m.Sha256
	}
	return nil
}

func (m *DataFileInfo) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *DataFileInfo) GetNumberOfEntries() int64 {
	if m != nil {
		return m.NumberOfEntries
	}
	return 0
}

func (m *DataFileInfo) GetMinTs() uint64 {
	if m != nil {
		return m.MinTs
	}
	return 0
}

func (m *DataFileInfo) GetMaxTs() uint64 {
	if m != nil {
		return m.MaxTs
	}
	return 0
}

func (m *DataFileInfo) GetResolvedTs() uint64 {
	if m != nil {
		return m.ResolvedTs
	}
	return 0
}

func (m *DataFileInfo) GetRegionId() int64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *DataFileInfo) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *DataFileInfo) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *DataFileInfo) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *DataFileInfo) GetType() FileType {
	if m != nil {
		return m.Type
	}
	return FileType_Delete
}

func (m *DataFileInfo) GetIsMeta() bool {
	if m != nil {
		return m.IsMeta
	}
	return false
}

func (m *DataFileInfo) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DataFileInfo) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DataFileInfo) GetMinBeginTsInDefaultCf() uint64 {
	if m != nil {
		return m.MinBeginTsInDefaultCf
	}
	return 0
}

func (m *DataFileInfo) GetRangeOffset() uint64 {
	if m != nil {
		return m.RangeOffset
	}
	return 0
}

func (m *DataFileInfo) GetRangeLength() uint64 {
	if m != nil {
		return m.RangeLength
	}
	return 0
}

func (m *DataFileInfo) GetCompressionType() CompressionType {
	if m != nil {
		return m.CompressionType
	}
	return CompressionType_UNKNOWN
}

func (m *DataFileInfo) GetCrc64Xor() uint64 {
	if m != nil {
		return m.Crc64Xor
	}
	return 0
}

func (m *DataFileInfo) GetRegionStartKey() []byte {
	if m != nil {
		return m.RegionStartKey
	}
	return nil
}

func (m *DataFileInfo) GetRegionEndKey() []byte {
	if m != nil {
		return m.RegionEndKey
	}
	return nil
}

func (m *DataFileInfo) GetRegionEpoch() []*metapb.RegionEpoch {
	if m != nil {
		return m.RegionEpoch
	}
	return nil
}

func (m *DataFileInfo) GetFileEncryptionInfo() *encryptionpb.FileEncryptionInfo {
	if m != nil {
		return m.FileEncryptionInfo
	}
	return nil
}

type StreamBackupError struct {
	// the unix epoch time (in millisecs) of the time the error reported.
	HappenAt uint64 `protobuf:"varint,1,opt,name=happen_at,json=happenAt,proto3" json:"happen_at,omitempty"`
	// the unified error code of the error.
	ErrorCode string `protobuf:"bytes,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// the user-friendly error message.
	ErrorMessage string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// the store id of who issues the error.
	StoreId uint64 `protobuf:"varint,4,opt,name=store_id,json=storeId,proto3" json:"store_id,omitempty"`
}

func (m *StreamBackupError) Reset()         { *m = StreamBackupError{} }
func (m *StreamBackupError) String() string { return proto.CompactTextString(m) }
func (*StreamBackupError) ProtoMessage()    {}
func (*StreamBackupError) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{46}
}
func (m *StreamBackupError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamBackupError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamBackupError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamBackupError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamBackupError.Merge(m, src)
}
func (m *StreamBackupError) XXX_Size() int {
	return m.Size()
}
func (m *StreamBackupError) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamBackupError.DiscardUnknown(m)
}

var xxx_messageInfo_StreamBackupError proto.InternalMessageInfo

func (m *StreamBackupError) GetHappenAt() uint64 {
	if m != nil {
		return m.HappenAt
	}
	return 0
}

func (m *StreamBackupError) GetErrorCode() string {
	if m != nil {
		return m.ErrorCode
	}
	return ""
}

func (m *StreamBackupError) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *StreamBackupError) GetStoreId() uint64 {
	if m != nil {
		return m.StoreId
	}
	return 0
}

type Span struct {
	Offset uint64 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Length uint64 `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *Span) Reset()         { *m = Span{} }
func (m *Span) String() string { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()    {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{47}
}
func (m *Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Span.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return m.Size()
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

func (m *Span) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Span) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

type SpansOfFile struct {
	Path  string  `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Spans []*Span `protobuf:"bytes,2,rep,name=spans,proto3" json:"spans,omitempty"`
}

func (m *SpansOfFile) Reset()         { *m = SpansOfFile{} }
func (m *SpansOfFile) String() string { return proto.CompactTextString(m) }
func (*SpansOfFile) ProtoMessage()    {}
func (*SpansOfFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{48}
}
func (m *SpansOfFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpansOfFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpansOfFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpansOfFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpansOfFile.Merge(m, src)
}
func (m *SpansOfFile) XXX_Size() int {
	return m.Size()
}
func (m *SpansOfFile) XXX_DiscardUnknown() {
	xxx_messageInfo_SpansOfFile.DiscardUnknown(m)
}

var xxx_messageInfo_SpansOfFile proto.InternalMessageInfo

func (m *SpansOfFile) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *SpansOfFile) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

type LogFileSubcompactionMeta struct {
	// The whole size of this subcompaction.
	// It should be the physical size of all input logs.
	Size_ uint64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	// The region that we perform the subcompaction.
	RegionId   uint64 `protobuf:"varint,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	Cf         string `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	InputMaxTs uint64 `protobuf:"varint,4,opt,name=input_max_ts,json=inputMaxTs,proto3" json:"input_max_ts,omitempty"`
	InputMinTs uint64 `protobuf:"varint,5,opt,name=input_min_ts,json=inputMinTs,proto3" json:"input_min_ts,omitempty"`
	// The whole compaction's configure.
	CompactFromTs  uint64 `protobuf:"varint,6,opt,name=compact_from_ts,json=compactFromTs,proto3" json:"compact_from_ts,omitempty"`
	CompactUntilTs uint64 `protobuf:"varint,7,opt,name=compact_until_ts,json=compactUntilTs,proto3" json:"compact_until_ts,omitempty"`
	// The key range of the input logs.
	// They are encoded user key. (i.e. mem-comparable, no 'z' prefix)
	MinKey []byte `protobuf:"bytes,8,opt,name=min_key,json=minKey,proto3" json:"min_key,omitempty"`
	// The largest key from the input.
	MaxKey []byte `protobuf:"bytes,9,opt,name=max_key,json=maxKey,proto3" json:"max_key,omitempty"`
	// The type of operations in the file. (Write or Delete)
	Ty      FileType `protobuf:"varint,10,opt,name=ty,proto3,enum=backup.FileType" json:"ty,omitempty"`
	TableId int64    `protobuf:"varint,11,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// The input log files of this.
	Sources []*SpansOfFile `protobuf:"bytes,12,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (m *LogFileSubcompactionMeta) Reset()         { *m = LogFileSubcompactionMeta{} }
func (m *LogFileSubcompactionMeta) String() string { return proto.CompactTextString(m) }
func (*LogFileSubcompactionMeta) ProtoMessage()    {}
func (*LogFileSubcompactionMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{49}
}
func (m *LogFileSubcompactionMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFileSubcompactionMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogFileSubcompactionMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogFileSubcompactionMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFileSubcompactionMeta.Merge(m, src)
}
func (m *LogFileSubcompactionMeta) XXX_Size() int {
	return m.Size()
}
func (m *LogFileSubcompactionMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFileSubcompactionMeta.DiscardUnknown(m)
}

var xxx_messageInfo_LogFileSubcompactionMeta proto.InternalMessageInfo

func (m *LogFileSubcompactionMeta) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *LogFileSubcompactionMeta) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *LogFileSubcompactionMeta) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *LogFileSubcompactionMeta) GetInputMaxTs() uint64 {
	if m != nil {
		return m.InputMaxTs
	}
	return 0
}

func (m *LogFileSubcompactionMeta) GetInputMinTs() uint64 {
	if m != nil {
		return m.InputMinTs
	}
	return 0
}

func (m *LogFileSubcompactionMeta) GetCompactFromTs() uint64 {
	if m != nil {
		return m.CompactFromTs
	}
	return 0
}

func (m *LogFileSubcompactionMeta) GetCompactUntilTs() uint64 {
	if m != nil {
		return m.CompactUntilTs
	}
	return 0
}

func (m *LogFileSubcompactionMeta) GetMinKey() []byte {
	if m != nil {
		return m.MinKey
	}
	return nil
}

func (m *LogFileSubcompactionMeta) GetMaxKey() []byte {
	if m != nil {
		return m.MaxKey
	}
	return nil
}

func (m *LogFileSubcompactionMeta) GetTy() FileType {
	if m != nil {
		return m.Ty
	}
	return FileType_Delete
}

func (m *LogFileSubcompactionMeta) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *LogFileSubcompactionMeta) GetSources() []*SpansOfFile {
	if m != nil {
		return m.Sources
	}
	return nil
}

// A subcompaction from a compaction.
// Subcompactions are actions that collect then sort key values from one region.
type LogFileSubcompaction struct {
	// The metadata of the subcompaction.
	Meta *LogFileSubcompactionMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// The generated SSTs.
	SstOutputs []*File `protobuf:"bytes,2,rep,name=sst_outputs,json=sstOutputs,proto3" json:"sst_outputs,omitempty"`
	// The hint for the history of the region that contains the keys being compacted.
	// This may be helpful for splitting, but it does not guarantee completeness and accuracy.
	RegionMetaHints []*RegionMetaHint `protobuf:"bytes,3,rep,name=region_meta_hints,json=regionMetaHints,proto3" json:"region_meta_hints,omitempty"`
}

func (m *LogFileSubcompaction) Reset()         { *m = LogFileSubcompaction{} }
func (m *LogFileSubcompaction) String() string { return proto.CompactTextString(m) }
func (*LogFileSubcompaction) ProtoMessage()    {}
func (*LogFileSubcompaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{50}
}
func (m *LogFileSubcompaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFileSubcompaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogFileSubcompaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogFileSubcompaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFileSubcompaction.Merge(m, src)
}
func (m *LogFileSubcompaction) XXX_Size() int {
	return m.Size()
}
func (m *LogFileSubcompaction) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFileSubcompaction.DiscardUnknown(m)
}

var xxx_messageInfo_LogFileSubcompaction proto.InternalMessageInfo

func (m *LogFileSubcompaction) GetMeta() *LogFileSubcompactionMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *LogFileSubcompaction) GetSstOutputs() []*File {
	if m != nil {
		return m.SstOutputs
	}
	return nil
}

func (m *LogFileSubcompaction) GetRegionMetaHints() []*RegionMetaHint {
	if m != nil {
		return m.RegionMetaHints
	}
	return nil
}

type RegionMetaHint struct {
	// The left boundary of the region of this epoch.
	// It is an byte-comparable encoded key without TS.
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// The right boundary of the region of the epoch.
	EndKey []byte `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// The region epoch.
	RegionEpoch *metapb.RegionEpoch `protobuf:"bytes,3,opt,name=region_epoch,json=regionEpoch,proto3" json:"region_epoch,omitempty"`
}

func (m *RegionMetaHint) Reset()         { *m = RegionMetaHint{} }
func (m *RegionMetaHint) String() string { return proto.CompactTextString(m) }
func (*RegionMetaHint) ProtoMessage()    {}
func (*RegionMetaHint) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{51}
}
func (m *RegionMetaHint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionMetaHint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionMetaHint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionMetaHint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionMetaHint.Merge(m, src)
}
func (m *RegionMetaHint) XXX_Size() int {
	return m.Size()
}
func (m *RegionMetaHint) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionMetaHint.DiscardUnknown(m)
}

var xxx_messageInfo_RegionMetaHint proto.InternalMessageInfo

func (m *RegionMetaHint) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *RegionMetaHint) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *RegionMetaHint) GetRegionEpoch() *metapb.RegionEpoch {
	if m != nil {
		return m.RegionEpoch
	}
	return nil
}

// Batched version of `LogFileSubcompaction`.
// So we can store many subcompactions to one file, to reduce the number of file.
type LogFileSubcompactions struct {
	Subcompactions []*LogFileSubcompaction `protobuf:"bytes,1,rep,name=subcompactions,proto3" json:"subcompactions,omitempty"`
}

func (m *LogFileSubcompactions) Reset()         { *m = LogFileSubcompactions{} }
func (m *LogFileSubcompactions) String() string { return proto.CompactTextString(m) }
func (*LogFileSubcompactions) ProtoMessage()    {}
func (*LogFileSubcompactions) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{52}
}
func (m *LogFileSubcompactions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFileSubcompactions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogFileSubcompactions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogFileSubcompactions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFileSubcompactions.Merge(m, src)
}
func (m *LogFileSubcompactions) XXX_Size() int {
	return m.Size()
}
func (m *LogFileSubcompactions) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFileSubcompactions.DiscardUnknown(m)
}

var xxx_messageInfo_LogFileSubcompactions proto.InternalMessageInfo

func (m *LogFileSubcompactions) GetSubcompactions() []*LogFileSubcompaction {
	if m != nil {
		return m.Subcompactions
	}
	return nil
}

type LogFileCompaction struct {
	CompactionFromTs  uint64 `protobuf:"varint,1,opt,name=compaction_from_ts,json=compactionFromTs,proto3" json:"compaction_from_ts,omitempty"`
	CompactionUntilTs uint64 `protobuf:"varint,2,opt,name=compaction_until_ts,json=compactionUntilTs,proto3" json:"compaction_until_ts,omitempty"`
	// The user provided name for the compaction.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The statistics or other useful information for human.
	Comments string `protobuf:"bytes,4,opt,name=comments,proto3" json:"comments,omitempty"`
	// relative path to the generated subcompaction metas. ("artificates")
	Artifacts string `protobuf:"bytes,5,opt,name=artifacts,proto3" json:"artifacts,omitempty"`
	// the XOR of all artificate's hash.
	ArtifactsHash uint64 `protobuf:"varint,6,opt,name=artifacts_hash,json=artifactsHash,proto3" json:"artifacts_hash,omitempty"`
	// relative path to the subcompaction generated SST files.
	// this is a hint for garbage-collecting, so we don't need to read the metas one by one.
	// Those SSTs cannot be directly used, what you need is probably in `artificates`.
	GeneratedFiles string `protobuf:"bytes,7,opt,name=generated_files,json=generatedFiles,proto3" json:"generated_files,omitempty"`
}

func (m *LogFileCompaction) Reset()         { *m = LogFileCompaction{} }
func (m *LogFileCompaction) String() string { return proto.CompactTextString(m) }
func (*LogFileCompaction) ProtoMessage()    {}
func (*LogFileCompaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{53}
}
func (m *LogFileCompaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFileCompaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogFileCompaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogFileCompaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFileCompaction.Merge(m, src)
}
func (m *LogFileCompaction) XXX_Size() int {
	return m.Size()
}
func (m *LogFileCompaction) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFileCompaction.DiscardUnknown(m)
}

var xxx_messageInfo_LogFileCompaction proto.InternalMessageInfo

func (m *LogFileCompaction) GetCompactionFromTs() uint64 {
	if m != nil {
		return m.CompactionFromTs
	}
	return 0
}

func (m *LogFileCompaction) GetCompactionUntilTs() uint64 {
	if m != nil {
		return m.CompactionUntilTs
	}
	return 0
}

func (m *LogFileCompaction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LogFileCompaction) GetComments() string {
	if m != nil {
		return m.Comments
	}
	return ""
}

func (m *LogFileCompaction) GetArtifacts() string {
	if m != nil {
		return m.Artifacts
	}
	return ""
}

func (m *LogFileCompaction) GetArtifactsHash() uint64 {
	if m != nil {
		return m.ArtifactsHash
	}
	return 0
}

func (m *LogFileCompaction) GetGeneratedFiles() string {
	if m != nil {
		return m.GeneratedFiles
	}
	return ""
}

type MetaEdit struct {
	// Path to the meta file.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Delete the physical files (MetaFileGroup) in the meta file.
	DeletePhysicalFiles []string `protobuf:"bytes,2,rep,name=delete_physical_files,json=deletePhysicalFiles,proto3" json:"delete_physical_files,omitempty"`
	// Delete the logical files (MetaFileInfo) in the meta file.
	// Note: Even the operation have been performed in the meta,
	// this modification should be kept as long as the corresponding physical
	// file not deleted. Or we may cannot know when to delete the physical file.
	// Then the file will be leak until truncated.
	DeleteLogicalFiles []*DeleteSpansOfFile `protobuf:"bytes,3,rep,name=delete_logical_files,json=deleteLogicalFiles,proto3" json:"delete_logical_files,omitempty"`
	// Whether to delete the metadata itself.
	DestructSelf bool `protobuf:"varint,4,opt,name=destruct_self,json=destructSelf,proto3" json:"destruct_self,omitempty"`
}

func (m *MetaEdit) Reset()         { *m = MetaEdit{} }
func (m *MetaEdit) String() string { return proto.CompactTextString(m) }
func (*MetaEdit) ProtoMessage()    {}
func (*MetaEdit) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{54}
}
func (m *MetaEdit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaEdit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaEdit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaEdit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaEdit.Merge(m, src)
}
func (m *MetaEdit) XXX_Size() int {
	return m.Size()
}
func (m *MetaEdit) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaEdit.DiscardUnknown(m)
}

var xxx_messageInfo_MetaEdit proto.InternalMessageInfo

func (m *MetaEdit) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *MetaEdit) GetDeletePhysicalFiles() []string {
	if m != nil {
		return m.DeletePhysicalFiles
	}
	return nil
}

func (m *MetaEdit) GetDeleteLogicalFiles() []*DeleteSpansOfFile {
	if m != nil {
		return m.DeleteLogicalFiles
	}
	return nil
}

func (m *MetaEdit) GetDestructSelf() bool {
	if m != nil {
		return m.DestructSelf
	}
	return false
}

// An extended version of `SpansOfFile`, added more metadata for the
// execution of delayed deletion.
type DeleteSpansOfFile struct {
	Path  string  `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Spans []*Span `protobuf:"bytes,2,rep,name=spans,proto3" json:"spans,omitempty"`
	// This is a hint for garbage collecting.
	// So we can easily check whether a set of spans consists the whole file.
	WholeFileLength uint64 `protobuf:"varint,3,opt,name=whole_file_length,json=wholeFileLength,proto3" json:"whole_file_length,omitempty"`
}

func (m *DeleteSpansOfFile) Reset()         { *m = DeleteSpansOfFile{} }
func (m *DeleteSpansOfFile) String() string { return proto.CompactTextString(m) }
func (*DeleteSpansOfFile) ProtoMessage()    {}
func (*DeleteSpansOfFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{55}
}
func (m *DeleteSpansOfFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteSpansOfFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteSpansOfFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteSpansOfFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSpansOfFile.Merge(m, src)
}
func (m *DeleteSpansOfFile) XXX_Size() int {
	return m.Size()
}
func (m *DeleteSpansOfFile) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSpansOfFile.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSpansOfFile proto.InternalMessageInfo

func (m *DeleteSpansOfFile) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *DeleteSpansOfFile) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *DeleteSpansOfFile) GetWholeFileLength() uint64 {
	if m != nil {
		return m.WholeFileLength
	}
	return 0
}

type Migration struct {
	Creator     string               `protobuf:"bytes,5,opt,name=creator,proto3" json:"creator,omitempty"`
	Version     MigrationVersion     `protobuf:"varint,6,opt,name=version,proto3,enum=backup.MigrationVersion" json:"version,omitempty"`
	EditMeta    []*MetaEdit          `protobuf:"bytes,1,rep,name=edit_meta,json=editMeta,proto3" json:"edit_meta,omitempty"`
	TruncatedTo uint64               `protobuf:"varint,2,opt,name=truncated_to,json=truncatedTo,proto3" json:"truncated_to,omitempty"`
	Compactions []*LogFileCompaction `protobuf:"bytes,3,rep,name=compactions,proto3" json:"compactions,omitempty"`
	// Delete all files matches this prefix.
	DestructPrefix []string `protobuf:"bytes,4,rep,name=destruct_prefix,json=destructPrefix,proto3" json:"destruct_prefix,omitempty"`
}

func (m *Migration) Reset()         { *m = Migration{} }
func (m *Migration) String() string { return proto.CompactTextString(m) }
func (*Migration) ProtoMessage()    {}
func (*Migration) Descriptor() ([]byte, []int) {
	return fileDescriptor_483d1f48d58a4885, []int{56}
}
func (m *Migration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Migration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Migration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Migration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Migration.Merge(m, src)
}
func (m *Migration) XXX_Size() int {
	return m.Size()
}
func (m *Migration) XXX_DiscardUnknown() {
	xxx_messageInfo_Migration.DiscardUnknown(m)
}

var xxx_messageInfo_Migration proto.InternalMessageInfo

func (m *Migration) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *Migration) GetVersion() MigrationVersion {
	if m != nil {
		return m.Version
	}
	return MigrationVersion_M0
}

func (m *Migration) GetEditMeta() []*MetaEdit {
	if m != nil {
		return m.EditMeta
	}
	return nil
}

func (m *Migration) GetTruncatedTo() uint64 {
	if m != nil {
		return m.TruncatedTo
	}
	return 0
}

func (m *Migration) GetCompactions() []*LogFileCompaction {
	if m != nil {
		return m.Compactions
	}
	return nil
}

func (m *Migration) GetDestructPrefix() []string {
	if m != nil {
		return m.DestructPrefix
	}
	return nil
}

func init() {
	proto.RegisterEnum("backup.PrepareSnapshotBackupRequestType", PrepareSnapshotBackupRequestType_name, PrepareSnapshotBackupRequestType_value)
	proto.RegisterEnum("backup.PrepareSnapshotBackupEventType", PrepareSnapshotBackupEventType_name, PrepareSnapshotBackupEventType_value)
	proto.RegisterEnum("backup.CompressionType", CompressionType_name, CompressionType_value)
	proto.RegisterEnum("backup.BackupMode", BackupMode_name, BackupMode_value)
	proto.RegisterEnum("backup.MetaVersion", MetaVersion_name, MetaVersion_value)
	proto.RegisterEnum("backup.FileType", FileType_name, FileType_value)
	proto.RegisterEnum("backup.MigrationVersion", MigrationVersion_name, MigrationVersion_value)
	proto.RegisterType((*PrepareSnapshotBackupRequest)(nil), "backup.PrepareSnapshotBackupRequest")
	proto.RegisterType((*PrepareSnapshotBackupResponse)(nil), "backup.PrepareSnapshotBackupResponse")
	proto.RegisterType((*BackupMeta)(nil), "backup.BackupMeta")
	proto.RegisterType((*BackupRange)(nil), "backup.BackupRange")
	proto.RegisterType((*File)(nil), "backup.File")
	proto.RegisterType((*MetaFile)(nil), "backup.MetaFile")
	proto.RegisterType((*PlacementPolicy)(nil), "backup.PlacementPolicy")
	proto.RegisterType((*StatsBlock)(nil), "backup.StatsBlock")
	proto.RegisterType((*StatsFile)(nil), "backup.StatsFile")
	proto.RegisterType((*StatsFileIndex)(nil), "backup.StatsFileIndex")
	proto.RegisterType((*Schema)(nil), "backup.Schema")
	proto.RegisterType((*IDMap)(nil), "backup.IDMap")
	proto.RegisterType((*PitrTableMap)(nil), "backup.PitrTableMap")
	proto.RegisterType((*PitrDBMap)(nil), "backup.PitrDBMap")
	proto.RegisterType((*RawRange)(nil), "backup.RawRange")
	proto.RegisterType((*ClusterIDError)(nil), "backup.ClusterIDError")
	proto.RegisterType((*Error)(nil), "backup.Error")
	proto.RegisterType((*StreamBackupTaskSecurityConfig)(nil), "backup.StreamBackupTaskSecurityConfig")
	proto.RegisterType((*CipherInfo)(nil), "backup.CipherInfo")
	proto.RegisterType((*MasterKeyConfig)(nil), "backup.MasterKeyConfig")
	proto.RegisterType((*BackupRequest)(nil), "backup.BackupRequest")
	proto.RegisterType((*StreamBackupTaskInfo)(nil), "backup.StreamBackupTaskInfo")
	proto.RegisterType((*StorageBackend)(nil), "backup.StorageBackend")
	proto.RegisterType((*Noop)(nil), "backup.Noop")
	proto.RegisterType((*Local)(nil), "backup.Local")
	proto.RegisterType((*S3)(nil), "backup.S3")
	proto.RegisterType((*GCS)(nil), "backup.GCS")
	proto.RegisterType((*AzureCustomerKey)(nil), "backup.AzureCustomerKey")
	proto.RegisterType((*AzureBlobStorage)(nil), "backup.AzureBlobStorage")
	proto.RegisterType((*Bucket)(nil), "backup.Bucket")
	proto.RegisterType((*CloudDynamic)(nil), "backup.CloudDynamic")
	proto.RegisterMapType((map[string]string)(nil), "backup.CloudDynamic.AttrsEntry")
	proto.RegisterType((*HDFS)(nil), "backup.HDFS")
	proto.RegisterType((*BackupResponse)(nil), "backup.BackupResponse")
	proto.RegisterType((*CleanupRequest)(nil), "backup.CleanupRequest")
	proto.RegisterType((*CleanupResponse)(nil), "backup.CleanupResponse")
	proto.RegisterType((*PrepareRequest)(nil), "backup.PrepareRequest")
	proto.RegisterType((*PrepareResponse)(nil), "backup.PrepareResponse")
	proto.RegisterType((*CheckAdminRequest)(nil), "backup.CheckAdminRequest")
	proto.RegisterType((*CheckAdminResponse)(nil), "backup.CheckAdminResponse")
	proto.RegisterType((*ExternalStorageRestoreRequest)(nil), "backup.ExternalStorageRestoreRequest")
	proto.RegisterType((*ExternalStorageRestoreResponse)(nil), "backup.ExternalStorageRestoreResponse")
	proto.RegisterType((*ExternalStorageSaveRequest)(nil), "backup.ExternalStorageSaveRequest")
	proto.RegisterType((*ExternalStorageSaveResponse)(nil), "backup.ExternalStorageSaveResponse")
	proto.RegisterType((*Metadata)(nil), "backup.Metadata")
	proto.RegisterType((*DataFileGroup)(nil), "backup.DataFileGroup")
	proto.RegisterType((*DataFileInfo)(nil), "backup.DataFileInfo")
	proto.RegisterType((*StreamBackupError)(nil), "backup.StreamBackupError")
	proto.RegisterType((*Span)(nil), "backup.Span")
	proto.RegisterType((*SpansOfFile)(nil), "backup.SpansOfFile")
	proto.RegisterType((*LogFileSubcompactionMeta)(nil), "backup.LogFileSubcompactionMeta")
	proto.RegisterType((*LogFileSubcompaction)(nil), "backup.LogFileSubcompaction")
	proto.RegisterType((*RegionMetaHint)(nil), "backup.RegionMetaHint")
	proto.RegisterType((*LogFileSubcompactions)(nil), "backup.LogFileSubcompactions")
	proto.RegisterType((*LogFileCompaction)(nil), "backup.LogFileCompaction")
	proto.RegisterType((*MetaEdit)(nil), "backup.MetaEdit")
	proto.RegisterType((*DeleteSpansOfFile)(nil), "backup.DeleteSpansOfFile")
	proto.RegisterType((*Migration)(nil), "backup.Migration")
}

func init() { proto.RegisterFile("brpb.proto", fileDescriptor_483d1f48d58a4885) }

var fileDescriptor_483d1f48d58a4885 = []byte{
	// 4581 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x3b, 0x4d, 0x6f, 0x1c, 0x47,
	0x76, 0xec, 0xf9, 0x9e, 0x37, 0x9f, 0x2c, 0x52, 0xd2, 0x98, 0xb6, 0x28, 0xba, 0x65, 0x6b, 0x19,
	0x7a, 0xc5, 0xb5, 0x25, 0xaf, 0x56, 0x89, 0x37, 0x30, 0xf8, 0x25, 0x93, 0x96, 0x28, 0x31, 0x4d,
	0xda, 0x8b, 0x18, 0x08, 0x1a, 0x3d, 0xdd, 0x35, 0x9c, 0x5e, 0xf6, 0x74, 0xf7, 0x76, 0xd5, 0x8c,
	0x44, 0x1f, 0x72, 0xc8, 0xdd, 0xf0, 0x6e, 0x90, 0x43, 0xfe, 0x40, 0x80, 0x1c, 0x12, 0x20, 0xd7,
	0x9c, 0x92, 0x43, 0x82, 0x6c, 0x90, 0x00, 0xf1, 0x21, 0x87, 0x3d, 0x06, 0x36, 0x92, 0x7f, 0x11,
	0x20, 0xa8, 0x57, 0x55, 0x3d, 0xdd, 0xc3, 0x21, 0x25, 0x39, 0x8b, 0x3d, 0x71, 0xea, 0xbd, 0x57,
	0x55, 0xaf, 0xde, 0x57, 0xbd, 0xf7, 0xaa, 0x09, 0xd0, 0x4f, 0xe2, 0xfe, 0x66, 0x9c, 0x44, 0x3c,
	0x22, 0x95, 0xbe, 0xe3, 0x9e, 0x8d, 0xe3, 0x95, 0xd6, 0xd9, 0x24, 0x89, 0x5d, 0x0d, 0x5e, 0x69,
	0xd1, 0x24, 0x89, 0x52, 0xaa, 0x95, 0xe6, 0x88, 0x72, 0x27, 0x1d, 0x11, 0x1a, 0xba, 0xc9, 0x79,
	0xcc, 0xfd, 0x28, 0x4c, 0x61, 0xcb, 0xa7, 0xd1, 0x69, 0x84, 0x3f, 0x7f, 0x24, 0x7e, 0x29, 0x68,
	0x27, 0x19, 0x33, 0x8e, 0x3f, 0x25, 0xc0, 0xfc, 0x1b, 0x03, 0xde, 0x3a, 0x4a, 0x68, 0xec, 0x24,
	0xf4, 0x38, 0x74, 0x62, 0x36, 0x8c, 0xf8, 0x36, 0x32, 0x60, 0xd1, 0x5f, 0x8c, 0x29, 0xe3, 0xe4,
	0x21, 0x14, 0xf8, 0x79, 0xcf, 0x58, 0x33, 0xd6, 0xdb, 0xf7, 0xd6, 0x37, 0x25, 0x73, 0x9b, 0x57,
	0xcd, 0x38, 0x39, 0x8f, 0xa9, 0x55, 0xe0, 0xe7, 0x64, 0x1d, 0xaa, 0x09, 0x3d, 0xf5, 0xa3, 0x90,
	0xf5, 0x0a, 0x6b, 0xc5, 0xf5, 0xc6, 0xbd, 0xf6, 0xa6, 0xe2, 0xda, 0x42, 0xb0, 0xa5, 0xd1, 0x64,
	0x1d, 0xba, 0x01, 0x75, 0x18, 0xb5, 0xfd, 0xd0, 0x66, 0xd4, 0x8d, 0x42, 0x8f, 0xf5, 0x8a, 0x6b,
	0xc6, 0x7a, 0xc9, 0x6a, 0x23, 0xfc, 0x20, 0x3c, 0x96, 0x50, 0xf3, 0x3f, 0x0d, 0xb8, 0x79, 0xc9,
	0xe6, 0x2c, 0x8e, 0x42, 0x46, 0xc9, 0x83, 0x0c, 0xbf, 0x77, 0xae, 0xe4, 0x77, 0x6f, 0x42, 0xc3,
	0x29, 0xb7, 0x77, 0xa0, 0x22, 0xd9, 0xe9, 0x15, 0xd6, 0x8c, 0x39, 0xcc, 0x2a, 0x2c, 0x79, 0x07,
	0xca, 0xa8, 0x0a, 0x64, 0x50, 0x90, 0x69, 0xc5, 0xec, 0x89, 0xbf, 0x96, 0x44, 0x92, 0xbb, 0xb0,
	0x14, 0x38, 0x8c, 0xdb, 0xea, 0x58, 0xcc, 0x9e, 0x38, 0x81, 0xef, 0xf5, 0x4a, 0x6b, 0xc6, 0x7a,
	0xcd, 0xea, 0x0a, 0xd4, 0x13, 0x3c, 0x18, 0xfb, 0x5c, 0xc0, 0xcd, 0xff, 0xae, 0x02, 0x48, 0xa6,
	0x0e, 0x29, 0x77, 0xc8, 0x4d, 0x00, 0x37, 0x18, 0x33, 0x4e, 0x13, 0xdb, 0xf7, 0xf0, 0x2c, 0x25,
	0xab, 0xae, 0x20, 0x07, 0x1e, 0xf9, 0x01, 0x74, 0x34, 0x7a, 0x42, 0x13, 0xa6, 0x79, 0xae, 0x5b,
	0x6d, 0x05, 0xfe, 0x5c, 0x42, 0xc5, 0x3a, 0xfd, 0x29, 0x4d, 0x03, 0x69, 0xea, 0xfd, 0x14, 0xdd,
	0x83, 0xaa, 0xc6, 0x35, 0xd7, 0x8c, 0xf5, 0xb2, 0xa5, 0x87, 0xc4, 0x84, 0xf2, 0xc0, 0x0f, 0x28,
	0xeb, 0x95, 0x50, 0x71, 0x4d, 0x2d, 0xc7, 0x47, 0x7e, 0x40, 0x2d, 0x89, 0x22, 0x3f, 0x02, 0x10,
	0x3f, 0x6c, 0x3f, 0xf4, 0xe8, 0x8b, 0x5e, 0x0b, 0xa5, 0xd1, 0xd5, 0x84, 0xe2, 0x18, 0x48, 0x5c,
	0x17, 0x34, 0x07, 0x82, 0x84, 0xdc, 0x86, 0x16, 0xe3, 0x4e, 0xc2, 0x53, 0x86, 0xca, 0x78, 0xb0,
	0x26, 0x02, 0x35, 0x4f, 0xb7, 0xa0, 0x41, 0x43, 0x2f, 0x25, 0xa9, 0x20, 0x09, 0xd0, 0xd0, 0xd3,
	0x04, 0xeb, 0x50, 0x65, 0xee, 0x90, 0x8e, 0x1c, 0xd6, 0xab, 0x2a, 0xab, 0x52, 0x7b, 0x1e, 0x23,
	0xd8, 0xd2, 0x68, 0x72, 0x1f, 0x9a, 0xf2, 0xa7, 0x62, 0xb1, 0x7d, 0x09, 0x8b, 0x0d, 0x49, 0x25,
	0x99, 0x5c, 0x81, 0xba, 0xcf, 0xec, 0xc4, 0x79, 0x6e, 0x9f, 0x4d, 0x7a, 0x35, 0x54, 0x57, 0xd5,
	0x67, 0x96, 0xf3, 0xfc, 0xf1, 0x44, 0x9c, 0x58, 0x20, 0x12, 0x27, 0x3c, 0xa5, 0xac, 0x57, 0xc7,
	0xdd, 0xd3, 0xe5, 0x2c, 0xe7, 0xb9, 0x25, 0x10, 0x56, 0x3d, 0x51, 0xbf, 0x18, 0x79, 0x08, 0x9d,
	0x74, 0x82, 0x62, 0xa2, 0x73, 0x09, 0x13, 0x2d, 0x3d, 0x4b, 0xb2, 0x41, 0xa0, 0xe4, 0x79, 0x01,
	0xeb, 0xc1, 0x9a, 0xb1, 0xde, 0xb4, 0xf0, 0x37, 0xf9, 0x00, 0x1a, 0x9e, 0x17, 0xc8, 0x75, 0x28,
	0xeb, 0x75, 0x2f, 0x59, 0x09, 0x3c, 0x2f, 0x38, 0x90, 0x34, 0x42, 0xe4, 0x12, 0x6d, 0x27, 0x94,
	0x8d, 0x03, 0xde, 0x5b, 0x44, 0x1b, 0x68, 0xf6, 0xb5, 0xcf, 0x8c, 0x03, 0x4e, 0x3e, 0x84, 0x86,
	0x13, 0xfb, 0xa9, 0xc8, 0x09, 0xba, 0xce, 0xd2, 0xa6, 0x8e, 0x3f, 0x5b, 0x47, 0x07, 0x4a, 0xf6,
	0x16, 0x38, 0xb1, 0xaf, 0xf5, 0x70, 0x1f, 0x6a, 0x71, 0x14, 0xf8, 0xae, 0x4f, 0x59, 0x6f, 0x09,
	0x45, 0x71, 0x23, 0xf5, 0xb6, 0xc0, 0x71, 0xe9, 0x88, 0x86, 0xfc, 0x48, 0x10, 0x9c, 0x5b, 0x29,
	0x21, 0xf9, 0x10, 0xae, 0x87, 0xf4, 0xb9, 0xed, 0x46, 0x41, 0xe0, 0x88, 0x68, 0xc5, 0x6c, 0x1a,
	0x3a, 0xfd, 0x80, 0x7a, 0xbd, 0x65, 0x64, 0x6c, 0x39, 0xa4, 0xcf, 0x77, 0x52, 0xe4, 0x9e, 0xc4,
	0x29, 0x9d, 0xf0, 0x17, 0xa1, 0xd0, 0xc9, 0x35, 0xad, 0x93, 0x93, 0x17, 0xe1, 0xe3, 0x09, 0xd9,
	0x80, 0xaa, 0xd7, 0xb7, 0x47, 0x4e, 0xcc, 0x7a, 0xd7, 0x91, 0x8b, 0xc5, 0x94, 0x0b, 0x9f, 0x27,
	0xbb, 0xdb, 0x87, 0x4e, 0x6c, 0x55, 0xbc, 0xfe, 0xa1, 0x13, 0x33, 0x72, 0x07, 0x4a, 0xa3, 0xc8,
	0xa3, 0xbd, 0x1b, 0x78, 0x42, 0xa2, 0x09, 0x95, 0xe3, 0x45, 0x1e, 0xb5, 0x10, 0x4f, 0xde, 0x83,
	0x8a, 0xd2, 0x71, 0x0f, 0x97, 0x5c, 0xca, 0x53, 0x4a, 0x35, 0x2b, 0x12, 0x61, 0xb0, 0x4a, 0xc4,
	0xcc, 0xff, 0x92, 0xf6, 0xde, 0x90, 0x06, 0x2b, 0x41, 0xc7, 0xfe, 0x97, 0xf4, 0xd3, 0x52, 0xad,
	0xd8, 0x2d, 0x59, 0xa5, 0xd8, 0xe1, 0x43, 0xf3, 0x14, 0x1a, 0x99, 0x35, 0xc8, 0x9b, 0x50, 0x97,
	0x1e, 0x71, 0x46, 0x65, 0xc8, 0x6a, 0x5a, 0x35, 0x04, 0x3c, 0xa6, 0xe7, 0xe4, 0x06, 0x54, 0x85,
	0x27, 0x08, 0x54, 0x01, 0x51, 0x15, 0x1a, 0x7a, 0x02, 0x91, 0x3a, 0x67, 0xf1, 0x52, 0xe7, 0x34,
	0xff, 0xb5, 0x00, 0x25, 0x31, 0x16, 0x86, 0x14, 0x3a, 0x23, 0x8a, 0xab, 0xd7, 0x2d, 0xfc, 0x4d,
	0xae, 0x43, 0x85, 0x0d, 0x9d, 0x7b, 0x3f, 0x7e, 0xa0, 0x17, 0x96, 0xa3, 0x3c, 0x3b, 0xc5, 0xcb,
	0xd9, 0x29, 0xe5, 0xd8, 0xf9, 0xed, 0xb8, 0xf5, 0x0a, 0xd4, 0xdc, 0xc4, 0x7d, 0xf0, 0xe1, 0x8b,
	0x28, 0xe9, 0x55, 0x11, 0x9b, 0x8e, 0x05, 0x5f, 0x3c, 0xe2, 0x4e, 0x60, 0x9f, 0x4d, 0x18, 0xfa,
	0x64, 0xc9, 0xaa, 0x21, 0xe0, 0xf1, 0x04, 0xe5, 0x2f, 0x91, 0xfd, 0x73, 0x8e, 0x5e, 0x89, 0x2b,
	0x23, 0x68, 0x5b, 0x40, 0x48, 0x1b, 0x0a, 0xee, 0x00, 0x1d, 0xa9, 0x6e, 0x15, 0xdc, 0x81, 0x90,
	0x08, 0x6a, 0xaa, 0x81, 0x94, 0xf8, 0x5b, 0xec, 0xe0, 0xfa, 0xf1, 0x50, 0xc4, 0xdb, 0x09, 0xc6,
	0xc2, 0xa6, 0x55, 0x93, 0x80, 0x83, 0x89, 0xf9, 0x55, 0x01, 0x6a, 0xda, 0xbb, 0xc8, 0x7b, 0x00,
	0xe2, 0x5e, 0xb0, 0xa5, 0x06, 0x8c, 0x39, 0x1a, 0xa8, 0x8f, 0x14, 0x2d, 0x13, 0xc4, 0x9e, 0x93,
	0x12, 0x17, 0xe6, 0x11, 0x0b, 0xbc, 0x24, 0xce, 0x04, 0xb6, 0xe2, 0xd5, 0x81, 0x2d, 0x1f, 0x87,
	0x4a, 0xaf, 0x12, 0x87, 0xd2, 0x30, 0x20, 0xe7, 0x54, 0x2e, 0xb7, 0x6b, 0x1d, 0x1b, 0xe4, 0x4c,
	0x1d, 0x87, 0xca, 0x6b, 0x45, 0x1d, 0x87, 0xcc, 0x77, 0xa1, 0x33, 0xe3, 0xe1, 0x82, 0xcc, 0x0f,
	0x07, 0x91, 0xb2, 0x61, 0xfc, 0x6d, 0x3e, 0x01, 0x38, 0xe6, 0x0e, 0x67, 0xdb, 0x41, 0xe4, 0x9e,
	0x09, 0x35, 0xc5, 0xc3, 0x73, 0xe6, 0xbb, 0x4e, 0xa0, 0xef, 0xb4, 0xa2, 0x05, 0x1a, 0x74, 0xe0,
	0x89, 0xbb, 0xea, 0xe7, 0x2c, 0x0a, 0x6d, 0x2e, 0x7c, 0x5e, 0x19, 0x66, 0x5d, 0x40, 0x4e, 0x04,
	0xc0, 0xfc, 0x09, 0xd4, 0x71, 0x35, 0x54, 0xc2, 0x06, 0x54, 0xfa, 0x62, 0x55, 0xad, 0x80, 0xd4,
	0x95, 0xa7, 0x1b, 0x5a, 0x8a, 0xc2, 0xfc, 0x3b, 0x03, 0xda, 0xe9, 0xcc, 0x34, 0xb8, 0xbe, 0xb2,
	0x4f, 0xbc, 0x01, 0x35, 0x61, 0x21, 0x36, 0x0d, 0x5d, 0x95, 0x92, 0x54, 0xc5, 0x78, 0x2f, 0x74,
	0x53, 0x54, 0x94, 0xf8, 0xe8, 0x12, 0x0a, 0xf5, 0x2c, 0xf1, 0xf3, 0xf6, 0x54, 0xce, 0xdb, 0x93,
	0x10, 0x85, 0x1f, 0x06, 0x7e, 0x48, 0x6d, 0xa1, 0x7c, 0xf4, 0x85, 0xa6, 0x05, 0x12, 0xb4, 0xeb,
	0x70, 0xc7, 0xfc, 0xb3, 0x02, 0x54, 0xa4, 0xce, 0x85, 0xf1, 0x7a, 0x7d, 0x25, 0xd6, 0x82, 0xd7,
	0x27, 0xcb, 0x50, 0xce, 0x0a, 0x48, 0x0e, 0x72, 0xce, 0x53, 0xbc, 0xca, 0x79, 0x4a, 0x57, 0x3b,
	0x4f, 0xf9, 0x82, 0xf3, 0xfc, 0x1e, 0x74, 0xb9, 0x3f, 0x08, 0x1c, 0x36, 0xb4, 0x13, 0x1a, 0x07,
	0xbe, 0xeb, 0x30, 0x64, 0xb8, 0x65, 0x75, 0x14, 0xdc, 0x52, 0x60, 0xc1, 0x1a, 0x13, 0x72, 0x46,
	0xf7, 0x6d, 0x5a, 0x72, 0x40, 0x7e, 0x02, 0x0d, 0xfc, 0xa1, 0xae, 0xbf, 0x1a, 0xea, 0xeb, 0x7a,
	0x4e, 0x5f, 0xa9, 0x62, 0x2c, 0x40, 0x52, 0xfc, 0x6d, 0x1e, 0x42, 0xf9, 0x60, 0xf7, 0xd0, 0x89,
	0x05, 0x8f, 0xe3, 0x98, 0xf1, 0x84, 0x3a, 0xa3, 0x8c, 0xe5, 0x68, 0xd0, 0x81, 0x27, 0x02, 0x90,
	0x17, 0x3d, 0x0f, 0xa7, 0x24, 0x05, 0x24, 0x69, 0x4e, 0x81, 0x07, 0x9e, 0xf9, 0x1c, 0x9a, 0xe2,
	0x42, 0x40, 0x63, 0x12, 0xab, 0xce, 0xb3, 0x81, 0x77, 0xa0, 0xe2, 0x7b, 0xe2, 0x2e, 0x51, 0x29,
	0x60, 0x4b, 0xb3, 0x89, 0x8c, 0x58, 0x65, 0xdf, 0x13, 0x33, 0xef, 0x02, 0xc4, 0x4e, 0xc2, 0x7d,
	0xbc, 0xa2, 0x94, 0xab, 0xce, 0x50, 0x66, 0x08, 0x4c, 0x06, 0xf5, 0xf4, 0x26, 0xfa, 0x7f, 0xec,
	0xfa, 0x43, 0xa8, 0xa0, 0xae, 0xf5, 0x8e, 0xcb, 0xd9, 0x6b, 0x4e, 0x9f, 0xca, 0x52, 0x34, 0xe6,
	0x11, 0xd4, 0x74, 0x1c, 0xf8, 0x9e, 0x97, 0x8c, 0x8c, 0x9a, 0x45, 0x1d, 0x35, 0xcd, 0x5d, 0x68,
	0xef, 0xa8, 0x04, 0x74, 0x17, 0x33, 0x5d, 0x91, 0x3d, 0xba, 0xe3, 0x24, 0xa1, 0x21, 0x57, 0x19,
	0xaa, 0x1e, 0x0a, 0x4c, 0x22, 0x6b, 0x01, 0x5c, 0xb4, 0x64, 0xe9, 0xa1, 0xf9, 0xef, 0x06, 0x94,
	0xe5, 0xec, 0x2e, 0x14, 0x47, 0xec, 0x54, 0x09, 0x42, 0xfc, 0x24, 0xdb, 0xd0, 0x9d, 0x26, 0xbd,
	0x76, 0x36, 0xc7, 0x4e, 0xcd, 0x25, 0xcf, 0xc1, 0xfe, 0x42, 0x9a, 0xf0, 0x1e, 0x78, 0x72, 0xd5,
	0x4d, 0xa8, 0x9d, 0x4d, 0xd4, 0xdc, 0x12, 0xce, 0x5d, 0x4c, 0xf3, 0x98, 0xc7, 0xf4, 0x5c, 0x4f,
	0xab, 0x9e, 0x4d, 0x24, 0xfd, 0x7d, 0x68, 0xca, 0xb4, 0x5e, 0xcd, 0x29, 0xcf, 0xcb, 0xe9, 0xf7,
	0x17, 0xac, 0x86, 0xa4, 0xc2, 0xe1, 0x76, 0x0d, 0x2a, 0x1e, 0xe5, 0x8e, 0x1f, 0x98, 0x7f, 0x6f,
	0xc0, 0xea, 0x31, 0x5a, 0x98, 0x8c, 0xa0, 0x27, 0x0e, 0x3b, 0x3b, 0xa6, 0xee, 0x38, 0xf1, 0xf9,
	0xf9, 0x4e, 0x14, 0x0e, 0x7c, 0x71, 0x2a, 0x12, 0x07, 0x8e, 0x1f, 0x72, 0xfa, 0x82, 0xa3, 0xbf,
	0xa7, 0x6a, 0xc8, 0x84, 0xad, 0x1d, 0x19, 0x1a, 0xc2, 0x41, 0xb4, 0xbf, 0x60, 0x75, 0x53, 0x7a,
	0x11, 0x0c, 0x84, 0x2e, 0xf6, 0x60, 0x71, 0xe4, 0xa0, 0x60, 0xce, 0xe8, 0xb9, 0xed, 0xe2, 0xc2,
	0xca, 0x58, 0xd2, 0x9c, 0xeb, 0x10, 0x09, 0x1e, 0x53, 0xb5, 0xef, 0xfe, 0x82, 0xd5, 0x19, 0xe5,
	0x41, 0xdb, 0x4d, 0x80, 0x69, 0x9d, 0x68, 0x06, 0x00, 0xd3, 0x6d, 0xc9, 0xc7, 0xd0, 0x50, 0x01,
	0x8b, 0x9f, 0xc7, 0x54, 0x95, 0x4f, 0xab, 0x9b, 0xb9, 0xba, 0x72, 0x2f, 0x1d, 0x1c, 0x52, 0x3e,
	0x8c, 0x3c, 0x0b, 0xe4, 0x14, 0x51, 0x42, 0x61, 0xc9, 0x22, 0x17, 0x98, 0xda, 0x92, 0x8a, 0x81,
	0x8f, 0xe9, 0xb9, 0xf9, 0x17, 0x06, 0x74, 0x66, 0x58, 0x24, 0x9f, 0x40, 0x67, 0xba, 0xfe, 0xeb,
	0xec, 0xdb, 0x9e, 0xa2, 0x71, 0xef, 0x87, 0xd0, 0x98, 0xca, 0x47, 0xdf, 0xb3, 0x37, 0xf2, 0x8b,
	0xa4, 0x9b, 0x5b, 0x90, 0xca, 0x85, 0x99, 0x5f, 0x55, 0xa0, 0x95, 0x2f, 0x77, 0x5f, 0x52, 0x7a,
	0xe5, 0x9c, 0xa9, 0x70, 0xb9, 0x33, 0x15, 0xaf, 0x4e, 0x91, 0x4a, 0x2f, 0x4f, 0x91, 0xca, 0x17,
	0x52, 0xa4, 0x9b, 0xe2, 0xda, 0xe7, 0xd4, 0x0e, 0xfc, 0x91, 0xcf, 0x55, 0x92, 0x54, 0x17, 0x90,
	0x27, 0x02, 0x40, 0xd6, 0xa0, 0xe1, 0x46, 0xa1, 0xf4, 0x41, 0xf7, 0x1c, 0xf3, 0xa4, 0x96, 0x95,
	0x05, 0x91, 0x8f, 0xa1, 0xc3, 0x78, 0x94, 0x38, 0xa7, 0xd4, 0x16, 0x56, 0x43, 0x43, 0x0f, 0xd3,
	0xa5, 0x5c, 0x3c, 0x46, 0xf4, 0xb6, 0xc4, 0x5a, 0x6d, 0x96, 0x1b, 0xe7, 0x8b, 0x23, 0xc8, 0x17,
	0x47, 0x32, 0x60, 0x34, 0xd2, 0x34, 0x4b, 0xb8, 0x73, 0x34, 0x8a, 0x13, 0xca, 0x58, 0xaa, 0xde,
	0x26, 0xaa, 0x37, 0xb5, 0xd9, 0x9d, 0x29, 0x1e, 0xcb, 0xf0, 0x8e, 0x9b, 0x07, 0x90, 0xf7, 0x60,
	0x31, 0xbb, 0x46, 0x40, 0x27, 0x34, 0xc0, 0x4a, 0xb3, 0x6c, 0x65, 0x17, 0x7f, 0x22, 0xe0, 0xe4,
	0x7e, 0x6a, 0xc2, 0x98, 0x8a, 0xb4, 0x2f, 0x73, 0x31, 0x6d, 0xb6, 0x68, 0xf7, 0x1f, 0x41, 0xc7,
	0x63, 0xdc, 0xce, 0xd6, 0x3f, 0x9d, 0xcb, 0xeb, 0x9f, 0x96, 0xc7, 0xf8, 0xd6, 0xb4, 0x04, 0x7a,
	0x1f, 0x80, 0x8d, 0xfb, 0x3a, 0xa7, 0xea, 0xaa, 0xf2, 0x23, 0x13, 0x6f, 0x54, 0x22, 0xc6, 0xc6,
	0x7d, 0x95, 0x4e, 0xbd, 0x2d, 0xe2, 0x0d, 0xde, 0x97, 0x76, 0x42, 0x1d, 0x0f, 0xcb, 0xb1, 0x9a,
	0x88, 0x2e, 0x08, 0xb3, 0xa8, 0xe3, 0xa5, 0x45, 0x0a, 0x79, 0x49, 0x91, 0xf2, 0x26, 0xd4, 0xc7,
	0xa1, 0xff, 0x8b, 0x31, 0x15, 0x76, 0xba, 0x84, 0x62, 0xaf, 0x49, 0xc0, 0x81, 0x27, 0xaa, 0x22,
	0x37, 0xc2, 0x18, 0x82, 0x85, 0x95, 0x48, 0x0f, 0x35, 0x5b, 0x3b, 0x12, 0x6e, 0x69, 0x82, 0x4f,
	0x4b, 0xb5, 0x4a, 0xb7, 0xaa, 0xea, 0x93, 0xff, 0x29, 0xc0, 0xf2, 0x6c, 0x40, 0x43, 0x39, 0xbd,
	0x0f, 0x55, 0x65, 0x0b, 0x2a, 0x76, 0x5d, 0x66, 0x32, 0x9a, 0x0c, 0xb3, 0x23, 0xb4, 0x79, 0xce,
	0xf4, 0x2d, 0x80, 0xe3, 0x13, 0x46, 0xae, 0x81, 0x70, 0x0c, 0x81, 0x90, 0xc9, 0x4a, 0x99, 0x86,
	0xde, 0x09, 0x4b, 0x2f, 0xc7, 0x52, 0xe6, 0x72, 0x7c, 0x1b, 0x9a, 0x78, 0xa5, 0x89, 0x14, 0x9a,
	0xd3, 0x04, 0xf3, 0xd0, 0xba, 0xd5, 0x40, 0xd8, 0x23, 0x04, 0xcd, 0x35, 0xb4, 0xca, 0x6b, 0x1a,
	0xda, 0x33, 0xe8, 0x30, 0x15, 0xb7, 0x75, 0x7c, 0xad, 0xe2, 0x31, 0xef, 0x4c, 0x8f, 0x79, 0x55,
	0x98, 0xb7, 0xda, 0x6c, 0x66, 0x8c, 0xdd, 0x9f, 0x71, 0xec, 0x09, 0x87, 0xe5, 0x4c, 0x57, 0x8b,
	0x56, 0x45, 0x64, 0x38, 0x63, 0x66, 0x7e, 0x53, 0x10, 0x59, 0x69, 0xce, 0xb9, 0x4c, 0x28, 0x85,
	0x51, 0x14, 0x2b, 0xf9, 0xa6, 0x65, 0xc2, 0xd3, 0x28, 0x8a, 0xf7, 0x17, 0x2c, 0xc4, 0x91, 0x77,
	0xa1, 0x1c, 0x44, 0xae, 0x13, 0xcc, 0xa6, 0x0a, 0x4f, 0x04, 0x70, 0x7f, 0xc1, 0x92, 0x58, 0xf2,
	0x16, 0x14, 0xd8, 0x7d, 0x75, 0x79, 0x42, 0x7a, 0x82, 0xfb, 0xfb, 0x0b, 0x56, 0x81, 0xdd, 0x27,
	0xb7, 0xa0, 0x78, 0xea, 0x32, 0x75, 0x3f, 0x36, 0x34, 0xfa, 0x93, 0x9d, 0xe3, 0xfd, 0x05, 0x4b,
	0x60, 0xc8, 0x47, 0xd0, 0x72, 0x83, 0x68, 0xec, 0xd9, 0xde, 0x79, 0xe8, 0x8c, 0x7c, 0x57, 0x5d,
	0x8b, 0xcb, 0xd3, 0x6b, 0x38, 0x1a, 0x7b, 0xbb, 0x12, 0xb7, 0xbf, 0x60, 0x35, 0xdd, 0xcc, 0x58,
	0x1c, 0x63, 0xe8, 0x0d, 0x64, 0x96, 0x98, 0x39, 0xc6, 0xfe, 0xee, 0x23, 0xb1, 0x3e, 0xe2, 0xc8,
	0x3e, 0x10, 0xe7, 0xcb, 0x71, 0x42, 0xed, 0x7e, 0x10, 0xf5, 0x6d, 0x6d, 0x58, 0x52, 0xe2, 0x3d,
	0x3d, 0x63, 0x4b, 0x50, 0x6c, 0x07, 0x51, 0x5f, 0xc9, 0x49, 0x5c, 0x8d, 0xce, 0x0c, 0x6c, 0xbb,
	0x0e, 0x55, 0x15, 0xca, 0xcc, 0x0a, 0x94, 0x84, 0xac, 0xcc, 0x37, 0xa1, 0x8c, 0xe2, 0x10, 0xf6,
	0x24, 0x8c, 0x5a, 0x27, 0x5b, 0x68, 0xe0, 0x7f, 0x5e, 0x82, 0xc2, 0xf1, 0x7d, 0x91, 0x30, 0xd3,
	0xd0, 0x8b, 0x23, 0x5f, 0x25, 0x2f, 0x75, 0x2b, 0x1d, 0x8b, 0x4a, 0x20, 0xd3, 0x08, 0xac, 0xa7,
	0x8d, 0xbf, 0xeb, 0x50, 0xe9, 0x8f, 0xdd, 0x33, 0xca, 0x55, 0x56, 0xa4, 0x46, 0x02, 0x1e, 0x27,
	0x74, 0xe0, 0xbf, 0x50, 0x86, 0xab, 0x46, 0x32, 0xe8, 0xcb, 0x68, 0xeb, 0x06, 0x0e, 0x93, 0xd9,
	0x75, 0x5d, 0x04, 0x7d, 0x04, 0xee, 0x08, 0x98, 0x48, 0x83, 0x18, 0x93, 0xf6, 0x5a, 0xb7, 0xc4,
	0x4f, 0x01, 0x71, 0xdc, 0x00, 0x85, 0x51, 0xb7, 0xc4, 0x4f, 0x11, 0xf7, 0x1d, 0xd7, 0xa5, 0x8c,
	0xe1, 0xcd, 0x52, 0x93, 0x5d, 0x3c, 0x09, 0x11, 0x97, 0xcb, 0x06, 0x2c, 0x32, 0xea, 0x26, 0x94,
	0xdb, 0x19, 0xaa, 0x3a, 0x52, 0x75, 0x24, 0x62, 0x2b, 0xa5, 0x5d, 0x87, 0xee, 0x20, 0x4a, 0x5c,
	0x6a, 0x0b, 0x61, 0xd8, 0x8c, 0x9f, 0x07, 0x54, 0xc5, 0xf1, 0x36, 0xc2, 0x8f, 0x1c, 0x3e, 0x3c,
	0x16, 0x50, 0x72, 0x1b, 0xda, 0x8c, 0x51, 0xfb, 0x6c, 0x84, 0xeb, 0x89, 0x18, 0x23, 0x43, 0x7b,
	0x83, 0x31, 0xfa, 0x78, 0x24, 0x16, 0x3b, 0xf0, 0x84, 0x8f, 0x27, 0x51, 0x40, 0x6d, 0x27, 0x91,
	0x1d, 0xc4, 0xba, 0x55, 0x15, 0xe3, 0xad, 0x44, 0xde, 0x66, 0x2f, 0x38, 0x4d, 0x42, 0x59, 0xef,
	0xb5, 0x10, 0x0b, 0x1a, 0x74, 0xe0, 0x91, 0x4d, 0x58, 0x8a, 0xfa, 0x3f, 0xa7, 0x2e, 0xb7, 0x45,
	0x9d, 0x96, 0xf6, 0x81, 0xda, 0xc8, 0xcd, 0xa2, 0x44, 0x3d, 0x89, 0xdc, 0x33, 0xdd, 0x04, 0x12,
	0xe2, 0xd4, 0x2e, 0x1e, 0x9d, 0x51, 0x19, 0xa7, 0x85, 0x38, 0x95, 0x1b, 0x0b, 0x98, 0xd0, 0x6b,
	0x9c, 0x44, 0x13, 0xdf, 0xa3, 0x09, 0xf6, 0xc7, 0xea, 0x56, 0x3a, 0x16, 0x59, 0x69, 0x9c, 0x44,
	0xa2, 0x14, 0x57, 0x5d, 0x30, 0x3d, 0x34, 0x7f, 0x6d, 0x40, 0xf1, 0x93, 0x9d, 0xe3, 0x97, 0x59,
	0x85, 0xd2, 0x7e, 0xe1, 0x12, 0xed, 0x17, 0xaf, 0xd6, 0x7e, 0x69, 0x8e, 0xf6, 0xdf, 0x85, 0x76,
	0x9c, 0x50, 0x8f, 0x0e, 0xfc, 0x90, 0x7a, 0xb6, 0x50, 0xbb, 0xb4, 0x91, 0xd6, 0x14, 0xba, 0xe5,
	0x06, 0xa2, 0x08, 0x73, 0x05, 0x20, 0xe4, 0xbe, 0x13, 0x30, 0x74, 0x1a, 0x65, 0x31, 0x9d, 0x0c,
	0x5c, 0xb8, 0x85, 0x39, 0x82, 0x2e, 0xfa, 0xcd, 0xce, 0x98, 0xf1, 0x68, 0x84, 0x59, 0x8e, 0xd8,
	0x25, 0x93, 0x67, 0xe9, 0xf4, 0xb3, 0x6e, 0xb5, 0xa6, 0x50, 0x41, 0x76, 0x0f, 0xae, 0xe5, 0xc9,
	0xec, 0x4c, 0x41, 0x5c, 0xb7, 0x96, 0x72, 0xd4, 0xc7, 0x88, 0x12, 0x61, 0xac, 0x3b, 0xeb, 0xa7,
	0xbf, 0x7b, 0x31, 0xbe, 0x0d, 0x4d, 0xc7, 0x75, 0xa3, 0x71, 0xc8, 0x6d, 0xbc, 0x40, 0xa4, 0x10,
	0x1b, 0x0a, 0xf6, 0x54, 0xdc, 0x23, 0x37, 0x01, 0xd8, 0xd0, 0x49, 0xa8, 0xcc, 0xce, 0xa4, 0xf0,
	0xea, 0x12, 0x22, 0xce, 0x3e, 0x75, 0x31, 0xe6, 0x9f, 0xe6, 0x5d, 0xec, 0xd8, 0x3f, 0x15, 0x0a,
	0xc8, 0x88, 0x86, 0xb9, 0x51, 0x4c, 0xb5, 0x87, 0x4d, 0xe1, 0xc7, 0x02, 0x4c, 0x3e, 0xbe, 0x20,
	0x6c, 0x98, 0x13, 0xd6, 0x32, 0xea, 0x99, 0x51, 0x83, 0xf9, 0x2b, 0x03, 0x2a, 0xdb, 0x52, 0x28,
	0xaf, 0x16, 0xa5, 0x8a, 0x97, 0x44, 0xa9, 0xd2, 0x25, 0x02, 0x2e, 0x5f, 0x2d, 0xe0, 0xca, 0x45,
	0x01, 0x8b, 0xb2, 0xad, 0x99, 0x0d, 0xfa, 0xe4, 0x4e, 0xba, 0x8b, 0xa1, 0x2a, 0x26, 0x9d, 0xa6,
	0x20, 0x34, 0xdd, 0xf5, 0x36, 0xb4, 0xb4, 0xff, 0x49, 0xd5, 0x48, 0xad, 0x37, 0x35, 0x10, 0x75,
	0xf3, 0x63, 0x28, 0x3b, 0x9c, 0x27, 0xba, 0xb2, 0xbd, 0x35, 0xef, 0x9a, 0xd9, 0xdc, 0x12, 0x14,
	0x7b, 0x21, 0x4f, 0xce, 0x2d, 0x49, 0xbd, 0xf2, 0x10, 0x60, 0x0a, 0x14, 0x61, 0x73, 0x6a, 0xd9,
	0xe2, 0x27, 0x59, 0x86, 0xf2, 0xc4, 0x09, 0xc6, 0x7a, 0x4f, 0x39, 0xf8, 0x83, 0xc2, 0x43, 0xc3,
	0x5c, 0x85, 0x92, 0xb8, 0x8e, 0xa4, 0x0c, 0x47, 0x11, 0xd7, 0xf5, 0xb8, 0x1a, 0x99, 0xff, 0x6c,
	0x40, 0x7b, 0xe6, 0x55, 0xe9, 0xb6, 0x7e, 0xf5, 0x31, 0xf2, 0x17, 0x6f, 0xee, 0xd1, 0xe7, 0xfb,
	0x15, 0x07, 0xaf, 0xf2, 0xd6, 0x32, 0xd3, 0xa2, 0x2f, 0xbf, 0x52, 0x8b, 0xde, 0xbc, 0x2b, 0x6a,
	0x76, 0xea, 0x84, 0xd3, 0xea, 0x26, 0x97, 0x34, 0x1a, 0xf9, 0xa4, 0xd1, 0x3c, 0x82, 0x4e, 0x4a,
	0xfe, 0x3a, 0xc7, 0xee, 0x41, 0x95, 0x8d, 0xd1, 0x57, 0xf0, 0xd0, 0x35, 0x4b, 0x0f, 0xcd, 0x87,
	0xd0, 0x56, 0x2f, 0x6f, 0x9a, 0x81, 0x3b, 0xd0, 0x61, 0xce, 0x84, 0xda, 0x3c, 0xb2, 0xb3, 0xf9,
	0x64, 0xcd, 0x6a, 0x09, 0xf0, 0x49, 0xa4, 0x62, 0x88, 0xf9, 0xb7, 0x06, 0x74, 0xd2, 0xa9, 0xaf,
	0xa9, 0x83, 0xe9, 0x09, 0x0b, 0x33, 0x69, 0xf1, 0x0f, 0x81, 0xb8, 0x51, 0x10, 0x88, 0x4b, 0x07,
	0x9f, 0xae, 0x30, 0x3e, 0xa8, 0x24, 0xb4, 0xab, 0x30, 0x42, 0xec, 0x3b, 0x02, 0x2e, 0x2e, 0xd6,
	0x1c, 0x35, 0x76, 0x8d, 0x65, 0xe5, 0xd6, 0xc9, 0x10, 0x1f, 0xfb, 0x5f, 0x52, 0x73, 0x09, 0x16,
	0x77, 0x86, 0xd4, 0x3d, 0xdb, 0xf2, 0x46, 0x7e, 0xa8, 0x0e, 0x6b, 0x7e, 0x65, 0x00, 0xc9, 0x42,
	0x5f, 0xe7, 0x1c, 0xaf, 0xfa, 0x1c, 0xb9, 0x01, 0x8b, 0x43, 0x87, 0xd9, 0x31, 0x0d, 0x3d, 0x3f,
	0x3c, 0xb5, 0x1d, 0xb1, 0x13, 0x9e, 0xa8, 0x66, 0x75, 0x86, 0x0e, 0x3b, 0x92, 0x70, 0x64, 0xc0,
	0xfc, 0x37, 0x03, 0x6e, 0xee, 0xa9, 0x1b, 0x58, 0x09, 0xda, 0xa2, 0x42, 0x0d, 0xa9, 0x7a, 0xe6,
	0x54, 0x88, 0xc6, 0x6b, 0x55, 0x88, 0xb7, 0xa0, 0xa1, 0x6e, 0xf5, 0x8c, 0xbb, 0x83, 0x04, 0x3d,
	0x55, 0x09, 0x7d, 0x22, 0xf7, 0x94, 0x14, 0x32, 0x7a, 0x35, 0x14, 0x0c, 0x49, 0xde, 0x85, 0x36,
	0xd6, 0x26, 0x21, 0xb7, 0x03, 0x1a, 0x9e, 0xf2, 0xa1, 0x12, 0x7a, 0x4b, 0x41, 0x9f, 0x20, 0xd0,
	0x5c, 0x83, 0xd5, 0xcb, 0x0e, 0x23, 0x05, 0x6d, 0xfe, 0x95, 0x01, 0x2b, 0x33, 0x24, 0xc7, 0xce,
	0xe4, 0x77, 0x78, 0xd8, 0x8b, 0x27, 0x29, 0xce, 0x3b, 0xc9, 0x4d, 0x78, 0x73, 0x2e, 0x9b, 0xea,
	0x18, 0xbf, 0x54, 0xef, 0x0f, 0x9e, 0xc3, 0x1d, 0xb2, 0xa1, 0xa3, 0x85, 0x91, 0x6f, 0x03, 0xee,
	0xaa, 0x77, 0x04, 0xac, 0x70, 0x55, 0xd4, 0x78, 0x00, 0x0d, 0x34, 0xdc, 0xd3, 0x24, 0x1a, 0xc7,
	0xba, 0xe9, 0x7f, 0x6d, 0x76, 0xc6, 0x27, 0x02, 0x6b, 0xe1, 0x5b, 0x2e, 0xfe, 0x64, 0xb2, 0x74,
	0x13, 0x1a, 0x4a, 0x7b, 0xa9, 0x58, 0xd5, 0x09, 0x0f, 0xba, 0x05, 0x42, 0x55, 0x51, 0x30, 0xa1,
	0x99, 0xfa, 0x0d, 0x34, 0x48, 0xd6, 0x76, 0x23, 0xe7, 0x85, 0xc0, 0x49, 0xa5, 0x95, 0x47, 0xce,
	0x0b, 0x05, 0xf6, 0x43, 0x01, 0x2e, 0x2b, 0xb0, 0x1f, 0x9e, 0x08, 0x0e, 0xf1, 0x43, 0x86, 0x34,
	0xb0, 0x55, 0x55, 0x60, 0xcb, 0xbc, 0x69, 0xea, 0xc0, 0xd6, 0x18, 0x4d, 0x07, 0xe6, 0x7f, 0x18,
	0xd0, 0xca, 0xf1, 0x3f, 0x2f, 0xd9, 0x27, 0x3f, 0x85, 0xce, 0xf4, 0xf9, 0x45, 0x76, 0x05, 0x0a,
	0x57, 0x48, 0xad, 0x95, 0xbe, 0xc5, 0x60, 0xc9, 0x3b, 0x65, 0xb9, 0x98, 0x65, 0xf9, 0x92, 0x03,
	0xde, 0x81, 0x8e, 0xa0, 0xce, 0x0a, 0x47, 0x9e, 0xb4, 0x25, 0x5d, 0x5f, 0xcb, 0xe7, 0x3a, 0x54,
	0x94, 0x29, 0xc8, 0x37, 0x30, 0x35, 0x32, 0xff, 0xa5, 0x02, 0xcd, 0x2c, 0x37, 0x99, 0x07, 0x09,
	0x23, 0xf7, 0x20, 0xa1, 0x0f, 0x5a, 0xc8, 0x1c, 0x74, 0x03, 0x16, 0xc3, 0xf1, 0xa8, 0x4f, 0x13,
	0x3b, 0x1a, 0xd8, 0x34, 0xe4, 0x89, 0x4f, 0x25, 0xd7, 0x45, 0xab, 0x23, 0x11, 0xcf, 0x06, 0x7b,
	0x12, 0x9c, 0x39, 0x56, 0x69, 0xfe, 0xb1, 0xca, 0xd9, 0x63, 0xcd, 0xe8, 0xbb, 0x72, 0x41, 0xdf,
	0x6f, 0x42, 0x5d, 0x75, 0x50, 0x7d, 0x0f, 0xd5, 0x57, 0xb4, 0x6a, 0x12, 0x30, 0xdb, 0x2d, 0xab,
	0x5d, 0x7e, 0x21, 0xd6, 0xe7, 0xb4, 0x9e, 0xa7, 0x0f, 0x76, 0xef, 0x40, 0x09, 0x8b, 0xfa, 0x06,
	0x1a, 0x47, 0x37, 0x7b, 0x3f, 0x62, 0x35, 0x8f, 0x58, 0xb1, 0x9c, 0xcf, 0x6c, 0x61, 0x24, 0x58,
	0x8a, 0xd4, 0xac, 0x8a, 0xcf, 0xf0, 0x63, 0x8a, 0x37, 0xa0, 0x26, 0x5b, 0x08, 0xaa, 0x0c, 0x29,
	0x5a, 0x55, 0x1c, 0x1f, 0x78, 0x19, 0x65, 0xb4, 0xb3, 0xca, 0x20, 0xbf, 0x0f, 0x2b, 0x42, 0x46,
	0x7d, 0x7a, 0x8a, 0x92, 0xb2, 0xfd, 0xd0, 0xf6, 0xe8, 0xc0, 0x19, 0x07, 0xdc, 0x76, 0x07, 0x58,
	0x78, 0x94, 0xac, 0x6b, 0x23, 0x3f, 0xdc, 0x16, 0x04, 0x27, 0xec, 0x20, 0xdc, 0x95, 0xd8, 0x9d,
	0x01, 0xc6, 0x37, 0x7c, 0xee, 0x8f, 0x06, 0x03, 0x46, 0x39, 0x56, 0x21, 0x25, 0xab, 0x81, 0xb0,
	0x67, 0x08, 0x9a, 0x92, 0xa8, 0xbd, 0x17, 0x33, 0x24, 0x32, 0x22, 0xcc, 0xed, 0x69, 0x90, 0xd7,
	0xec, 0x69, 0x64, 0x1f, 0x85, 0x96, 0x66, 0x1e, 0x85, 0xd6, 0xa1, 0xab, 0xb4, 0x36, 0xd5, 0xcf,
	0x32, 0x2a, 0xa1, 0x2d, 0xe1, 0xc7, 0x5a, 0x4b, 0xef, 0x40, 0x5b, 0x77, 0xc8, 0x95, 0xb2, 0xae,
	0x21, 0x9d, 0xea, 0x9b, 0xef, 0x49, 0x95, 0x3d, 0x98, 0xf6, 0xd1, 0xe3, 0xc8, 0x1d, 0xaa, 0xa7,
	0xf8, 0xa5, 0xfc, 0x9d, 0xb5, 0x27, 0x50, 0x69, 0x2b, 0x5d, 0x0c, 0x88, 0x05, 0xcb, 0x18, 0xa1,
	0x32, 0x29, 0x33, 0xba, 0xe9, 0x0d, 0x8c, 0xc3, 0x6b, 0xf9, 0x16, 0xae, 0x50, 0xf8, 0xb4, 0x17,
	0x8c, 0x2e, 0x4b, 0x06, 0x17, 0x60, 0xe6, 0xd7, 0x06, 0x2c, 0x66, 0xbb, 0x35, 0x7b, 0x3a, 0x2f,
	0x18, 0x3a, 0x71, 0x4c, 0x43, 0xdb, 0xd1, 0xef, 0x15, 0x35, 0x09, 0xd8, 0xc2, 0xa6, 0x2f, 0xde,
	0xba, 0xb6, 0x1b, 0x79, 0x3a, 0x8e, 0xd7, 0x11, 0xb2, 0x13, 0x79, 0xe2, 0xc2, 0x96, 0x5f, 0x5f,
	0xd9, 0x23, 0xca, 0x98, 0x48, 0x59, 0xe4, 0xa5, 0xd5, 0x44, 0xe0, 0xa1, 0x84, 0xe5, 0x82, 0xa6,
	0x7e, 0x0d, 0x94, 0x41, 0xd3, 0x7c, 0x00, 0xa5, 0xe3, 0xd8, 0xc1, 0xdc, 0x5c, 0x59, 0x85, 0x64,
	0x40, 0x8d, 0x32, 0x66, 0x58, 0xc8, 0xc5, 0x84, 0x3d, 0x68, 0x88, 0x79, 0xec, 0xd9, 0x40, 0x3f,
	0xe5, 0x5f, 0x08, 0x71, 0x26, 0x94, 0x99, 0x20, 0x99, 0x7d, 0x5c, 0x16, 0xf3, 0x2c, 0x89, 0x32,
	0xbf, 0x2e, 0x42, 0xef, 0x49, 0x74, 0x8a, 0xb9, 0xca, 0xb8, 0x2f, 0xcc, 0xc4, 0x71, 0x55, 0x37,
	0xdd, 0x49, 0x5f, 0xc3, 0x8d, 0xfc, 0x6b, 0xf8, 0xd4, 0xa7, 0x25, 0x4b, 0x53, 0x9f, 0x9e, 0x79,
	0x18, 0x22, 0x6b, 0xd0, 0xf4, 0xc3, 0x78, 0xcc, 0xed, 0x5c, 0x54, 0x04, 0x84, 0x1d, 0x62, 0x0c,
	0x99, 0x52, 0x64, 0x6f, 0x00, 0x45, 0x81, 0xc1, 0xe7, 0x0e, 0x74, 0x14, 0x5b, 0xf6, 0x20, 0x89,
	0x46, 0xd3, 0x48, 0xd3, 0x52, 0xe0, 0x47, 0x49, 0x34, 0x3a, 0xc1, 0xef, 0xc4, 0x34, 0xdd, 0x38,
	0xe4, 0x7e, 0x60, 0xab, 0xd7, 0xc6, 0x92, 0xd5, 0x56, 0xf0, 0xcf, 0x04, 0xf8, 0x84, 0x89, 0x68,
	0x20, 0x76, 0x9b, 0xc6, 0x1d, 0x11, 0xf4, 0x54, 0xd4, 0x11, 0x8c, 0x66, 0xa2, 0xce, 0xc8, 0x79,
	0x21, 0x10, 0x6b, 0xf8, 0xdd, 0x18, 0x5c, 0x12, 0x63, 0x0a, 0xfc, 0x3c, 0x17, 0x48, 0x1a, 0xf9,
	0x40, 0x72, 0x17, 0xaa, 0x2c, 0x1a, 0x27, 0x2e, 0x65, 0xbd, 0x66, 0xfe, 0x69, 0x3d, 0xa3, 0x40,
	0x4b, 0xd3, 0x98, 0xff, 0x60, 0xc0, 0xf2, 0x3c, 0x8d, 0x90, 0x0f, 0xa1, 0x84, 0x11, 0xcc, 0x50,
	0xf6, 0x9f, 0xb6, 0xf7, 0xe6, 0x6b, 0xcf, 0x42, 0x6a, 0x72, 0x17, 0x1a, 0x8c, 0x71, 0x3b, 0x1a,
	0xf3, 0x78, 0xcc, 0xe7, 0x7f, 0x67, 0x00, 0x8c, 0xf1, 0x67, 0x12, 0x4f, 0xb6, 0x61, 0x51, 0xa9,
	0x17, 0xef, 0xde, 0xa1, 0x1f, 0x72, 0x5d, 0x7b, 0xa5, 0x99, 0x8f, 0xf4, 0x58, 0xb1, 0xc7, 0xbe,
	0x1f, 0x72, 0xab, 0x93, 0xe4, 0xc6, 0xcc, 0xfc, 0x53, 0x68, 0xe7, 0x49, 0xbe, 0xe7, 0x33, 0xe3,
	0x6c, 0xe0, 0x90, 0x3d, 0xcb, 0x97, 0x06, 0x0e, 0xf3, 0x4f, 0xe0, 0xda, 0x3c, 0xa1, 0x30, 0xb2,
	0x0b, 0x6d, 0x96, 0x83, 0xa8, 0x44, 0xe9, 0xad, 0xab, 0x64, 0x69, 0xcd, 0xcc, 0x31, 0xbf, 0x2e,
	0xc0, 0xa2, 0x22, 0xdc, 0x99, 0x6a, 0x07, 0xcb, 0x07, 0x3d, 0x4a, 0x2d, 0xd5, 0xd0, 0xe5, 0x83,
	0xc6, 0x28, 0x63, 0xdd, 0x84, 0xa5, 0x0c, 0x75, 0x6a, 0xaf, 0xd2, 0x9f, 0x16, 0xa7, 0x28, 0x6d,
	0xb2, 0xba, 0xfd, 0x5d, 0xcc, 0xb4, 0xbf, 0x45, 0x0c, 0x8f, 0x46, 0x23, 0x1a, 0x72, 0xdd, 0xf9,
	0x48, 0xc7, 0xe4, 0x2d, 0xa8, 0x3b, 0x09, 0xf7, 0x07, 0x8e, 0xcb, 0x75, 0x6f, 0x71, 0x0a, 0x10,
	0xa9, 0x67, 0x3a, 0xb0, 0x87, 0x0e, 0xd3, 0xf9, 0x46, 0x2b, 0x85, 0xee, 0x3b, 0x6c, 0x48, 0x7e,
	0x00, 0x9d, 0x53, 0x1a, 0xd2, 0xc4, 0xe1, 0xd4, 0x53, 0x9f, 0xa9, 0xc8, 0xce, 0x63, 0x3b, 0x05,
	0x63, 0x46, 0x64, 0xfe, 0x93, 0x21, 0x93, 0xd0, 0x3d, 0xcf, 0xe7, 0x73, 0x23, 0xd1, 0x3d, 0xb8,
	0xe6, 0xd1, 0x80, 0x72, 0x6a, 0xa7, 0xdf, 0x79, 0x4c, 0x3f, 0x7b, 0xa9, 0x5b, 0x4b, 0x12, 0x79,
	0xa4, 0x70, 0xf2, 0x93, 0x97, 0xc7, 0xb0, 0xac, 0xe6, 0x04, 0xd1, 0x69, 0x66, 0x8a, 0x34, 0xc6,
	0x37, 0xd2, 0x2c, 0x0d, 0x69, 0xb2, 0x9e, 0x44, 0xe4, 0xb4, 0x27, 0x72, 0x96, 0x5c, 0xec, 0x36,
	0xb4, 0x3c, 0xca, 0x78, 0x32, 0x76, 0xb9, 0xcd, 0x68, 0x30, 0x50, 0x1f, 0x5b, 0x36, 0x35, 0xf0,
	0x98, 0x06, 0x03, 0xf3, 0x39, 0x2c, 0x5e, 0x58, 0xed, 0xfb, 0x06, 0x56, 0x91, 0x76, 0x3d, 0x1f,
	0x46, 0xf2, 0x71, 0x82, 0xe6, 0x33, 0xfc, 0x0e, 0x22, 0xc4, 0xea, 0x2a, 0xc7, 0xff, 0x55, 0x01,
	0xea, 0x87, 0xfe, 0x69, 0x82, 0x5f, 0xb6, 0xe1, 0xdb, 0x79, 0x42, 0x1d, 0xae, 0x9e, 0x9c, 0xeb,
	0x96, 0x1e, 0x92, 0x7b, 0xd3, 0x6f, 0x32, 0xe5, 0x23, 0x46, 0xda, 0x38, 0x4a, 0x67, 0xeb, 0x8c,
	0x38, 0xfd, 0x5a, 0xf3, 0x2e, 0xd4, 0xa9, 0xe7, 0x73, 0x5b, 0x85, 0x8e, 0xe2, 0xec, 0x67, 0x81,
	0x42, 0x67, 0x56, 0x4d, 0x90, 0x60, 0xc8, 0x7f, 0x1b, 0x9a, 0x3c, 0x19, 0x87, 0x2e, 0xea, 0x9c,
	0x47, 0xca, 0x22, 0x1b, 0x29, 0xec, 0x24, 0x22, 0x1f, 0x41, 0x23, 0xeb, 0x42, 0x33, 0xfa, 0xb8,
	0xe0, 0x19, 0x56, 0x96, 0x5a, 0xd8, 0x54, 0xaa, 0x88, 0xb4, 0x33, 0x2e, 0x6c, 0xa0, 0xad, 0xc1,
	0x47, 0x08, 0xdd, 0x78, 0x0a, 0x6b, 0x2f, 0xfb, 0x90, 0x98, 0x74, 0xa0, 0xf1, 0x19, 0xbe, 0xa2,
	0xe0, 0xf7, 0xb2, 0xdd, 0x05, 0xd2, 0x82, 0xfa, 0xcf, 0x1c, 0x9f, 0x6f, 0xc5, 0x71, 0x70, 0xde,
	0x35, 0x08, 0x40, 0xe5, 0x91, 0x1f, 0xfa, 0x6c, 0xd8, 0x2d, 0x6c, 0x7c, 0x0a, 0xab, 0x57, 0x7f,
	0xe8, 0x4b, 0x16, 0xa1, 0x95, 0x4e, 0xde, 0x8d, 0x42, 0xb1, 0xde, 0x35, 0x58, 0xcc, 0x6c, 0x20,
	0x3f, 0x89, 0xec, 0x1a, 0x1b, 0x7f, 0x08, 0x9d, 0x99, 0x0c, 0x8b, 0x34, 0xa0, 0xfa, 0xd9, 0xd3,
	0xc7, 0x4f, 0x9f, 0xfd, 0xec, 0x69, 0x77, 0x81, 0x54, 0xa1, 0xf8, 0xe4, 0x8b, 0x0f, 0x25, 0x03,
	0xc7, 0x4f, 0xb7, 0x8e, 0x8e, 0xfe, 0xb8, 0x5b, 0x20, 0x35, 0x28, 0x7d, 0x71, 0x7c, 0xb2, 0xdb,
	0x2d, 0x6e, 0xac, 0xa5, 0xdf, 0xf3, 0x8a, 0x04, 0xa2, 0x06, 0xa5, 0xe3, 0x9d, 0x2d, 0x31, 0xad,
	0x06, 0xa5, 0x47, 0x07, 0x4f, 0xf6, 0xba, 0xc6, 0xc6, 0x4d, 0x68, 0x64, 0xca, 0x1b, 0x52, 0x81,
	0xc2, 0xe7, 0x1f, 0x74, 0x17, 0xf0, 0xef, 0xbd, 0xae, 0xb1, 0x71, 0x0b, 0x6a, 0xfa, 0xf2, 0x11,
	0x5b, 0x48, 0xa3, 0x95, 0xfb, 0x1e, 0x8d, 0x05, 0x83, 0x26, 0x74, 0x67, 0x2d, 0x42, 0x4c, 0x3e,
	0x7c, 0x5f, 0x2e, 0x72, 0xf8, 0x41, 0xd7, 0xb8, 0xf7, 0xbf, 0x05, 0xa8, 0x48, 0x36, 0xc8, 0x47,
	0xa0, 0x3e, 0x2c, 0x27, 0xd7, 0x66, 0xbe, 0xfa, 0x92, 0xc2, 0x5e, 0xb9, 0x3e, 0x0b, 0x56, 0xd5,
	0xe7, 0xc2, 0xfb, 0x06, 0x39, 0x82, 0x25, 0xec, 0x63, 0x64, 0xbb, 0x09, 0xcf, 0x62, 0x92, 0x1a,
	0xc4, 0x85, 0xd6, 0xc7, 0xca, 0xca, 0x3c, 0x54, 0x66, 0xc5, 0x21, 0x5c, 0x9b, 0xab, 0x2a, 0xf2,
	0xce, 0xab, 0x7c, 0x62, 0xbe, 0xf2, 0xee, 0x4b, 0xa8, 0xe4, 0x4e, 0xeb, 0xc6, 0xfb, 0x06, 0xf9,
	0x29, 0x54, 0x63, 0x49, 0x44, 0xae, 0xcf, 0xcc, 0xd2, 0xab, 0xdd, 0xb8, 0x00, 0xd7, 0x9c, 0x8a,
	0xd9, 0xae, 0xec, 0x89, 0x91, 0xcc, 0x57, 0x28, 0xd9, 0x9e, 0xda, 0x74, 0xf6, 0x4c, 0xf3, 0xcc,
	0x5c, 0xb8, 0xf7, 0x8f, 0x06, 0x74, 0x66, 0x2a, 0x7b, 0xf2, 0x05, 0x54, 0x55, 0xb3, 0x83, 0xa4,
	0xa7, 0xb8, 0xb2, 0x29, 0xb3, 0x72, 0xe7, 0x65, 0x64, 0x29, 0xb7, 0x7f, 0x04, 0x25, 0xe6, 0x4c,
	0x28, 0x31, 0x2f, 0x99, 0x91, 0xe9, 0x7e, 0xac, 0xdc, 0xbe, 0x92, 0x46, 0x2f, 0xb9, 0x7d, 0xef,
	0x37, 0x7f, 0x5d, 0x33, 0x7e, 0xfd, 0xed, 0xaa, 0xf1, 0xcd, 0xb7, 0xab, 0xc6, 0x7f, 0x7d, 0xbb,
	0x6a, 0xfc, 0xf2, 0xbb, 0xd5, 0x85, 0xbf, 0xfc, 0x6e, 0x75, 0xe1, 0x9b, 0xef, 0x56, 0x17, 0x7e,
	0xf3, 0xdd, 0xea, 0x02, 0x74, 0xa3, 0xe4, 0x74, 0x93, 0xfb, 0x67, 0x93, 0xcd, 0xb3, 0x09, 0xfe,
	0x4f, 0x41, 0xbf, 0x82, 0x7f, 0xee, 0xff, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6a, 0xa7, 0x03,
	0x23, 0xd7, 0x30, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BackupClient is the client API for Backup service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackupClient interface {
	Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (Backup_BackupClient, error)
	// CheckPendingAdminOp used for snapshot backup. before we start snapshot for a TiKV.
	// we need stop all schedule first and make sure all in-flight schedule has finished.
	// this rpc check all pending conf change for leader.
	CheckPendingAdminOp(ctx context.Context, in *CheckAdminRequest, opts ...grpc.CallOption) (Backup_CheckPendingAdminOpClient, error)
	// PrepareSnapshotBackup is an advanced version of preparing snapshot backup.
	// Check the defination of `PrepareSnapshotBackupRequest` for more.
	PrepareSnapshotBackup(ctx context.Context, opts ...grpc.CallOption) (Backup_PrepareSnapshotBackupClient, error)
	// prepare is used for file-copy backup. before we start the backup for a TiKV.
	// we need invoke this function to generate the SST files map. or we get nothing to backup.
	Prepare(ctx context.Context, in *PrepareRequest, opts ...grpc.CallOption) (*PrepareResponse, error)
	// cleanup used for file-copy backup. after we finish the backup for a TiKV.
	// we need clean some internel state. e.g. checkpoint, SST File maps
	Cleanup(ctx context.Context, in *CleanupRequest, opts ...grpc.CallOption) (*CleanupResponse, error)
}

type backupClient struct {
	cc *grpc.ClientConn
}

func NewBackupClient(cc *grpc.ClientConn) BackupClient {
	return &backupClient{cc}
}

func (c *backupClient) Backup(ctx context.Context, in *BackupRequest, opts ...grpc.CallOption) (Backup_BackupClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Backup_serviceDesc.Streams[0], "/backup.Backup/backup", opts...)
	if err != nil {
		return nil, err
	}
	x := &backupBackupClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Backup_BackupClient interface {
	Recv() (*BackupResponse, error)
	grpc.ClientStream
}

type backupBackupClient struct {
	grpc.ClientStream
}

func (x *backupBackupClient) Recv() (*BackupResponse, error) {
	m := new(BackupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *backupClient) CheckPendingAdminOp(ctx context.Context, in *CheckAdminRequest, opts ...grpc.CallOption) (Backup_CheckPendingAdminOpClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Backup_serviceDesc.Streams[1], "/backup.Backup/CheckPendingAdminOp", opts...)
	if err != nil {
		return nil, err
	}
	x := &backupCheckPendingAdminOpClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Backup_CheckPendingAdminOpClient interface {
	Recv() (*CheckAdminResponse, error)
	grpc.ClientStream
}

type backupCheckPendingAdminOpClient struct {
	grpc.ClientStream
}

func (x *backupCheckPendingAdminOpClient) Recv() (*CheckAdminResponse, error) {
	m := new(CheckAdminResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *backupClient) PrepareSnapshotBackup(ctx context.Context, opts ...grpc.CallOption) (Backup_PrepareSnapshotBackupClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Backup_serviceDesc.Streams[2], "/backup.Backup/PrepareSnapshotBackup", opts...)
	if err != nil {
		return nil, err
	}
	x := &backupPrepareSnapshotBackupClient{stream}
	return x, nil
}

type Backup_PrepareSnapshotBackupClient interface {
	Send(*PrepareSnapshotBackupRequest) error
	Recv() (*PrepareSnapshotBackupResponse, error)
	grpc.ClientStream
}

type backupPrepareSnapshotBackupClient struct {
	grpc.ClientStream
}

func (x *backupPrepareSnapshotBackupClient) Send(m *PrepareSnapshotBackupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *backupPrepareSnapshotBackupClient) Recv() (*PrepareSnapshotBackupResponse, error) {
	m := new(PrepareSnapshotBackupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *backupClient) Prepare(ctx context.Context, in *PrepareRequest, opts ...grpc.CallOption) (*PrepareResponse, error) {
	out := new(PrepareResponse)
	err := c.cc.Invoke(ctx, "/backup.Backup/prepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backupClient) Cleanup(ctx context.Context, in *CleanupRequest, opts ...grpc.CallOption) (*CleanupResponse, error) {
	out := new(CleanupResponse)
	err := c.cc.Invoke(ctx, "/backup.Backup/cleanup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackupServer is the server API for Backup service.
type BackupServer interface {
	Backup(*BackupRequest, Backup_BackupServer) error
	// CheckPendingAdminOp used for snapshot backup. before we start snapshot for a TiKV.
	// we need stop all schedule first and make sure all in-flight schedule has finished.
	// this rpc check all pending conf change for leader.
	CheckPendingAdminOp(*CheckAdminRequest, Backup_CheckPendingAdminOpServer) error
	// PrepareSnapshotBackup is an advanced version of preparing snapshot backup.
	// Check the defination of `PrepareSnapshotBackupRequest` for more.
	PrepareSnapshotBackup(Backup_PrepareSnapshotBackupServer) error
	// prepare is used for file-copy backup. before we start the backup for a TiKV.
	// we need invoke this function to generate the SST files map. or we get nothing to backup.
	Prepare(context.Context, *PrepareRequest) (*PrepareResponse, error)
	// cleanup used for file-copy backup. after we finish the backup for a TiKV.
	// we need clean some internel state. e.g. checkpoint, SST File maps
	Cleanup(context.Context, *CleanupRequest) (*CleanupResponse, error)
}

// UnimplementedBackupServer can be embedded to have forward compatible implementations.
type UnimplementedBackupServer struct {
}

func (*UnimplementedBackupServer) Backup(req *BackupRequest, srv Backup_BackupServer) error {
	return status.Errorf(codes.Unimplemented, "method Backup not implemented")
}
func (*UnimplementedBackupServer) CheckPendingAdminOp(req *CheckAdminRequest, srv Backup_CheckPendingAdminOpServer) error {
	return status.Errorf(codes.Unimplemented, "method CheckPendingAdminOp not implemented")
}
func (*UnimplementedBackupServer) PrepareSnapshotBackup(srv Backup_PrepareSnapshotBackupServer) error {
	return status.Errorf(codes.Unimplemented, "method PrepareSnapshotBackup not implemented")
}
func (*UnimplementedBackupServer) Prepare(ctx context.Context, req *PrepareRequest) (*PrepareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prepare not implemented")
}
func (*UnimplementedBackupServer) Cleanup(ctx context.Context, req *CleanupRequest) (*CleanupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cleanup not implemented")
}

func RegisterBackupServer(s *grpc.Server, srv BackupServer) {
	s.RegisterService(&_Backup_serviceDesc, srv)
}

func _Backup_Backup_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BackupRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackupServer).Backup(m, &backupBackupServer{stream})
}

type Backup_BackupServer interface {
	Send(*BackupResponse) error
	grpc.ServerStream
}

type backupBackupServer struct {
	grpc.ServerStream
}

func (x *backupBackupServer) Send(m *BackupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Backup_CheckPendingAdminOp_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CheckAdminRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackupServer).CheckPendingAdminOp(m, &backupCheckPendingAdminOpServer{stream})
}

type Backup_CheckPendingAdminOpServer interface {
	Send(*CheckAdminResponse) error
	grpc.ServerStream
}

type backupCheckPendingAdminOpServer struct {
	grpc.ServerStream
}

func (x *backupCheckPendingAdminOpServer) Send(m *CheckAdminResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Backup_PrepareSnapshotBackup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BackupServer).PrepareSnapshotBackup(&backupPrepareSnapshotBackupServer{stream})
}

type Backup_PrepareSnapshotBackupServer interface {
	Send(*PrepareSnapshotBackupResponse) error
	Recv() (*PrepareSnapshotBackupRequest, error)
	grpc.ServerStream
}

type backupPrepareSnapshotBackupServer struct {
	grpc.ServerStream
}

func (x *backupPrepareSnapshotBackupServer) Send(m *PrepareSnapshotBackupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *backupPrepareSnapshotBackupServer) Recv() (*PrepareSnapshotBackupRequest, error) {
	m := new(PrepareSnapshotBackupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Backup_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backup.Backup/Prepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServer).Prepare(ctx, req.(*PrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Backup_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackupServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backup.Backup/Cleanup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackupServer).Cleanup(ctx, req.(*CleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Backup_serviceDesc = grpc.ServiceDesc{
	ServiceName: "backup.Backup",
	HandlerType: (*BackupServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "prepare",
			Handler:    _Backup_Prepare_Handler,
		},
		{
			MethodName: "cleanup",
			Handler:    _Backup_Cleanup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "backup",
			Handler:       _Backup_Backup_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CheckPendingAdminOp",
			Handler:       _Backup_CheckPendingAdminOp_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PrepareSnapshotBackup",
			Handler:       _Backup_PrepareSnapshotBackup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "brpb.proto",
}

// ExternalStorageClient is the client API for ExternalStorage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExternalStorageClient interface {
	// Restore to a file
	Restore(ctx context.Context, in *ExternalStorageRestoreRequest, opts ...grpc.CallOption) (*ExternalStorageRestoreResponse, error)
	// Save a file to storage
	Save(ctx context.Context, in *ExternalStorageSaveRequest, opts ...grpc.CallOption) (*ExternalStorageSaveResponse, error)
}

type externalStorageClient struct {
	cc *grpc.ClientConn
}

func NewExternalStorageClient(cc *grpc.ClientConn) ExternalStorageClient {
	return &externalStorageClient{cc}
}

func (c *externalStorageClient) Restore(ctx context.Context, in *ExternalStorageRestoreRequest, opts ...grpc.CallOption) (*ExternalStorageRestoreResponse, error) {
	out := new(ExternalStorageRestoreResponse)
	err := c.cc.Invoke(ctx, "/backup.ExternalStorage/restore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalStorageClient) Save(ctx context.Context, in *ExternalStorageSaveRequest, opts ...grpc.CallOption) (*ExternalStorageSaveResponse, error) {
	out := new(ExternalStorageSaveResponse)
	err := c.cc.Invoke(ctx, "/backup.ExternalStorage/save", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExternalStorageServer is the server API for ExternalStorage service.
type ExternalStorageServer interface {
	// Restore to a file
	Restore(context.Context, *ExternalStorageRestoreRequest) (*ExternalStorageRestoreResponse, error)
	// Save a file to storage
	Save(context.Context, *ExternalStorageSaveRequest) (*ExternalStorageSaveResponse, error)
}

// UnimplementedExternalStorageServer can be embedded to have forward compatible implementations.
type UnimplementedExternalStorageServer struct {
}

func (*UnimplementedExternalStorageServer) Restore(ctx context.Context, req *ExternalStorageRestoreRequest) (*ExternalStorageRestoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restore not implemented")
}
func (*UnimplementedExternalStorageServer) Save(ctx context.Context, req *ExternalStorageSaveRequest) (*ExternalStorageSaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Save not implemented")
}

func RegisterExternalStorageServer(s *grpc.Server, srv ExternalStorageServer) {
	s.RegisterService(&_ExternalStorage_serviceDesc, srv)
}

func _ExternalStorage_Restore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExternalStorageRestoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalStorageServer).Restore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backup.ExternalStorage/Restore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalStorageServer).Restore(ctx, req.(*ExternalStorageRestoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalStorage_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExternalStorageSaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalStorageServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/backup.ExternalStorage/Save",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalStorageServer).Save(ctx, req.(*ExternalStorageSaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExternalStorage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "backup.ExternalStorage",
	HandlerType: (*ExternalStorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "restore",
			Handler:    _ExternalStorage_Restore_Handler,
		},
		{
			MethodName: "save",
			Handler:    _ExternalStorage_Save_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "brpb.proto",
}

func (m *PrepareSnapshotBackupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareSnapshotBackupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareSnapshotBackupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeaseInSeconds != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.LeaseInSeconds))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Regions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ty != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Ty))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrepareSnapshotBackupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareSnapshotBackupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareSnapshotBackupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastLeaseIsValid {
		i--
		if m.LastLeaseIsValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Ty != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Ty))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BackupSize != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.BackupSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if len(m.Ranges) > 0 {
		for iNdEx := len(m.Ranges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ranges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if m.Mode != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.DbMaps) > 0 {
		for iNdEx := len(m.DbMaps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DbMaps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.IsTxnKv {
		i--
		if m.IsTxnKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.NewCollationsEnabled) > 0 {
		i -= len(m.NewCollationsEnabled)
		copy(dAtA[i:], m.NewCollationsEnabled)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.NewCollationsEnabled)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Policies) > 0 {
		for iNdEx := len(m.Policies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Policies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.ApiVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ApiVersion))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.BackupResult) > 0 {
		i -= len(m.BackupResult)
		copy(dAtA[i:], m.BackupResult)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.BackupResult)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.DdlIndexes != nil {
		{
			size, err := m.DdlIndexes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.RawRangeIndex != nil {
		{
			size, err := m.RawRangeIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.SchemaIndex != nil {
		{
			size, err := m.SchemaIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.FileIndex != nil {
		{
			size, err := m.FileIndex.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Version != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x60
	}
	if len(m.BrVersion) > 0 {
		i -= len(m.BrVersion)
		copy(dAtA[i:], m.BrVersion)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.BrVersion)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Ddls) > 0 {
		i -= len(m.Ddls)
		copy(dAtA[i:], m.Ddls)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Ddls)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.RawRanges) > 0 {
		for iNdEx := len(m.RawRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.IsRawKv {
		i--
		if m.IsRawKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.EndVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.EndVersion))
		i--
		dAtA[i] = 0x30
	}
	if m.StartVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.StartVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ClusterVersion) > 0 {
		i -= len(m.ClusterVersion)
		copy(dAtA[i:], m.ClusterVersion)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ClusterVersion)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClusterId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ClusterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CipherIv) > 0 {
		i -= len(m.CipherIv)
		copy(dAtA[i:], m.CipherIv)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.CipherIv)))
		i--
		dAtA[i] = 0x62
	}
	if m.Size_ != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Cf) > 0 {
		i -= len(m.Cf)
		copy(dAtA[i:], m.Cf)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Cf)))
		i--
		dAtA[i] = 0x52
	}
	if m.TotalBytes != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TotalBytes))
		i--
		dAtA[i] = 0x48
	}
	if m.TotalKvs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TotalKvs))
		i--
		dAtA[i] = 0x40
	}
	if m.Crc64Xor != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Crc64Xor))
		i--
		dAtA[i] = 0x38
	}
	if m.EndVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.EndVersion))
		i--
		dAtA[i] = 0x30
	}
	if m.StartVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.StartVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sha256) > 0 {
		i -= len(m.Sha256)
		copy(dAtA[i:], m.Sha256)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Sha256)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetaFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BackupRanges) > 0 {
		for iNdEx := len(m.BackupRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BackupRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Ddls) > 0 {
		for iNdEx := len(m.Ddls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ddls[iNdEx])
			copy(dAtA[i:], m.Ddls[iNdEx])
			i = encodeVarintBrpb(dAtA, i, uint64(len(m.Ddls[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RawRanges) > 0 {
		for iNdEx := len(m.RawRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RawRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DataFiles) > 0 {
		for iNdEx := len(m.DataFiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataFiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MetaFiles) > 0 {
		for iNdEx := len(m.MetaFiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MetaFiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlacementPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatsBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatsBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JsonTable) > 0 {
		i -= len(m.JsonTable)
		copy(dAtA[i:], m.JsonTable)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.JsonTable)))
		i--
		dAtA[i] = 0x12
	}
	if m.PhysicalId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.PhysicalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatsFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatsFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatsFileIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatsFileIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatsFileIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InlineData) > 0 {
		i -= len(m.InlineData)
		copy(dAtA[i:], m.InlineData)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.InlineData)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CipherIv) > 0 {
		i -= len(m.CipherIv)
		copy(dAtA[i:], m.CipherIv)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.CipherIv)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SizeOri != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.SizeOri))
		i--
		dAtA[i] = 0x20
	}
	if m.SizeEnc != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.SizeEnc))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Sha256) > 0 {
		i -= len(m.Sha256)
		copy(dAtA[i:], m.Sha256)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Sha256)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Schema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatsIndex) > 0 {
		for iNdEx := len(m.StatsIndex) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StatsIndex[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Stats) > 0 {
		i -= len(m.Stats)
		copy(dAtA[i:], m.Stats)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Stats)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TiflashReplicas != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TiflashReplicas))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalBytes != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TotalBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalKvs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TotalKvs))
		i--
		dAtA[i] = 0x20
	}
	if m.Crc64Xor != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Crc64Xor))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Table) > 0 {
		i -= len(m.Table)
		copy(dAtA[i:], m.Table)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Table)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Db) > 0 {
		i -= len(m.Db)
		copy(dAtA[i:], m.Db)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Db)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IDMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DownstreamId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.DownstreamId))
		i--
		dAtA[i] = 0x10
	}
	if m.UpstreamId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.UpstreamId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PitrTableMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PitrTableMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PitrTableMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IdMap != nil {
		{
			size, err := m.IdMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PitrDBMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PitrDBMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PitrDBMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IdMap != nil {
		{
			size, err := m.IdMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cf) > 0 {
		i -= len(m.Cf)
		copy(dAtA[i:], m.Cf)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Cf)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterIDError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterIDError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterIDError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Request))
		i--
		dAtA[i] = 0x10
	}
	if m.Current != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Current))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Detail != nil {
		{
			size := m.Detail.Size()
			i -= size
			if _, err := m.Detail.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Error_ClusterIdError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_ClusterIdError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClusterIdError != nil {
		{
			size, err := m.ClusterIdError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Error_KvError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_KvError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KvError != nil {
		{
			size, err := m.KvError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Error_RegionError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_RegionError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RegionError != nil {
		{
			size, err := m.RegionError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StreamBackupTaskSecurityConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamBackupTaskSecurityConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamBackupTaskSecurityConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Encryption != nil {
		{
			size := m.Encryption.Size()
			i -= size
			if _, err := m.Encryption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StreamBackupTaskSecurityConfig_PlaintextDataKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamBackupTaskSecurityConfig_PlaintextDataKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PlaintextDataKey != nil {
		{
			size, err := m.PlaintextDataKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StreamBackupTaskSecurityConfig_MasterKeyConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamBackupTaskSecurityConfig_MasterKeyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MasterKeyConfig != nil {
		{
			size, err := m.MasterKeyConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CipherInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CipherInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CipherInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CipherKey) > 0 {
		i -= len(m.CipherKey)
		copy(dAtA[i:], m.CipherKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.CipherKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.CipherType != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CipherType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MasterKeyConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MasterKeyConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MasterKeyConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MasterKeys) > 0 {
		for iNdEx := len(m.MasterKeys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MasterKeys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EncryptionType != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.EncryptionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Mode != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ReplicaRead {
		i--
		if m.ReplicaRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.SubRanges) > 0 {
		for iNdEx := len(m.SubRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.DstApiVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.DstApiVersion))
		i--
		dAtA[i] = 0x78
	}
	if m.CipherInfo != nil {
		{
			size, err := m.CipherInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.CompressionLevel != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompressionLevel))
		i--
		dAtA[i] = 0x68
	}
	if m.CompressionType != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompressionType))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Cf) > 0 {
		i -= len(m.Cf)
		copy(dAtA[i:], m.Cf)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Cf)))
		i--
		dAtA[i] = 0x5a
	}
	if m.IsRawKv {
		i--
		if m.IsRawKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.StorageBackend != nil {
		{
			size, err := m.StorageBackend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Concurrency != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Concurrency))
		i--
		dAtA[i] = 0x40
	}
	if m.RateLimit != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.RateLimit))
		i--
		dAtA[i] = 0x38
	}
	if m.EndVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.EndVersion))
		i--
		dAtA[i] = 0x28
	}
	if m.StartVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.StartVersion))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.ClusterId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ClusterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StreamBackupTaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamBackupTaskInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamBackupTaskInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SecurityConfig != nil {
		{
			size, err := m.SecurityConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CompressionType != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompressionType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TableFilter) > 0 {
		for iNdEx := len(m.TableFilter) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TableFilter[iNdEx])
			copy(dAtA[i:], m.TableFilter[iNdEx])
			i = encodeVarintBrpb(dAtA, i, uint64(len(m.TableFilter[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.EndTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.EndTs))
		i--
		dAtA[i] = 0x18
	}
	if m.StartTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.StartTs))
		i--
		dAtA[i] = 0x10
	}
	if m.Storage != nil {
		{
			size, err := m.Storage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageBackend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageBackend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Backend != nil {
		{
			size := m.Backend.Size()
			i -= size
			if _, err := m.Backend.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StorageBackend_Noop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_Noop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Noop != nil {
		{
			size, err := m.Noop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_Local) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_Local) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Local != nil {
		{
			size, err := m.Local.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_S3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_S3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.S3 != nil {
		{
			size, err := m.S3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_Gcs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_Gcs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gcs != nil {
		{
			size, err := m.Gcs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_CloudDynamic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_CloudDynamic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloudDynamic != nil {
		{
			size, err := m.CloudDynamic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_Hdfs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_Hdfs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Hdfs != nil {
		{
			size, err := m.Hdfs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *StorageBackend_AzureBlobStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageBackend_AzureBlobStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureBlobStorage != nil {
		{
			size, err := m.AzureBlobStorage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Noop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Noop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Noop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Local) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Local) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Local) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Profile) > 0 {
		i -= len(m.Profile)
		copy(dAtA[i:], m.Profile)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Profile)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.SessionToken) > 0 {
		i -= len(m.SessionToken)
		copy(dAtA[i:], m.SessionToken)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.SessionToken)))
		i--
		dAtA[i] = 0x7a
	}
	if m.ObjectLockEnabled {
		i--
		if m.ObjectLockEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.ExternalId) > 0 {
		i -= len(m.ExternalId)
		copy(dAtA[i:], m.ExternalId)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ExternalId)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.RoleArn) > 0 {
		i -= len(m.RoleArn)
		copy(dAtA[i:], m.RoleArn)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.RoleArn)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.SseKmsKeyId) > 0 {
		i -= len(m.SseKmsKeyId)
		copy(dAtA[i:], m.SseKmsKeyId)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.SseKmsKeyId)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ForcePathStyle {
		i--
		if m.ForcePathStyle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.SecretAccessKey) > 0 {
		i -= len(m.SecretAccessKey)
		copy(dAtA[i:], m.SecretAccessKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.SecretAccessKey)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AccessKey) > 0 {
		i -= len(m.AccessKey)
		copy(dAtA[i:], m.AccessKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.AccessKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Acl) > 0 {
		i -= len(m.Acl)
		copy(dAtA[i:], m.Acl)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Acl)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Sse) > 0 {
		i -= len(m.Sse)
		copy(dAtA[i:], m.Sse)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Sse)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StorageClass) > 0 {
		i -= len(m.StorageClass)
		copy(dAtA[i:], m.StorageClass)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StorageClass)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CredentialsBlob) > 0 {
		i -= len(m.CredentialsBlob)
		copy(dAtA[i:], m.CredentialsBlob)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.CredentialsBlob)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PredefinedAcl) > 0 {
		i -= len(m.PredefinedAcl)
		copy(dAtA[i:], m.PredefinedAcl)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.PredefinedAcl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StorageClass) > 0 {
		i -= len(m.StorageClass)
		copy(dAtA[i:], m.StorageClass)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StorageClass)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureCustomerKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureCustomerKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureCustomerKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptionKeySha256) > 0 {
		i -= len(m.EncryptionKeySha256)
		copy(dAtA[i:], m.EncryptionKeySha256)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EncryptionKeySha256)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptionKey) > 0 {
		i -= len(m.EncryptionKey)
		copy(dAtA[i:], m.EncryptionKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EncryptionKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureBlobStorage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureBlobStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureBlobStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EncryptionKey != nil {
		{
			size, err := m.EncryptionKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.EncryptionScope) > 0 {
		i -= len(m.EncryptionScope)
		copy(dAtA[i:], m.EncryptionScope)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EncryptionScope)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AccessSig) > 0 {
		i -= len(m.AccessSig)
		copy(dAtA[i:], m.AccessSig)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.AccessSig)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SharedKey) > 0 {
		i -= len(m.SharedKey)
		copy(dAtA[i:], m.SharedKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.SharedKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AccountName) > 0 {
		i -= len(m.AccountName)
		copy(dAtA[i:], m.AccountName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.AccountName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StorageClass) > 0 {
		i -= len(m.StorageClass)
		copy(dAtA[i:], m.StorageClass)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StorageClass)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Bucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StorageClass) > 0 {
		i -= len(m.StorageClass)
		copy(dAtA[i:], m.StorageClass)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StorageClass)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudDynamic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudDynamic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudDynamic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for k := range m.Attrs {
			v := m.Attrs[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBrpb(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBrpb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBrpb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ProviderName) > 0 {
		i -= len(m.ProviderName)
		copy(dAtA[i:], m.ProviderName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ProviderName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Bucket != nil {
		{
			size, err := m.Bucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HDFS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDFS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HDFS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Remote) > 0 {
		i -= len(m.Remote)
		copy(dAtA[i:], m.Remote)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Remote)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BackupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ApiVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ApiVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CleanupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CleanupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CleanupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CleanupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SaveToStorage {
		i--
		if m.SaveToStorage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrepareResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CollectFileSize != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CollectFileSize))
		i--
		dAtA[i] = 0x20
	}
	if m.CollectFileCount != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CollectFileCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UniqueId) > 0 {
		i -= len(m.UniqueId)
		copy(dAtA[i:], m.UniqueId)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.UniqueId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckAdminRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckAdminRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckAdminRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CheckAdminResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckAdminResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckAdminResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HasPendingAdmin {
		i--
		if m.HasPendingAdmin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorageRestoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorageRestoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorageRestoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContentLength != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ContentLength))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RestoreName) > 0 {
		i -= len(m.RestoreName)
		copy(dAtA[i:], m.RestoreName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.RestoreName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageBackend != nil {
		{
			size, err := m.StorageBackend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorageRestoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorageRestoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorageRestoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ExternalStorageSaveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorageSaveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorageSaveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContentLength != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ContentLength))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageBackend != nil {
		{
			size, err := m.StorageBackend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalStorageSaveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalStorageSaveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalStorageSaveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MetaVersion != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.MetaVersion))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FileGroups) > 0 {
		for iNdEx := len(m.FileGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.MinTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.MinTs))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.MaxTs))
		i--
		dAtA[i] = 0x20
	}
	if m.ResolvedTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ResolvedTs))
		i--
		dAtA[i] = 0x18
	}
	if m.StoreId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DataFileGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFileGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataFileGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x30
	}
	if m.MinResolvedTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.MinResolvedTs))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.MaxTs))
		i--
		dAtA[i] = 0x20
	}
	if m.MinTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.MinTs))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DataFilesInfo) > 0 {
		for iNdEx := len(m.DataFilesInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataFilesInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataFileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataFileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileEncryptionInfo != nil {
		{
			size, err := m.FileEncryptionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.RegionEpoch) > 0 {
		for iNdEx := len(m.RegionEpoch) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RegionEpoch[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.RegionEndKey) > 0 {
		i -= len(m.RegionEndKey)
		copy(dAtA[i:], m.RegionEndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.RegionEndKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.RegionStartKey) > 0 {
		i -= len(m.RegionStartKey)
		copy(dAtA[i:], m.RegionStartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.RegionStartKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Crc64Xor != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Crc64Xor))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.CompressionType != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompressionType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.RangeLength != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.RangeLength))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.RangeOffset != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.RangeOffset))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.MinBeginTsInDefaultCf != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.MinBeginTsInDefaultCf))
		i--
		dAtA[i] = 0x78
	}
	if m.Length != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x70
	}
	if m.TableId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x68
	}
	if m.IsMeta {
		i--
		if m.IsMeta {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Type != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Cf) > 0 {
		i -= len(m.Cf)
		copy(dAtA[i:], m.Cf)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Cf)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x42
	}
	if m.RegionId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x38
	}
	if m.ResolvedTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ResolvedTs))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.MaxTs))
		i--
		dAtA[i] = 0x28
	}
	if m.MinTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.MinTs))
		i--
		dAtA[i] = 0x20
	}
	if m.NumberOfEntries != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.NumberOfEntries))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sha256) > 0 {
		i -= len(m.Sha256)
		copy(dAtA[i:], m.Sha256)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Sha256)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamBackupError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamBackupError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamBackupError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StoreId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.StoreId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorCode) > 0 {
		i -= len(m.ErrorCode)
		copy(dAtA[i:], m.ErrorCode)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.ErrorCode)))
		i--
		dAtA[i] = 0x12
	}
	if m.HappenAt != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.HappenAt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Span) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SpansOfFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpansOfFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpansOfFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogFileSubcompactionMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFileSubcompactionMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogFileSubcompactionMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.TableId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x58
	}
	if m.Ty != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Ty))
		i--
		dAtA[i] = 0x50
	}
	if len(m.MaxKey) > 0 {
		i -= len(m.MaxKey)
		copy(dAtA[i:], m.MaxKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.MaxKey)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MinKey) > 0 {
		i -= len(m.MinKey)
		copy(dAtA[i:], m.MinKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.MinKey)))
		i--
		dAtA[i] = 0x42
	}
	if m.CompactUntilTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompactUntilTs))
		i--
		dAtA[i] = 0x38
	}
	if m.CompactFromTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompactFromTs))
		i--
		dAtA[i] = 0x30
	}
	if m.InputMinTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.InputMinTs))
		i--
		dAtA[i] = 0x28
	}
	if m.InputMaxTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.InputMaxTs))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Cf) > 0 {
		i -= len(m.Cf)
		copy(dAtA[i:], m.Cf)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Cf)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RegionId != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.RegionId))
		i--
		dAtA[i] = 0x10
	}
	if m.Size_ != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogFileSubcompaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFileSubcompaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogFileSubcompaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegionMetaHints) > 0 {
		for iNdEx := len(m.RegionMetaHints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RegionMetaHints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SstOutputs) > 0 {
		for iNdEx := len(m.SstOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SstOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegionMetaHint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionMetaHint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionMetaHint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegionEpoch != nil {
		{
			size, err := m.RegionEpoch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBrpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogFileSubcompactions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFileSubcompactions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogFileSubcompactions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Subcompactions) > 0 {
		for iNdEx := len(m.Subcompactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subcompactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LogFileCompaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFileCompaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogFileCompaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GeneratedFiles) > 0 {
		i -= len(m.GeneratedFiles)
		copy(dAtA[i:], m.GeneratedFiles)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.GeneratedFiles)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ArtifactsHash != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.ArtifactsHash))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Artifacts) > 0 {
		i -= len(m.Artifacts)
		copy(dAtA[i:], m.Artifacts)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Artifacts)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Comments) > 0 {
		i -= len(m.Comments)
		copy(dAtA[i:], m.Comments)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Comments)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CompactionUntilTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompactionUntilTs))
		i--
		dAtA[i] = 0x10
	}
	if m.CompactionFromTs != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.CompactionFromTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetaEdit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaEdit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaEdit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DestructSelf {
		i--
		if m.DestructSelf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeleteLogicalFiles) > 0 {
		for iNdEx := len(m.DeleteLogicalFiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeleteLogicalFiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DeletePhysicalFiles) > 0 {
		for iNdEx := len(m.DeletePhysicalFiles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeletePhysicalFiles[iNdEx])
			copy(dAtA[i:], m.DeletePhysicalFiles[iNdEx])
			i = encodeVarintBrpb(dAtA, i, uint64(len(m.DeletePhysicalFiles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteSpansOfFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteSpansOfFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteSpansOfFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WholeFileLength != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.WholeFileLength))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Migration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Migration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Migration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintBrpb(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DestructPrefix) > 0 {
		for iNdEx := len(m.DestructPrefix) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DestructPrefix[iNdEx])
			copy(dAtA[i:], m.DestructPrefix[iNdEx])
			i = encodeVarintBrpb(dAtA, i, uint64(len(m.DestructPrefix[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Compactions) > 0 {
		for iNdEx := len(m.Compactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Compactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TruncatedTo != 0 {
		i = encodeVarintBrpb(dAtA, i, uint64(m.TruncatedTo))
		i--
		dAtA[i] = 0x10
	}
	if len(m.EditMeta) > 0 {
		for iNdEx := len(m.EditMeta) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EditMeta[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBrpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBrpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovBrpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PrepareSnapshotBackupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ty != 0 {
		n += 1 + sovBrpb(uint64(m.Ty))
	}
	if len(m.Regions) > 0 {
		for _, e := range m.Regions {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.LeaseInSeconds != 0 {
		n += 1 + sovBrpb(uint64(m.LeaseInSeconds))
	}
	return n
}

func (m *PrepareSnapshotBackupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ty != 0 {
		n += 1 + sovBrpb(uint64(m.Ty))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.LastLeaseIsValid {
		n += 2
	}
	return n
}

func (m *BackupMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovBrpb(uint64(m.ClusterId))
	}
	l = len(m.ClusterVersion)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.StartVersion != 0 {
		n += 1 + sovBrpb(uint64(m.StartVersion))
	}
	if m.EndVersion != 0 {
		n += 1 + sovBrpb(uint64(m.EndVersion))
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.IsRawKv {
		n += 2
	}
	if len(m.RawRanges) > 0 {
		for _, e := range m.RawRanges {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	l = len(m.Ddls)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.BrVersion)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovBrpb(uint64(m.Version))
	}
	if m.FileIndex != nil {
		l = m.FileIndex.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.SchemaIndex != nil {
		l = m.SchemaIndex.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.RawRangeIndex != nil {
		l = m.RawRangeIndex.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.DdlIndexes != nil {
		l = m.DdlIndexes.Size()
		n += 2 + l + sovBrpb(uint64(l))
	}
	l = len(m.BackupResult)
	if l > 0 {
		n += 2 + l + sovBrpb(uint64(l))
	}
	if m.ApiVersion != 0 {
		n += 2 + sovBrpb(uint64(m.ApiVersion))
	}
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 2 + l + sovBrpb(uint64(l))
		}
	}
	l = len(m.NewCollationsEnabled)
	if l > 0 {
		n += 2 + l + sovBrpb(uint64(l))
	}
	if m.IsTxnKv {
		n += 3
	}
	if len(m.DbMaps) > 0 {
		for _, e := range m.DbMaps {
			l = e.Size()
			n += 2 + l + sovBrpb(uint64(l))
		}
	}
	if m.Mode != 0 {
		n += 2 + sovBrpb(uint64(m.Mode))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 2 + l + sovBrpb(uint64(l))
		}
	}
	if m.BackupSize != 0 {
		n += 2 + sovBrpb(uint64(m.BackupSize))
	}
	return n
}

func (m *BackupRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Sha256)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovBrpb(uint64(m.StartVersion))
	}
	if m.EndVersion != 0 {
		n += 1 + sovBrpb(uint64(m.EndVersion))
	}
	if m.Crc64Xor != 0 {
		n += 1 + sovBrpb(uint64(m.Crc64Xor))
	}
	if m.TotalKvs != 0 {
		n += 1 + sovBrpb(uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovBrpb(uint64(m.TotalBytes))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovBrpb(uint64(m.Size_))
	}
	l = len(m.CipherIv)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *MetaFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MetaFiles) > 0 {
		for _, e := range m.MetaFiles {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.DataFiles) > 0 {
		for _, e := range m.DataFiles {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.RawRanges) > 0 {
		for _, e := range m.RawRanges {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.Ddls) > 0 {
		for _, b := range m.Ddls {
			l = len(b)
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.BackupRanges) > 0 {
		for _, e := range m.BackupRanges {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *PlacementPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *StatsBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhysicalId != 0 {
		n += 1 + sovBrpb(uint64(m.PhysicalId))
	}
	l = len(m.JsonTable)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *StatsFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *StatsFileIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Sha256)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.SizeEnc != 0 {
		n += 1 + sovBrpb(uint64(m.SizeEnc))
	}
	if m.SizeOri != 0 {
		n += 1 + sovBrpb(uint64(m.SizeOri))
	}
	l = len(m.CipherIv)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.InlineData)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Db)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Table)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Crc64Xor != 0 {
		n += 1 + sovBrpb(uint64(m.Crc64Xor))
	}
	if m.TotalKvs != 0 {
		n += 1 + sovBrpb(uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovBrpb(uint64(m.TotalBytes))
	}
	if m.TiflashReplicas != 0 {
		n += 1 + sovBrpb(uint64(m.TiflashReplicas))
	}
	l = len(m.Stats)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.StatsIndex) > 0 {
		for _, e := range m.StatsIndex {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *IDMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpstreamId != 0 {
		n += 1 + sovBrpb(uint64(m.UpstreamId))
	}
	if m.DownstreamId != 0 {
		n += 1 + sovBrpb(uint64(m.DownstreamId))
	}
	return n
}

func (m *PitrTableMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.IdMap != nil {
		l = m.IdMap.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *PitrDBMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.IdMap != nil {
		l = m.IdMap.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *RawRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *ClusterIDError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Current != 0 {
		n += 1 + sovBrpb(uint64(m.Current))
	}
	if m.Request != 0 {
		n += 1 + sovBrpb(uint64(m.Request))
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Detail != nil {
		n += m.Detail.Size()
	}
	return n
}

func (m *Error_ClusterIdError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterIdError != nil {
		l = m.ClusterIdError.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *Error_KvError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KvError != nil {
		l = m.KvError.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *Error_RegionError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StreamBackupTaskSecurityConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Encryption != nil {
		n += m.Encryption.Size()
	}
	return n
}

func (m *StreamBackupTaskSecurityConfig_PlaintextDataKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlaintextDataKey != nil {
		l = m.PlaintextDataKey.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StreamBackupTaskSecurityConfig_MasterKeyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MasterKeyConfig != nil {
		l = m.MasterKeyConfig.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *CipherInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CipherType != 0 {
		n += 1 + sovBrpb(uint64(m.CipherType))
	}
	l = len(m.CipherKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *MasterKeyConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncryptionType != 0 {
		n += 1 + sovBrpb(uint64(m.EncryptionType))
	}
	if len(m.MasterKeys) > 0 {
		for _, e := range m.MasterKeys {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *BackupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovBrpb(uint64(m.ClusterId))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovBrpb(uint64(m.StartVersion))
	}
	if m.EndVersion != 0 {
		n += 1 + sovBrpb(uint64(m.EndVersion))
	}
	if m.RateLimit != 0 {
		n += 1 + sovBrpb(uint64(m.RateLimit))
	}
	if m.Concurrency != 0 {
		n += 1 + sovBrpb(uint64(m.Concurrency))
	}
	if m.StorageBackend != nil {
		l = m.StorageBackend.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.IsRawKv {
		n += 2
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.CompressionType != 0 {
		n += 1 + sovBrpb(uint64(m.CompressionType))
	}
	if m.CompressionLevel != 0 {
		n += 1 + sovBrpb(uint64(m.CompressionLevel))
	}
	if m.CipherInfo != nil {
		l = m.CipherInfo.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.DstApiVersion != 0 {
		n += 1 + sovBrpb(uint64(m.DstApiVersion))
	}
	if len(m.SubRanges) > 0 {
		for _, e := range m.SubRanges {
			l = e.Size()
			n += 2 + l + sovBrpb(uint64(l))
		}
	}
	if m.ReplicaRead {
		n += 3
	}
	if m.Mode != 0 {
		n += 2 + sovBrpb(uint64(m.Mode))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 2 + l + sovBrpb(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 2 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *StreamBackupTaskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Storage != nil {
		l = m.Storage.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.StartTs != 0 {
		n += 1 + sovBrpb(uint64(m.StartTs))
	}
	if m.EndTs != 0 {
		n += 1 + sovBrpb(uint64(m.EndTs))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.TableFilter) > 0 {
		for _, s := range m.TableFilter {
			l = len(s)
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.CompressionType != 0 {
		n += 1 + sovBrpb(uint64(m.CompressionType))
	}
	if m.SecurityConfig != nil {
		l = m.SecurityConfig.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *StorageBackend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Backend != nil {
		n += m.Backend.Size()
	}
	return n
}

func (m *StorageBackend_Noop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Noop != nil {
		l = m.Noop.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_Local) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_S3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.S3 != nil {
		l = m.S3.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_Gcs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gcs != nil {
		l = m.Gcs.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_CloudDynamic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudDynamic != nil {
		l = m.CloudDynamic.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_Hdfs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hdfs != nil {
		l = m.Hdfs.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *StorageBackend_AzureBlobStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureBlobStorage != nil {
		l = m.AzureBlobStorage.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}
func (m *Noop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Local) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *S3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StorageClass)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Sse)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Acl)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.AccessKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.SecretAccessKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.ForcePathStyle {
		n += 2
	}
	l = len(m.SseKmsKeyId)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.RoleArn)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.ObjectLockEnabled {
		n += 2
	}
	l = len(m.SessionToken)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 2 + l + sovBrpb(uint64(l))
	}
	l = len(m.Profile)
	if l > 0 {
		n += 2 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *GCS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StorageClass)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.PredefinedAcl)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.CredentialsBlob)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *AzureCustomerKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptionKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EncryptionKeySha256)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *AzureBlobStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StorageClass)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.AccountName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.SharedKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.AccessSig)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EncryptionScope)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.EncryptionKey != nil {
		l = m.EncryptionKey.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *Bucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StorageClass)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *CloudDynamic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bucket != nil {
		l = m.Bucket.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.ProviderName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Attrs) > 0 {
		for k, v := range m.Attrs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBrpb(uint64(len(k))) + 1 + len(v) + sovBrpb(uint64(len(v)))
			n += mapEntrySize + 1 + sovBrpb(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HDFS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Remote)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *BackupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.ApiVersion != 0 {
		n += 1 + sovBrpb(uint64(m.ApiVersion))
	}
	return n
}

func (m *CleanupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *CleanupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Success {
		n += 2
	}
	return n
}

func (m *PrepareRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SaveToStorage {
		n += 2
	}
	return n
}

func (m *PrepareResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.UniqueId)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.CollectFileCount != 0 {
		n += 1 + sovBrpb(uint64(m.CollectFileCount))
	}
	if m.CollectFileSize != 0 {
		n += 1 + sovBrpb(uint64(m.CollectFileSize))
	}
	return n
}

func (m *CheckAdminRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CheckAdminResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.HasPendingAdmin {
		n += 2
	}
	return n
}

func (m *ExternalStorageRestoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageBackend != nil {
		l = m.StorageBackend.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.RestoreName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.ContentLength != 0 {
		n += 1 + sovBrpb(uint64(m.ContentLength))
	}
	return n
}

func (m *ExternalStorageRestoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ExternalStorageSaveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageBackend != nil {
		l = m.StorageBackend.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.ContentLength != 0 {
		n += 1 + sovBrpb(uint64(m.ContentLength))
	}
	return n
}

func (m *ExternalStorageSaveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.StoreId != 0 {
		n += 1 + sovBrpb(uint64(m.StoreId))
	}
	if m.ResolvedTs != 0 {
		n += 1 + sovBrpb(uint64(m.ResolvedTs))
	}
	if m.MaxTs != 0 {
		n += 1 + sovBrpb(uint64(m.MaxTs))
	}
	if m.MinTs != 0 {
		n += 1 + sovBrpb(uint64(m.MinTs))
	}
	if len(m.FileGroups) > 0 {
		for _, e := range m.FileGroups {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.MetaVersion != 0 {
		n += 1 + sovBrpb(uint64(m.MetaVersion))
	}
	return n
}

func (m *DataFileGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.DataFilesInfo) > 0 {
		for _, e := range m.DataFilesInfo {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.MinTs != 0 {
		n += 1 + sovBrpb(uint64(m.MinTs))
	}
	if m.MaxTs != 0 {
		n += 1 + sovBrpb(uint64(m.MaxTs))
	}
	if m.MinResolvedTs != 0 {
		n += 1 + sovBrpb(uint64(m.MinResolvedTs))
	}
	if m.Length != 0 {
		n += 1 + sovBrpb(uint64(m.Length))
	}
	return n
}

func (m *DataFileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sha256)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.NumberOfEntries != 0 {
		n += 1 + sovBrpb(uint64(m.NumberOfEntries))
	}
	if m.MinTs != 0 {
		n += 1 + sovBrpb(uint64(m.MinTs))
	}
	if m.MaxTs != 0 {
		n += 1 + sovBrpb(uint64(m.MaxTs))
	}
	if m.ResolvedTs != 0 {
		n += 1 + sovBrpb(uint64(m.ResolvedTs))
	}
	if m.RegionId != 0 {
		n += 1 + sovBrpb(uint64(m.RegionId))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovBrpb(uint64(m.Type))
	}
	if m.IsMeta {
		n += 2
	}
	if m.TableId != 0 {
		n += 1 + sovBrpb(uint64(m.TableId))
	}
	if m.Length != 0 {
		n += 1 + sovBrpb(uint64(m.Length))
	}
	if m.MinBeginTsInDefaultCf != 0 {
		n += 1 + sovBrpb(uint64(m.MinBeginTsInDefaultCf))
	}
	if m.RangeOffset != 0 {
		n += 2 + sovBrpb(uint64(m.RangeOffset))
	}
	if m.RangeLength != 0 {
		n += 2 + sovBrpb(uint64(m.RangeLength))
	}
	if m.CompressionType != 0 {
		n += 2 + sovBrpb(uint64(m.CompressionType))
	}
	if m.Crc64Xor != 0 {
		n += 2 + sovBrpb(uint64(m.Crc64Xor))
	}
	l = len(m.RegionStartKey)
	if l > 0 {
		n += 2 + l + sovBrpb(uint64(l))
	}
	l = len(m.RegionEndKey)
	if l > 0 {
		n += 2 + l + sovBrpb(uint64(l))
	}
	if len(m.RegionEpoch) > 0 {
		for _, e := range m.RegionEpoch {
			l = e.Size()
			n += 2 + l + sovBrpb(uint64(l))
		}
	}
	if m.FileEncryptionInfo != nil {
		l = m.FileEncryptionInfo.Size()
		n += 2 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *StreamBackupError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HappenAt != 0 {
		n += 1 + sovBrpb(uint64(m.HappenAt))
	}
	l = len(m.ErrorCode)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.StoreId != 0 {
		n += 1 + sovBrpb(uint64(m.StoreId))
	}
	return n
}

func (m *Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovBrpb(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovBrpb(uint64(m.Length))
	}
	return n
}

func (m *SpansOfFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *LogFileSubcompactionMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovBrpb(uint64(m.Size_))
	}
	if m.RegionId != 0 {
		n += 1 + sovBrpb(uint64(m.RegionId))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.InputMaxTs != 0 {
		n += 1 + sovBrpb(uint64(m.InputMaxTs))
	}
	if m.InputMinTs != 0 {
		n += 1 + sovBrpb(uint64(m.InputMinTs))
	}
	if m.CompactFromTs != 0 {
		n += 1 + sovBrpb(uint64(m.CompactFromTs))
	}
	if m.CompactUntilTs != 0 {
		n += 1 + sovBrpb(uint64(m.CompactUntilTs))
	}
	l = len(m.MinKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.MaxKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Ty != 0 {
		n += 1 + sovBrpb(uint64(m.Ty))
	}
	if m.TableId != 0 {
		n += 1 + sovBrpb(uint64(m.TableId))
	}
	if len(m.Sources) > 0 {
		for _, e := range m.Sources {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *LogFileSubcompaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.SstOutputs) > 0 {
		for _, e := range m.SstOutputs {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.RegionMetaHints) > 0 {
		for _, e := range m.RegionMetaHints {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *RegionMetaHint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.RegionEpoch != nil {
		l = m.RegionEpoch.Size()
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *LogFileSubcompactions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subcompactions) > 0 {
		for _, e := range m.Subcompactions {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	return n
}

func (m *LogFileCompaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompactionFromTs != 0 {
		n += 1 + sovBrpb(uint64(m.CompactionFromTs))
	}
	if m.CompactionUntilTs != 0 {
		n += 1 + sovBrpb(uint64(m.CompactionUntilTs))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Comments)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	l = len(m.Artifacts)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.ArtifactsHash != 0 {
		n += 1 + sovBrpb(uint64(m.ArtifactsHash))
	}
	l = len(m.GeneratedFiles)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	return n
}

func (m *MetaEdit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.DeletePhysicalFiles) > 0 {
		for _, s := range m.DeletePhysicalFiles {
			l = len(s)
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.DeleteLogicalFiles) > 0 {
		for _, e := range m.DeleteLogicalFiles {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.DestructSelf {
		n += 2
	}
	return n
}

func (m *DeleteSpansOfFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.WholeFileLength != 0 {
		n += 1 + sovBrpb(uint64(m.WholeFileLength))
	}
	return n
}

func (m *Migration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EditMeta) > 0 {
		for _, e := range m.EditMeta {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if m.TruncatedTo != 0 {
		n += 1 + sovBrpb(uint64(m.TruncatedTo))
	}
	if len(m.Compactions) > 0 {
		for _, e := range m.Compactions {
			l = e.Size()
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	if len(m.DestructPrefix) > 0 {
		for _, s := range m.DestructPrefix {
			l = len(s)
			n += 1 + l + sovBrpb(uint64(l))
		}
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovBrpb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovBrpb(uint64(m.Version))
	}
	return n
}

func sovBrpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBrpb(x uint64) (n int) {
	return sovBrpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PrepareSnapshotBackupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareSnapshotBackupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareSnapshotBackupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ty", wireType)
			}
			m.Ty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ty |= PrepareSnapshotBackupRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, &metapb.Region{})
			if err := m.Regions[len(m.Regions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseInSeconds", wireType)
			}
			m.LeaseInSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseInSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareSnapshotBackupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareSnapshotBackupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareSnapshotBackupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ty", wireType)
			}
			m.Ty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ty |= PrepareSnapshotBackupEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &metapb.Region{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &errorpb.Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLeaseIsValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastLeaseIsValid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndVersion", wireType)
			}
			m.EndVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &Schema{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRawKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRawKv = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawRanges = append(m.RawRanges, &RawRange{})
			if err := m.RawRanges[len(m.RawRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddls", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ddls = append(m.Ddls[:0], dAtA[iNdEx:postIndex]...)
			if m.Ddls == nil {
				m.Ddls = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileIndex == nil {
				m.FileIndex = &MetaFile{}
			}
			if err := m.FileIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchemaIndex == nil {
				m.SchemaIndex = &MetaFile{}
			}
			if err := m.SchemaIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawRangeIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RawRangeIndex == nil {
				m.RawRangeIndex = &MetaFile{}
			}
			if err := m.RawRangeIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlIndexes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DdlIndexes == nil {
				m.DdlIndexes = &MetaFile{}
			}
			if err := m.DdlIndexes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupResult", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupResult = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			m.ApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiVersion |= kvrpcpb.APIVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &PlacementPolicy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewCollationsEnabled", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewCollationsEnabled = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTxnKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTxnKv = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbMaps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbMaps = append(m.DbMaps, &PitrDBMap{})
			if err := m.DbMaps[len(m.DbMaps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= BackupMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &BackupRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupSize", wireType)
			}
			m.BackupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackupSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256 = append(m.Sha256[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha256 == nil {
				m.Sha256 = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndVersion", wireType)
			}
			m.EndVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc64Xor", wireType)
			}
			m.Crc64Xor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc64Xor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalKvs", wireType)
			}
			m.TotalKvs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalKvs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherIv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherIv = append(m.CipherIv[:0], dAtA[iNdEx:postIndex]...)
			if m.CipherIv == nil {
				m.CipherIv = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetaFiles = append(m.MetaFiles, &File{})
			if err := m.MetaFiles[len(m.MetaFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFiles = append(m.DataFiles, &File{})
			if err := m.DataFiles[len(m.DataFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &Schema{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawRanges = append(m.RawRanges, &RawRange{})
			if err := m.RawRanges[len(m.RawRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddls", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ddls = append(m.Ddls, make([]byte, postIndex-iNdEx))
			copy(m.Ddls[len(m.Ddls)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupRanges = append(m.BackupRanges, &BackupRange{})
			if err := m.BackupRanges[len(m.BackupRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlacementPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlacementPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = append(m.Info[:0], dAtA[iNdEx:postIndex]...)
			if m.Info == nil {
				m.Info = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalId", wireType)
			}
			m.PhysicalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhysicalId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonTable", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JsonTable = append(m.JsonTable[:0], dAtA[iNdEx:postIndex]...)
			if m.JsonTable == nil {
				m.JsonTable = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &StatsBlock{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatsFileIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatsFileIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatsFileIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256 = append(m.Sha256[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha256 == nil {
				m.Sha256 = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeEnc", wireType)
			}
			m.SizeEnc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeEnc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeOri", wireType)
			}
			m.SizeOri = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeOri |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherIv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherIv = append(m.CipherIv[:0], dAtA[iNdEx:postIndex]...)
			if m.CipherIv == nil {
				m.CipherIv = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineData = append(m.InlineData[:0], dAtA[iNdEx:postIndex]...)
			if m.InlineData == nil {
				m.InlineData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Db = append(m.Db[:0], dAtA[iNdEx:postIndex]...)
			if m.Db == nil {
				m.Db = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Table = append(m.Table[:0], dAtA[iNdEx:postIndex]...)
			if m.Table == nil {
				m.Table = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc64Xor", wireType)
			}
			m.Crc64Xor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc64Xor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalKvs", wireType)
			}
			m.TotalKvs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalKvs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TiflashReplicas", wireType)
			}
			m.TiflashReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TiflashReplicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats[:0], dAtA[iNdEx:postIndex]...)
			if m.Stats == nil {
				m.Stats = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatsIndex = append(m.StatsIndex, &StatsFileIndex{})
			if err := m.StatsIndex[len(m.StatsIndex)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamId", wireType)
			}
			m.UpstreamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpstreamId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownstreamId", wireType)
			}
			m.DownstreamId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownstreamId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PitrTableMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PitrTableMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PitrTableMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdMap == nil {
				m.IdMap = &IDMap{}
			}
			if err := m.IdMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &IDMap{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PitrDBMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PitrDBMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PitrDBMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdMap == nil {
				m.IdMap = &IDMap{}
			}
			if err := m.IdMap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &PitrTableMap{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterIDError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterIDError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterIDError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Current |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			m.Request = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Request |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIdError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClusterIDError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &Error_ClusterIdError{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &kvrpcpb.KeyError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &Error_KvError{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &errorpb.Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Detail = &Error_RegionError{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamBackupTaskSecurityConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamBackupTaskSecurityConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamBackupTaskSecurityConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaintextDataKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CipherInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Encryption = &StreamBackupTaskSecurityConfig_PlaintextDataKey{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterKeyConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MasterKeyConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Encryption = &StreamBackupTaskSecurityConfig_MasterKeyConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CipherInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CipherInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CipherInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherType", wireType)
			}
			m.CipherType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CipherType |= encryptionpb.EncryptionMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherKey = append(m.CipherKey[:0], dAtA[iNdEx:postIndex]...)
			if m.CipherKey == nil {
				m.CipherKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MasterKeyConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MasterKeyConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MasterKeyConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionType", wireType)
			}
			m.EncryptionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncryptionType |= encryptionpb.EncryptionMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterKeys = append(m.MasterKeys, &encryptionpb.MasterKey{})
			if err := m.MasterKeys[len(m.MasterKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndVersion", wireType)
			}
			m.EndVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RateLimit", wireType)
			}
			m.RateLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RateLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			m.Concurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Concurrency |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageBackend == nil {
				m.StorageBackend = &StorageBackend{}
			}
			if err := m.StorageBackend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRawKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRawKv = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionType", wireType)
			}
			m.CompressionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionType |= CompressionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionLevel", wireType)
			}
			m.CompressionLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CipherInfo == nil {
				m.CipherInfo = &CipherInfo{}
			}
			if err := m.CipherInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstApiVersion", wireType)
			}
			m.DstApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstApiVersion |= kvrpcpb.APIVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubRanges = append(m.SubRanges, &kvrpcpb.KeyRange{})
			if err := m.SubRanges[len(m.SubRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicaRead = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= BackupMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamBackupTaskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamBackupTaskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamBackupTaskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Storage == nil {
				m.Storage = &StorageBackend{}
			}
			if err := m.Storage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTs", wireType)
			}
			m.EndTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableFilter = append(m.TableFilter, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionType", wireType)
			}
			m.CompressionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionType |= CompressionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityConfig == nil {
				m.SecurityConfig = &StreamBackupTaskSecurityConfig{}
			}
			if err := m.SecurityConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageBackend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageBackend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageBackend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Noop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Noop{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_Noop{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Local{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_Local{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &S3{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_S3{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCS{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_Gcs{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudDynamic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudDynamic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_CloudDynamic{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HDFS{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_Hdfs{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureBlobStorage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureBlobStorage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Backend = &StorageBackend_AzureBlobStorage{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Noop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Noop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Noop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Local) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Local: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Local: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sse", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sse = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretAccessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretAccessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePathStyle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForcePathStyle = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SseKmsKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SseKmsKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleArn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectLockEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ObjectLockEnabled = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredefinedAcl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredefinedAcl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialsBlob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialsBlob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureCustomerKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureCustomerKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureCustomerKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKeySha256", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKeySha256 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureBlobStorage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureBlobStorage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureBlobStorage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharedKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessSig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessSig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionScope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionScope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionKey == nil {
				m.EncryptionKey = &AzureCustomerKey{}
			}
			if err := m.EncryptionKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudDynamic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudDynamic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudDynamic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bucket == nil {
				m.Bucket = &Bucket{}
			}
			if err := m.Bucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attrs == nil {
				m.Attrs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBrpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBrpb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBrpb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBrpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBrpb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBrpb
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBrpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBrpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attrs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HDFS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDFS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDFS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			m.ApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiVersion |= kvrpcpb.APIVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaveToStorage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaveToStorage = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectFileCount", wireType)
			}
			m.CollectFileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectFileCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectFileSize", wireType)
			}
			m.CollectFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectFileSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckAdminRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckAdminRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckAdminRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckAdminResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckAdminResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckAdminResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &metapb.Region{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasPendingAdmin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasPendingAdmin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorageRestoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalStorageRestoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalStorageRestoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageBackend == nil {
				m.StorageBackend = &StorageBackend{}
			}
			if err := m.StorageBackend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RestoreName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentLength", wireType)
			}
			m.ContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorageRestoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalStorageRestoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalStorageRestoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorageSaveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalStorageSaveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalStorageSaveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageBackend == nil {
				m.StorageBackend = &StorageBackend{}
			}
			if err := m.StorageBackend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentLength", wireType)
			}
			m.ContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalStorageSaveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalStorageSaveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalStorageSaveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &DataFileInfo{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedTs", wireType)
			}
			m.ResolvedTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolvedTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			m.MaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTs", wireType)
			}
			m.MinTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileGroups = append(m.FileGroups, &DataFileGroup{})
			if err := m.FileGroups[len(m.FileGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaVersion", wireType)
			}
			m.MetaVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaVersion |= MetaVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataFileGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFileGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFileGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilesInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilesInfo = append(m.DataFilesInfo, &DataFileInfo{})
			if err := m.DataFilesInfo[len(m.DataFilesInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTs", wireType)
			}
			m.MinTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			m.MaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinResolvedTs", wireType)
			}
			m.MinResolvedTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinResolvedTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataFileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256 = append(m.Sha256[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha256 == nil {
				m.Sha256 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfEntries", wireType)
			}
			m.NumberOfEntries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfEntries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTs", wireType)
			}
			m.MinTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			m.MaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedTs", wireType)
			}
			m.ResolvedTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolvedTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMeta", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMeta = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBeginTsInDefaultCf", wireType)
			}
			m.MinBeginTsInDefaultCf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinBeginTsInDefaultCf |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeOffset", wireType)
			}
			m.RangeOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeLength", wireType)
			}
			m.RangeLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionType", wireType)
			}
			m.CompressionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionType |= CompressionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc64Xor", wireType)
			}
			m.Crc64Xor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc64Xor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionStartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionStartKey = append(m.RegionStartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RegionStartKey == nil {
				m.RegionStartKey = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionEndKey = append(m.RegionEndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RegionEndKey == nil {
				m.RegionEndKey = []byte{}
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionEpoch = append(m.RegionEpoch, &metapb.RegionEpoch{})
			if err := m.RegionEpoch[len(m.RegionEpoch)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileEncryptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileEncryptionInfo == nil {
				m.FileEncryptionInfo = &encryptionpb.FileEncryptionInfo{}
			}
			if err := m.FileEncryptionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamBackupError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamBackupError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamBackupError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HappenAt", wireType)
			}
			m.HappenAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HappenAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreId", wireType)
			}
			m.StoreId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpansOfFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpansOfFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpansOfFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, &Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFileSubcompactionMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFileSubcompactionMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFileSubcompactionMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMaxTs", wireType)
			}
			m.InputMaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputMaxTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMinTs", wireType)
			}
			m.InputMinTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputMinTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactFromTs", wireType)
			}
			m.CompactFromTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactFromTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactUntilTs", wireType)
			}
			m.CompactUntilTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactUntilTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinKey = append(m.MinKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MinKey == nil {
				m.MinKey = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxKey = append(m.MaxKey[:0], dAtA[iNdEx:postIndex]...)
			if m.MaxKey == nil {
				m.MaxKey = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ty", wireType)
			}
			m.Ty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ty |= FileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, &SpansOfFile{})
			if err := m.Sources[len(m.Sources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFileSubcompaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFileSubcompaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFileSubcompaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &LogFileSubcompactionMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SstOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SstOutputs = append(m.SstOutputs, &File{})
			if err := m.SstOutputs[len(m.SstOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionMetaHints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionMetaHints = append(m.RegionMetaHints, &RegionMetaHint{})
			if err := m.RegionMetaHints[len(m.RegionMetaHints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionMetaHint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionMetaHint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionMetaHint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionEpoch == nil {
				m.RegionEpoch = &metapb.RegionEpoch{}
			}
			if err := m.RegionEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFileSubcompactions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFileSubcompactions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFileSubcompactions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcompactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subcompactions = append(m.Subcompactions, &LogFileSubcompaction{})
			if err := m.Subcompactions[len(m.Subcompactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFileCompaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFileCompaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFileCompaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionFromTs", wireType)
			}
			m.CompactionFromTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionFromTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactionUntilTs", wireType)
			}
			m.CompactionUntilTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactionUntilTs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifacts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifacts = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArtifactsHash", wireType)
			}
			m.ArtifactsHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArtifactsHash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedFiles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedFiles = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaEdit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaEdit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaEdit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletePhysicalFiles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeletePhysicalFiles = append(m.DeletePhysicalFiles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteLogicalFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeleteLogicalFiles = append(m.DeleteLogicalFiles, &DeleteSpansOfFile{})
			if err := m.DeleteLogicalFiles[len(m.DeleteLogicalFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestructSelf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DestructSelf = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteSpansOfFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteSpansOfFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteSpansOfFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, &Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WholeFileLength", wireType)
			}
			m.WholeFileLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WholeFileLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Migration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Migration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Migration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditMeta = append(m.EditMeta, &MetaEdit{})
			if err := m.EditMeta[len(m.EditMeta)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncatedTo", wireType)
			}
			m.TruncatedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TruncatedTo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compactions = append(m.Compactions, &LogFileCompaction{})
			if err := m.Compactions[len(m.Compactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestructPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestructPrefix = append(m.DestructPrefix, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBrpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBrpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= MigrationVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBrpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBrpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBrpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBrpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBrpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBrpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBrpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBrpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBrpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBrpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBrpb = fmt.Errorf("proto: unexpected end of group")
)
