// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: import_sstpb.proto

/*
Package import_sstpb is a generated protocol buffer package.

It is generated from these files:

	import_sstpb.proto

It has these top-level messages:

	SwitchModeRequest
	SwitchModeResponse
	GetModeRequest
	GetModeResponse
	Range
	SSTMeta
	RewriteRule
	UploadRequest
	UploadResponse
	IngestRequest
	MultiIngestRequest
	IngestResponse
	CompactRequest
	CompactResponse
	DownloadRequest
	Error
	DownloadResponse
	SetDownloadSpeedLimitRequest
	SetDownloadSpeedLimitResponse
	Pair
	WriteBatch
	WriteRequest
	WriteResponse
	RawWriteBatch
	RawWriteRequest
	RawWriteResponse
	DuplicateDetectRequest
	KvPair
	DuplicateDetectResponse
	KVMeta
	ApplyRequest
	ApplyResponse
	ClearRequest
	ClearResponse
*/
package import_sstpb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"
	metapb "github.com/pingcap/kvproto/pkg/metapb"

	errorpb "github.com/pingcap/kvproto/pkg/errorpb"

	kvrpcpb "github.com/pingcap/kvproto/pkg/kvrpcpb"

	_ "github.com/gogo/protobuf/gogoproto"

	backup "github.com/pingcap/kvproto/pkg/brpb"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SwitchMode int32

const (
	SwitchMode_Normal SwitchMode = 0
	SwitchMode_Import SwitchMode = 1
)

var SwitchMode_name = map[int32]string{
	0: "Normal",
	1: "Import",
}
var SwitchMode_value = map[string]int32{
	"Normal": 0,
	"Import": 1,
}

func (x SwitchMode) String() string {
	return proto.EnumName(SwitchMode_name, int32(x))
}
func (SwitchMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{0} }

type DownloadRequestType int32

const (
	// For the compatibility with old version of TiDBs
	DownloadRequestType_Legacy DownloadRequestType = 0
	// For the TiDBs with newer versions that support keyspace feature.
	DownloadRequestType_Keyspace DownloadRequestType = 1
)

var DownloadRequestType_name = map[int32]string{
	0: "Legacy",
	1: "Keyspace",
}
var DownloadRequestType_value = map[string]int32{
	"Legacy":   0,
	"Keyspace": 1,
}

func (x DownloadRequestType) String() string {
	return proto.EnumName(DownloadRequestType_name, int32(x))
}
func (DownloadRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImportSstpb, []int{1}
}

type Pair_OP int32

const (
	Pair_Put    Pair_OP = 0
	Pair_Delete Pair_OP = 1
)

var Pair_OP_name = map[int32]string{
	0: "Put",
	1: "Delete",
}
var Pair_OP_value = map[string]int32{
	"Put":    0,
	"Delete": 1,
}

func (x Pair_OP) String() string {
	return proto.EnumName(Pair_OP_name, int32(x))
}
func (Pair_OP) EnumDescriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{19, 0} }

type SwitchModeRequest struct {
	Mode   SwitchMode `protobuf:"varint,1,opt,name=mode,proto3,enum=import_sstpb.SwitchMode" json:"mode,omitempty"`
	Ranges []*Range   `protobuf:"bytes,2,rep,name=ranges" json:"ranges,omitempty"`
}

func (m *SwitchModeRequest) Reset()                    { *m = SwitchModeRequest{} }
func (m *SwitchModeRequest) String() string            { return proto.CompactTextString(m) }
func (*SwitchModeRequest) ProtoMessage()               {}
func (*SwitchModeRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{0} }

func (m *SwitchModeRequest) GetMode() SwitchMode {
	if m != nil {
		return m.Mode
	}
	return SwitchMode_Normal
}

func (m *SwitchModeRequest) GetRanges() []*Range {
	if m != nil {
		return m.Ranges
	}
	return nil
}

type SwitchModeResponse struct {
}

func (m *SwitchModeResponse) Reset()                    { *m = SwitchModeResponse{} }
func (m *SwitchModeResponse) String() string            { return proto.CompactTextString(m) }
func (*SwitchModeResponse) ProtoMessage()               {}
func (*SwitchModeResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{1} }

type GetModeRequest struct {
}

func (m *GetModeRequest) Reset()                    { *m = GetModeRequest{} }
func (m *GetModeRequest) String() string            { return proto.CompactTextString(m) }
func (*GetModeRequest) ProtoMessage()               {}
func (*GetModeRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{2} }

type GetModeResponse struct {
	Mode SwitchMode `protobuf:"varint,1,opt,name=mode,proto3,enum=import_sstpb.SwitchMode" json:"mode,omitempty"`
}

func (m *GetModeResponse) Reset()                    { *m = GetModeResponse{} }
func (m *GetModeResponse) String() string            { return proto.CompactTextString(m) }
func (*GetModeResponse) ProtoMessage()               {}
func (*GetModeResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{3} }

func (m *GetModeResponse) GetMode() SwitchMode {
	if m != nil {
		return m.Mode
	}
	return SwitchMode_Normal
}

type Range struct {
	Start []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	End   []byte `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *Range) Reset()                    { *m = Range{} }
func (m *Range) String() string            { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()               {}
func (*Range) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{4} }

func (m *Range) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Range) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

type SSTMeta struct {
	Uuid            []byte              `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Range           *Range              `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
	Crc32           uint32              `protobuf:"varint,3,opt,name=crc32,proto3" json:"crc32,omitempty"`
	Length          uint64              `protobuf:"varint,4,opt,name=length,proto3" json:"length,omitempty"`
	CfName          string              `protobuf:"bytes,5,opt,name=cf_name,json=cfName,proto3" json:"cf_name,omitempty"`
	RegionId        uint64              `protobuf:"varint,6,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	RegionEpoch     *metapb.RegionEpoch `protobuf:"bytes,7,opt,name=region_epoch,json=regionEpoch" json:"region_epoch,omitempty"`
	EndKeyExclusive bool                `protobuf:"varint,8,opt,name=end_key_exclusive,json=endKeyExclusive,proto3" json:"end_key_exclusive,omitempty"`
	// total_kvs and total_bytes is equivalent to PD's approximate_keys and approximate_size
	// set these values can save time from tikv upload keys and size to PD through Heartbeat.
	TotalKvs   uint64 `protobuf:"varint,9,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes uint64 `protobuf:"varint,10,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion kvrpcpb.APIVersion `protobuf:"varint,11,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// cipher_iv is used to encrypt/decrypt sst
	CipherIv []byte `protobuf:"bytes,12,opt,name=cipher_iv,json=cipherIv,proto3" json:"cipher_iv,omitempty"`
}

func (m *SSTMeta) Reset()                    { *m = SSTMeta{} }
func (m *SSTMeta) String() string            { return proto.CompactTextString(m) }
func (*SSTMeta) ProtoMessage()               {}
func (*SSTMeta) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{5} }

func (m *SSTMeta) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *SSTMeta) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *SSTMeta) GetCrc32() uint32 {
	if m != nil {
		return m.Crc32
	}
	return 0
}

func (m *SSTMeta) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SSTMeta) GetCfName() string {
	if m != nil {
		return m.CfName
	}
	return ""
}

func (m *SSTMeta) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *SSTMeta) GetRegionEpoch() *metapb.RegionEpoch {
	if m != nil {
		return m.RegionEpoch
	}
	return nil
}

func (m *SSTMeta) GetEndKeyExclusive() bool {
	if m != nil {
		return m.EndKeyExclusive
	}
	return false
}

func (m *SSTMeta) GetTotalKvs() uint64 {
	if m != nil {
		return m.TotalKvs
	}
	return 0
}

func (m *SSTMeta) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *SSTMeta) GetApiVersion() kvrpcpb.APIVersion {
	if m != nil {
		return m.ApiVersion
	}
	return kvrpcpb.APIVersion_V1
}

func (m *SSTMeta) GetCipherIv() []byte {
	if m != nil {
		return m.CipherIv
	}
	return nil
}

// A rewrite rule is applied on the *encoded* keys (the internal storage
// representation).
type RewriteRule struct {
	OldKeyPrefix []byte `protobuf:"bytes,1,opt,name=old_key_prefix,json=oldKeyPrefix,proto3" json:"old_key_prefix,omitempty"`
	NewKeyPrefix []byte `protobuf:"bytes,2,opt,name=new_key_prefix,json=newKeyPrefix,proto3" json:"new_key_prefix,omitempty"`
	NewTimestamp uint64 `protobuf:"varint,3,opt,name=new_timestamp,json=newTimestamp,proto3" json:"new_timestamp,omitempty"`
}

func (m *RewriteRule) Reset()                    { *m = RewriteRule{} }
func (m *RewriteRule) String() string            { return proto.CompactTextString(m) }
func (*RewriteRule) ProtoMessage()               {}
func (*RewriteRule) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{6} }

func (m *RewriteRule) GetOldKeyPrefix() []byte {
	if m != nil {
		return m.OldKeyPrefix
	}
	return nil
}

func (m *RewriteRule) GetNewKeyPrefix() []byte {
	if m != nil {
		return m.NewKeyPrefix
	}
	return nil
}

func (m *RewriteRule) GetNewTimestamp() uint64 {
	if m != nil {
		return m.NewTimestamp
	}
	return 0
}

type UploadRequest struct {
	// Types that are valid to be assigned to Chunk:
	//	*UploadRequest_Meta
	//	*UploadRequest_Data
	Chunk isUploadRequest_Chunk `protobuf_oneof:"chunk"`
}

func (m *UploadRequest) Reset()                    { *m = UploadRequest{} }
func (m *UploadRequest) String() string            { return proto.CompactTextString(m) }
func (*UploadRequest) ProtoMessage()               {}
func (*UploadRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{7} }

type isUploadRequest_Chunk interface {
	isUploadRequest_Chunk()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UploadRequest_Meta struct {
	Meta *SSTMeta `protobuf:"bytes,1,opt,name=meta,oneof"`
}
type UploadRequest_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*UploadRequest_Meta) isUploadRequest_Chunk() {}
func (*UploadRequest_Data) isUploadRequest_Chunk() {}

func (m *UploadRequest) GetChunk() isUploadRequest_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *UploadRequest) GetMeta() *SSTMeta {
	if x, ok := m.GetChunk().(*UploadRequest_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *UploadRequest) GetData() []byte {
	if x, ok := m.GetChunk().(*UploadRequest_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UploadRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UploadRequest_OneofMarshaler, _UploadRequest_OneofUnmarshaler, _UploadRequest_OneofSizer, []interface{}{
		(*UploadRequest_Meta)(nil),
		(*UploadRequest_Data)(nil),
	}
}

func _UploadRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UploadRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *UploadRequest_Meta:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Meta); err != nil {
			return err
		}
	case *UploadRequest_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Data)
	case nil:
	default:
		return fmt.Errorf("UploadRequest.Chunk has unexpected type %T", x)
	}
	return nil
}

func _UploadRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UploadRequest)
	switch tag {
	case 1: // chunk.meta
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SSTMeta)
		err := b.DecodeMessage(msg)
		m.Chunk = &UploadRequest_Meta{msg}
		return true, err
	case 2: // chunk.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Chunk = &UploadRequest_Data{x}
		return true, err
	default:
		return false, nil
	}
}

func _UploadRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UploadRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *UploadRequest_Meta:
		s := proto.Size(x.Meta)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UploadRequest_Data:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Data)))
		n += len(x.Data)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type UploadResponse struct {
}

func (m *UploadResponse) Reset()                    { *m = UploadResponse{} }
func (m *UploadResponse) String() string            { return proto.CompactTextString(m) }
func (*UploadResponse) ProtoMessage()               {}
func (*UploadResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{8} }

type IngestRequest struct {
	Context *kvrpcpb.Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Sst     *SSTMeta         `protobuf:"bytes,2,opt,name=sst" json:"sst,omitempty"`
}

func (m *IngestRequest) Reset()                    { *m = IngestRequest{} }
func (m *IngestRequest) String() string            { return proto.CompactTextString(m) }
func (*IngestRequest) ProtoMessage()               {}
func (*IngestRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{9} }

func (m *IngestRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *IngestRequest) GetSst() *SSTMeta {
	if m != nil {
		return m.Sst
	}
	return nil
}

type MultiIngestRequest struct {
	Context *kvrpcpb.Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Ssts    []*SSTMeta       `protobuf:"bytes,2,rep,name=ssts" json:"ssts,omitempty"`
}

func (m *MultiIngestRequest) Reset()                    { *m = MultiIngestRequest{} }
func (m *MultiIngestRequest) String() string            { return proto.CompactTextString(m) }
func (*MultiIngestRequest) ProtoMessage()               {}
func (*MultiIngestRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{10} }

func (m *MultiIngestRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *MultiIngestRequest) GetSsts() []*SSTMeta {
	if m != nil {
		return m.Ssts
	}
	return nil
}

type IngestResponse struct {
	Error *errorpb.Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *IngestResponse) Reset()                    { *m = IngestResponse{} }
func (m *IngestResponse) String() string            { return proto.CompactTextString(m) }
func (*IngestResponse) ProtoMessage()               {}
func (*IngestResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{11} }

func (m *IngestResponse) GetError() *errorpb.Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type CompactRequest struct {
	// Compact files in the range and above the output level.
	// Compact all files if the range is not specified.
	// Compact all files to the bottommost level if the output level is -1.
	Range       *Range           `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	OutputLevel int32            `protobuf:"varint,2,opt,name=output_level,json=outputLevel,proto3" json:"output_level,omitempty"`
	Context     *kvrpcpb.Context `protobuf:"bytes,3,opt,name=context" json:"context,omitempty"`
}

func (m *CompactRequest) Reset()                    { *m = CompactRequest{} }
func (m *CompactRequest) String() string            { return proto.CompactTextString(m) }
func (*CompactRequest) ProtoMessage()               {}
func (*CompactRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{12} }

func (m *CompactRequest) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *CompactRequest) GetOutputLevel() int32 {
	if m != nil {
		return m.OutputLevel
	}
	return 0
}

func (m *CompactRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

type CompactResponse struct {
}

func (m *CompactResponse) Reset()                    { *m = CompactResponse{} }
func (m *CompactResponse) String() string            { return proto.CompactTextString(m) }
func (*CompactResponse) ProtoMessage()               {}
func (*CompactResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{13} }

type DownloadRequest struct {
	// The SST meta used to identify the downloaded file.
	// Must be the same among all nodes in the same Raft group.
	// Note: the "crc32" and "cf_name" fields are ignored in this request,
	// and the "range" field represents the closed key range after rewrite
	// (as origin keys in encoded representation).
	Sst SSTMeta `protobuf:"bytes,2,opt,name=sst" json:"sst"`
	// The file name of the SST file.
	Name string `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
	// Performs a key prefix rewrite after downloading the SST file.
	// All keys in the SST will be rewritten as:
	//
	//  new_key = new_key_prefix + old_key[len(old_key_prefix)..]
	//
	// When used for TiDB, rewriting the prefix changes the table ID. Please
	// note that key-rewrite is applied on the origin keys in encoded
	// representation (the SST itself should still use data keys in encoded
	// representation).
	//
	// You need to ensure that the keys before and after rewriting are in the
	// same order, otherwise the RPC request will fail.
	RewriteRule    RewriteRule            `protobuf:"bytes,13,opt,name=rewrite_rule,json=rewriteRule" json:"rewrite_rule"`
	StorageBackend *backup.StorageBackend `protobuf:"bytes,14,opt,name=storage_backend,json=storageBackend" json:"storage_backend,omitempty"`
	// The identity for the stroage backend.
	// When this field presents, the storage would be cached.
	// If there is a cached storage, TiKV would use it driectly.
	StorageCacheId string `protobuf:"bytes,17,opt,name=storage_cache_id,json=storageCacheId,proto3" json:"storage_cache_id,omitempty"`
	IsRawKv        bool   `protobuf:"varint,15,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	// cipher_info is used to decrypt sst when download sst
	CipherInfo *backup.CipherInfo `protobuf:"bytes,16,opt,name=cipher_info,json=cipherInfo" json:"cipher_info,omitempty"`
	// The type of the download request.
	RequestType DownloadRequestType `protobuf:"varint,18,opt,name=request_type,json=requestType,proto3,enum=import_sstpb.DownloadRequestType" json:"request_type,omitempty"`
	Context     *kvrpcpb.Context    `protobuf:"bytes,19,opt,name=context" json:"context,omitempty"`
}

func (m *DownloadRequest) Reset()                    { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string            { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()               {}
func (*DownloadRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{14} }

func (m *DownloadRequest) GetSst() SSTMeta {
	if m != nil {
		return m.Sst
	}
	return SSTMeta{}
}

func (m *DownloadRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DownloadRequest) GetRewriteRule() RewriteRule {
	if m != nil {
		return m.RewriteRule
	}
	return RewriteRule{}
}

func (m *DownloadRequest) GetStorageBackend() *backup.StorageBackend {
	if m != nil {
		return m.StorageBackend
	}
	return nil
}

func (m *DownloadRequest) GetStorageCacheId() string {
	if m != nil {
		return m.StorageCacheId
	}
	return ""
}

func (m *DownloadRequest) GetIsRawKv() bool {
	if m != nil {
		return m.IsRawKv
	}
	return false
}

func (m *DownloadRequest) GetCipherInfo() *backup.CipherInfo {
	if m != nil {
		return m.CipherInfo
	}
	return nil
}

func (m *DownloadRequest) GetRequestType() DownloadRequestType {
	if m != nil {
		return m.RequestType
	}
	return DownloadRequestType_Legacy
}

func (m *DownloadRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

// For now it is just used for distinguishing the error of the request with the error
// of gRPC, add more concrete types if it is necessary later.
type Error struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// We meet some internal errors of the store.
	StoreError *errorpb.Error `protobuf:"bytes,2,opt,name=store_error,json=storeError" json:"store_error,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{15} }

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetStoreError() *errorpb.Error {
	if m != nil {
		return m.StoreError
	}
	return nil
}

type DownloadResponse struct {
	// The actual key range (after rewrite) of the downloaded SST. The range is
	// inclusive in both ends.
	Range Range `protobuf:"bytes,1,opt,name=range" json:"range"`
	// Whether the SST is empty. An empty SST is prohibited in TiKV, do not
	// ingest if this field is true.
	// (Deprecated, should be replaced by checking `length == 0` in the future)
	IsEmpty bool   `protobuf:"varint,2,opt,name=is_empty,json=isEmpty,proto3" json:"is_empty,omitempty"`
	Error   *Error `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
	// The CRC32 checksum of the rewritten SST file (implementation can return
	// zero, indicating the CRC32 was not calculated).
	Crc32 uint32 `protobuf:"varint,4,opt,name=crc32,proto3" json:"crc32,omitempty"`
	// The actual length of the rewritten SST file.
	Length uint64 `protobuf:"varint,5,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *DownloadResponse) Reset()                    { *m = DownloadResponse{} }
func (m *DownloadResponse) String() string            { return proto.CompactTextString(m) }
func (*DownloadResponse) ProtoMessage()               {}
func (*DownloadResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{16} }

func (m *DownloadResponse) GetRange() Range {
	if m != nil {
		return m.Range
	}
	return Range{}
}

func (m *DownloadResponse) GetIsEmpty() bool {
	if m != nil {
		return m.IsEmpty
	}
	return false
}

func (m *DownloadResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *DownloadResponse) GetCrc32() uint32 {
	if m != nil {
		return m.Crc32
	}
	return 0
}

func (m *DownloadResponse) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

type SetDownloadSpeedLimitRequest struct {
	// The download speed limit (bytes/second). Set to 0 for unlimited speed.
	SpeedLimit uint64 `protobuf:"varint,1,opt,name=speed_limit,json=speedLimit,proto3" json:"speed_limit,omitempty"`
}

func (m *SetDownloadSpeedLimitRequest) Reset()         { *m = SetDownloadSpeedLimitRequest{} }
func (m *SetDownloadSpeedLimitRequest) String() string { return proto.CompactTextString(m) }
func (*SetDownloadSpeedLimitRequest) ProtoMessage()    {}
func (*SetDownloadSpeedLimitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorImportSstpb, []int{17}
}

func (m *SetDownloadSpeedLimitRequest) GetSpeedLimit() uint64 {
	if m != nil {
		return m.SpeedLimit
	}
	return 0
}

type SetDownloadSpeedLimitResponse struct {
}

func (m *SetDownloadSpeedLimitResponse) Reset()         { *m = SetDownloadSpeedLimitResponse{} }
func (m *SetDownloadSpeedLimitResponse) String() string { return proto.CompactTextString(m) }
func (*SetDownloadSpeedLimitResponse) ProtoMessage()    {}
func (*SetDownloadSpeedLimitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorImportSstpb, []int{18}
}

type Pair struct {
	Key   []byte  `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte  `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Op    Pair_OP `protobuf:"varint,3,opt,name=op,proto3,enum=import_sstpb.Pair_OP" json:"op,omitempty"`
}

func (m *Pair) Reset()                    { *m = Pair{} }
func (m *Pair) String() string            { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()               {}
func (*Pair) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{19} }

func (m *Pair) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Pair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Pair) GetOp() Pair_OP {
	if m != nil {
		return m.Op
	}
	return Pair_Put
}

type WriteBatch struct {
	CommitTs uint64  `protobuf:"varint,1,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	Pairs    []*Pair `protobuf:"bytes,2,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *WriteBatch) Reset()                    { *m = WriteBatch{} }
func (m *WriteBatch) String() string            { return proto.CompactTextString(m) }
func (*WriteBatch) ProtoMessage()               {}
func (*WriteBatch) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{20} }

func (m *WriteBatch) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *WriteBatch) GetPairs() []*Pair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type WriteRequest struct {
	// Types that are valid to be assigned to Chunk:
	//	*WriteRequest_Meta
	//	*WriteRequest_Batch
	Chunk   isWriteRequest_Chunk `protobuf_oneof:"chunk"`
	Context *kvrpcpb.Context     `protobuf:"bytes,3,opt,name=context" json:"context,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{21} }

type isWriteRequest_Chunk interface {
	isWriteRequest_Chunk()
	MarshalTo([]byte) (int, error)
	Size() int
}

type WriteRequest_Meta struct {
	Meta *SSTMeta `protobuf:"bytes,1,opt,name=meta,oneof"`
}
type WriteRequest_Batch struct {
	Batch *WriteBatch `protobuf:"bytes,2,opt,name=batch,oneof"`
}

func (*WriteRequest_Meta) isWriteRequest_Chunk()  {}
func (*WriteRequest_Batch) isWriteRequest_Chunk() {}

func (m *WriteRequest) GetChunk() isWriteRequest_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *WriteRequest) GetMeta() *SSTMeta {
	if x, ok := m.GetChunk().(*WriteRequest_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *WriteRequest) GetBatch() *WriteBatch {
	if x, ok := m.GetChunk().(*WriteRequest_Batch); ok {
		return x.Batch
	}
	return nil
}

func (m *WriteRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WriteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WriteRequest_OneofMarshaler, _WriteRequest_OneofUnmarshaler, _WriteRequest_OneofSizer, []interface{}{
		(*WriteRequest_Meta)(nil),
		(*WriteRequest_Batch)(nil),
	}
}

func _WriteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WriteRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *WriteRequest_Meta:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Meta); err != nil {
			return err
		}
	case *WriteRequest_Batch:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Batch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("WriteRequest.Chunk has unexpected type %T", x)
	}
	return nil
}

func _WriteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WriteRequest)
	switch tag {
	case 1: // chunk.meta
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SSTMeta)
		err := b.DecodeMessage(msg)
		m.Chunk = &WriteRequest_Meta{msg}
		return true, err
	case 2: // chunk.batch
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WriteBatch)
		err := b.DecodeMessage(msg)
		m.Chunk = &WriteRequest_Batch{msg}
		return true, err
	default:
		return false, nil
	}
}

func _WriteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WriteRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *WriteRequest_Meta:
		s := proto.Size(x.Meta)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WriteRequest_Batch:
		s := proto.Size(x.Batch)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type WriteResponse struct {
	Error *Error     `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Metas []*SSTMeta `protobuf:"bytes,2,rep,name=metas" json:"metas,omitempty"`
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (m *WriteResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{22} }

func (m *WriteResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *WriteResponse) GetMetas() []*SSTMeta {
	if m != nil {
		return m.Metas
	}
	return nil
}

type RawWriteBatch struct {
	Ttl   uint64  `protobuf:"varint,1,opt,name=ttl,proto3" json:"ttl,omitempty"`
	Pairs []*Pair `protobuf:"bytes,2,rep,name=pairs" json:"pairs,omitempty"`
	// To be compatible with the key encoding of API V2.
	// This field should be generated from the client instead of the server,
	// since the message will be send to all the replicas of a region.
	// Otherwise, the underlying data generated by the server would be inconsistent which is hard to scale
	// for other features like MVCC over RawKV.
	Ts uint64 `protobuf:"varint,3,opt,name=ts,proto3" json:"ts,omitempty"`
}

func (m *RawWriteBatch) Reset()                    { *m = RawWriteBatch{} }
func (m *RawWriteBatch) String() string            { return proto.CompactTextString(m) }
func (*RawWriteBatch) ProtoMessage()               {}
func (*RawWriteBatch) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{23} }

func (m *RawWriteBatch) GetTtl() uint64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *RawWriteBatch) GetPairs() []*Pair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func (m *RawWriteBatch) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

type RawWriteRequest struct {
	// Types that are valid to be assigned to Chunk:
	//	*RawWriteRequest_Meta
	//	*RawWriteRequest_Batch
	Chunk   isRawWriteRequest_Chunk `protobuf_oneof:"chunk"`
	Context *kvrpcpb.Context        `protobuf:"bytes,3,opt,name=context" json:"context,omitempty"`
}

func (m *RawWriteRequest) Reset()                    { *m = RawWriteRequest{} }
func (m *RawWriteRequest) String() string            { return proto.CompactTextString(m) }
func (*RawWriteRequest) ProtoMessage()               {}
func (*RawWriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{24} }

type isRawWriteRequest_Chunk interface {
	isRawWriteRequest_Chunk()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RawWriteRequest_Meta struct {
	Meta *SSTMeta `protobuf:"bytes,1,opt,name=meta,oneof"`
}
type RawWriteRequest_Batch struct {
	Batch *RawWriteBatch `protobuf:"bytes,2,opt,name=batch,oneof"`
}

func (*RawWriteRequest_Meta) isRawWriteRequest_Chunk()  {}
func (*RawWriteRequest_Batch) isRawWriteRequest_Chunk() {}

func (m *RawWriteRequest) GetChunk() isRawWriteRequest_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *RawWriteRequest) GetMeta() *SSTMeta {
	if x, ok := m.GetChunk().(*RawWriteRequest_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *RawWriteRequest) GetBatch() *RawWriteBatch {
	if x, ok := m.GetChunk().(*RawWriteRequest_Batch); ok {
		return x.Batch
	}
	return nil
}

func (m *RawWriteRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RawWriteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RawWriteRequest_OneofMarshaler, _RawWriteRequest_OneofUnmarshaler, _RawWriteRequest_OneofSizer, []interface{}{
		(*RawWriteRequest_Meta)(nil),
		(*RawWriteRequest_Batch)(nil),
	}
}

func _RawWriteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RawWriteRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *RawWriteRequest_Meta:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Meta); err != nil {
			return err
		}
	case *RawWriteRequest_Batch:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Batch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RawWriteRequest.Chunk has unexpected type %T", x)
	}
	return nil
}

func _RawWriteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RawWriteRequest)
	switch tag {
	case 1: // chunk.meta
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SSTMeta)
		err := b.DecodeMessage(msg)
		m.Chunk = &RawWriteRequest_Meta{msg}
		return true, err
	case 2: // chunk.batch
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RawWriteBatch)
		err := b.DecodeMessage(msg)
		m.Chunk = &RawWriteRequest_Batch{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RawWriteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RawWriteRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *RawWriteRequest_Meta:
		s := proto.Size(x.Meta)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RawWriteRequest_Batch:
		s := proto.Size(x.Batch)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RawWriteResponse struct {
	Error *Error     `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Metas []*SSTMeta `protobuf:"bytes,2,rep,name=metas" json:"metas,omitempty"`
}

func (m *RawWriteResponse) Reset()                    { *m = RawWriteResponse{} }
func (m *RawWriteResponse) String() string            { return proto.CompactTextString(m) }
func (*RawWriteResponse) ProtoMessage()               {}
func (*RawWriteResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{25} }

func (m *RawWriteResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *RawWriteResponse) GetMetas() []*SSTMeta {
	if m != nil {
		return m.Metas
	}
	return nil
}

type DuplicateDetectRequest struct {
	Context  *kvrpcpb.Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartKey []byte           `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte           `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// Return only the keys found by scanning, not their values.
	KeyOnly bool `protobuf:"varint,4,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	// We only check the data whose timestamp is larger than `min_commit_ts`. `min_commit_ts` is exclueded.
	MinCommitTs uint64 `protobuf:"varint,5,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
}

func (m *DuplicateDetectRequest) Reset()         { *m = DuplicateDetectRequest{} }
func (m *DuplicateDetectRequest) String() string { return proto.CompactTextString(m) }
func (*DuplicateDetectRequest) ProtoMessage()    {}
func (*DuplicateDetectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorImportSstpb, []int{26}
}

func (m *DuplicateDetectRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DuplicateDetectRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *DuplicateDetectRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *DuplicateDetectRequest) GetKeyOnly() bool {
	if m != nil {
		return m.KeyOnly
	}
	return false
}

func (m *DuplicateDetectRequest) GetMinCommitTs() uint64 {
	if m != nil {
		return m.MinCommitTs
	}
	return 0
}

type KvPair struct {
	Key      []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value    []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	CommitTs uint64 `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
}

func (m *KvPair) Reset()                    { *m = KvPair{} }
func (m *KvPair) String() string            { return proto.CompactTextString(m) }
func (*KvPair) ProtoMessage()               {}
func (*KvPair) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{27} }

func (m *KvPair) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KvPair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *KvPair) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type DuplicateDetectResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	KeyError    *Error         `protobuf:"bytes,2,opt,name=key_error,json=keyError" json:"key_error,omitempty"`
	// The these keys will be in asc order (but commit time is in desc order),
	//  and the content is just like following:
	// [
	//   {key: "key1", value: "value11", commit_ts: 1005},
	//   {key: "key1", value: "value12", commit_ts: 1004},
	//   {key: "key1", value: "value13", commit_ts: 1001},
	//   {key: "key2", value: "value21", commit_ts: 1004},
	//   {key: "key2", value: "value22", commit_ts: 1002},
	//   ...
	// ]
	Pairs []*KvPair `protobuf:"bytes,3,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *DuplicateDetectResponse) Reset()         { *m = DuplicateDetectResponse{} }
func (m *DuplicateDetectResponse) String() string { return proto.CompactTextString(m) }
func (*DuplicateDetectResponse) ProtoMessage()    {}
func (*DuplicateDetectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorImportSstpb, []int{28}
}

func (m *DuplicateDetectResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *DuplicateDetectResponse) GetKeyError() *Error {
	if m != nil {
		return m.KeyError
	}
	return nil
}

func (m *DuplicateDetectResponse) GetPairs() []*KvPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type KVMeta struct {
	// The file name of the KV file.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// file offset, sometimes only need to get a part of data from the merged file
	RangeOffset uint64 `protobuf:"varint,11,opt,name=range_offset,json=rangeOffset,proto3" json:"range_offset,omitempty"`
	// file length for check.
	Length uint64 `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	// range length of the merged file, if it exists.
	RangeLength uint64 `protobuf:"varint,12,opt,name=range_length,json=rangeLength,proto3" json:"range_length,omitempty"`
	// tell us which cf should apply. WRITE_CF or DEFAULT_CF e.g.
	Cf string `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	// is_delete represents whether we should delete the kv in tikv.
	// it may not be too much delete file. only rollBack operation will generate delete kv file.
	IsDelete bool `protobuf:"varint,4,opt,name=is_delete,json=isDelete,proto3" json:"is_delete,omitempty"`
	// the key ts space being smaller than start_ts can be filter.
	StartTs uint64 `protobuf:"varint,10,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	// the key ts space large than restore_ts can be filter.
	RestoreTs uint64 `protobuf:"varint,5,opt,name=restore_ts,json=restoreTs,proto3" json:"restore_ts,omitempty"`
	StartKey  []byte `protobuf:"bytes,6,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey    []byte `protobuf:"bytes,7,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// used for checksum when download kv file.
	Sha256 []byte `protobuf:"bytes,8,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// the key ts space less than start_snapshot_ts can be filter.
	// Deprecated: this field 'start_snapshot_ts' is replaced by the field 'start_ts'.
	StartSnapshotTs uint64 `protobuf:"varint,9,opt,name=start_snapshot_ts,json=startSnapshotTs,proto3" json:"start_snapshot_ts,omitempty"`
	// the compression type for the file.
	CompressionType backup.CompressionType `protobuf:"varint,13,opt,name=compression_type,json=compressionType,proto3,enum=backup.CompressionType" json:"compression_type,omitempty"`
}

func (m *KVMeta) Reset()                    { *m = KVMeta{} }
func (m *KVMeta) String() string            { return proto.CompactTextString(m) }
func (*KVMeta) ProtoMessage()               {}
func (*KVMeta) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{29} }

func (m *KVMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *KVMeta) GetRangeOffset() uint64 {
	if m != nil {
		return m.RangeOffset
	}
	return 0
}

func (m *KVMeta) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *KVMeta) GetRangeLength() uint64 {
	if m != nil {
		return m.RangeLength
	}
	return 0
}

func (m *KVMeta) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *KVMeta) GetIsDelete() bool {
	if m != nil {
		return m.IsDelete
	}
	return false
}

func (m *KVMeta) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *KVMeta) GetRestoreTs() uint64 {
	if m != nil {
		return m.RestoreTs
	}
	return 0
}

func (m *KVMeta) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *KVMeta) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *KVMeta) GetSha256() []byte {
	if m != nil {
		return m.Sha256
	}
	return nil
}

func (m *KVMeta) GetStartSnapshotTs() uint64 {
	if m != nil {
		return m.StartSnapshotTs
	}
	return 0
}

func (m *KVMeta) GetCompressionType() backup.CompressionType {
	if m != nil {
		return m.CompressionType
	}
	return backup.CompressionType_UNKNOWN
}

type ApplyRequest struct {
	// The meta of the KV file.
	Meta  *KVMeta   `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Metas []*KVMeta `protobuf:"bytes,12,rep,name=metas" json:"metas,omitempty"`
	// Performs a key prefix rewrite after downloading the file.
	// All keys in the files will be rewritten as:
	//
	//  new_key = new_key_prefix + old_key[len(old_key_prefix)..]
	//
	// When used for TiDB, rewriting the prefix changes the table ID. Please
	// note that key-rewrite is applied on the origin keys in encoded
	// representation.
	//
	// You need to ensure that the keys before and after rewriting are in the
	// same order, otherwise the RPC request will fail.
	RewriteRule  RewriteRule    `protobuf:"bytes,2,opt,name=rewrite_rule,json=rewriteRule" json:"rewrite_rule"`
	RewriteRules []*RewriteRule `protobuf:"bytes,13,rep,name=rewrite_rules,json=rewriteRules" json:"rewrite_rules,omitempty"`
	// The identity for the stroage backend.
	// When this field presents, the storage would be cached.
	// If there is a cached storage, TiKV would use it driectly.
	StorageCacheId string                 `protobuf:"bytes,5,opt,name=storage_cache_id,json=storageCacheId,proto3" json:"storage_cache_id,omitempty"`
	StorageBackend *backup.StorageBackend `protobuf:"bytes,3,opt,name=storage_backend,json=storageBackend" json:"storage_backend,omitempty"`
	// context represents region info and it used to build raft commands.
	Context *kvrpcpb.Context `protobuf:"bytes,4,opt,name=context" json:"context,omitempty"`
	// cipher_info is used to decrypt kv file when download file.
	CipherInfo *backup.CipherInfo `protobuf:"bytes,11,opt,name=cipher_info,json=cipherInfo" json:"cipher_info,omitempty"`
}

func (m *ApplyRequest) Reset()                    { *m = ApplyRequest{} }
func (m *ApplyRequest) String() string            { return proto.CompactTextString(m) }
func (*ApplyRequest) ProtoMessage()               {}
func (*ApplyRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{30} }

func (m *ApplyRequest) GetMeta() *KVMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ApplyRequest) GetMetas() []*KVMeta {
	if m != nil {
		return m.Metas
	}
	return nil
}

func (m *ApplyRequest) GetRewriteRule() RewriteRule {
	if m != nil {
		return m.RewriteRule
	}
	return RewriteRule{}
}

func (m *ApplyRequest) GetRewriteRules() []*RewriteRule {
	if m != nil {
		return m.RewriteRules
	}
	return nil
}

func (m *ApplyRequest) GetStorageCacheId() string {
	if m != nil {
		return m.StorageCacheId
	}
	return ""
}

func (m *ApplyRequest) GetStorageBackend() *backup.StorageBackend {
	if m != nil {
		return m.StorageBackend
	}
	return nil
}

func (m *ApplyRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ApplyRequest) GetCipherInfo() *backup.CipherInfo {
	if m != nil {
		return m.CipherInfo
	}
	return nil
}

type ApplyResponse struct {
	// The actual key range (after rewrite) of the downloaded file. The range is
	// inclusive in both ends.
	Range Range  `protobuf:"bytes,1,opt,name=range" json:"range"`
	Error *Error `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *ApplyResponse) Reset()                    { *m = ApplyResponse{} }
func (m *ApplyResponse) String() string            { return proto.CompactTextString(m) }
func (*ApplyResponse) ProtoMessage()               {}
func (*ApplyResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{31} }

func (m *ApplyResponse) GetRange() Range {
	if m != nil {
		return m.Range
	}
	return Range{}
}

func (m *ApplyResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ClearRequest struct {
	// clear files in import directory with given prefix.
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *ClearRequest) Reset()                    { *m = ClearRequest{} }
func (m *ClearRequest) String() string            { return proto.CompactTextString(m) }
func (*ClearRequest) ProtoMessage()               {}
func (*ClearRequest) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{32} }

func (m *ClearRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

type ClearResponse struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
}

func (m *ClearResponse) Reset()                    { *m = ClearResponse{} }
func (m *ClearResponse) String() string            { return proto.CompactTextString(m) }
func (*ClearResponse) ProtoMessage()               {}
func (*ClearResponse) Descriptor() ([]byte, []int) { return fileDescriptorImportSstpb, []int{33} }

func (m *ClearResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func init() {
	proto.RegisterType((*SwitchModeRequest)(nil), "import_sstpb.SwitchModeRequest")
	proto.RegisterType((*SwitchModeResponse)(nil), "import_sstpb.SwitchModeResponse")
	proto.RegisterType((*GetModeRequest)(nil), "import_sstpb.GetModeRequest")
	proto.RegisterType((*GetModeResponse)(nil), "import_sstpb.GetModeResponse")
	proto.RegisterType((*Range)(nil), "import_sstpb.Range")
	proto.RegisterType((*SSTMeta)(nil), "import_sstpb.SSTMeta")
	proto.RegisterType((*RewriteRule)(nil), "import_sstpb.RewriteRule")
	proto.RegisterType((*UploadRequest)(nil), "import_sstpb.UploadRequest")
	proto.RegisterType((*UploadResponse)(nil), "import_sstpb.UploadResponse")
	proto.RegisterType((*IngestRequest)(nil), "import_sstpb.IngestRequest")
	proto.RegisterType((*MultiIngestRequest)(nil), "import_sstpb.MultiIngestRequest")
	proto.RegisterType((*IngestResponse)(nil), "import_sstpb.IngestResponse")
	proto.RegisterType((*CompactRequest)(nil), "import_sstpb.CompactRequest")
	proto.RegisterType((*CompactResponse)(nil), "import_sstpb.CompactResponse")
	proto.RegisterType((*DownloadRequest)(nil), "import_sstpb.DownloadRequest")
	proto.RegisterType((*Error)(nil), "import_sstpb.Error")
	proto.RegisterType((*DownloadResponse)(nil), "import_sstpb.DownloadResponse")
	proto.RegisterType((*SetDownloadSpeedLimitRequest)(nil), "import_sstpb.SetDownloadSpeedLimitRequest")
	proto.RegisterType((*SetDownloadSpeedLimitResponse)(nil), "import_sstpb.SetDownloadSpeedLimitResponse")
	proto.RegisterType((*Pair)(nil), "import_sstpb.Pair")
	proto.RegisterType((*WriteBatch)(nil), "import_sstpb.WriteBatch")
	proto.RegisterType((*WriteRequest)(nil), "import_sstpb.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "import_sstpb.WriteResponse")
	proto.RegisterType((*RawWriteBatch)(nil), "import_sstpb.RawWriteBatch")
	proto.RegisterType((*RawWriteRequest)(nil), "import_sstpb.RawWriteRequest")
	proto.RegisterType((*RawWriteResponse)(nil), "import_sstpb.RawWriteResponse")
	proto.RegisterType((*DuplicateDetectRequest)(nil), "import_sstpb.DuplicateDetectRequest")
	proto.RegisterType((*KvPair)(nil), "import_sstpb.KvPair")
	proto.RegisterType((*DuplicateDetectResponse)(nil), "import_sstpb.DuplicateDetectResponse")
	proto.RegisterType((*KVMeta)(nil), "import_sstpb.KVMeta")
	proto.RegisterType((*ApplyRequest)(nil), "import_sstpb.ApplyRequest")
	proto.RegisterType((*ApplyResponse)(nil), "import_sstpb.ApplyResponse")
	proto.RegisterType((*ClearRequest)(nil), "import_sstpb.ClearRequest")
	proto.RegisterType((*ClearResponse)(nil), "import_sstpb.ClearResponse")
	proto.RegisterEnum("import_sstpb.SwitchMode", SwitchMode_name, SwitchMode_value)
	proto.RegisterEnum("import_sstpb.DownloadRequestType", DownloadRequestType_name, DownloadRequestType_value)
	proto.RegisterEnum("import_sstpb.Pair_OP", Pair_OP_name, Pair_OP_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ImportSST service

type ImportSSTClient interface {
	// Switch to normal/import mode.
	SwitchMode(ctx context.Context, in *SwitchModeRequest, opts ...grpc.CallOption) (*SwitchModeResponse, error)
	// Get import mode(normal/import).
	GetMode(ctx context.Context, in *GetModeRequest, opts ...grpc.CallOption) (*GetModeResponse, error)
	// Upload an SST file to a server.
	Upload(ctx context.Context, opts ...grpc.CallOption) (ImportSST_UploadClient, error)
	// Ingest an uploaded SST file to a region.
	Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
	// Compact the specific range for better performance.
	Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error)
	SetDownloadSpeedLimit(ctx context.Context, in *SetDownloadSpeedLimitRequest, opts ...grpc.CallOption) (*SetDownloadSpeedLimitResponse, error)
	// Download an SST file from an external storage, and performs key-rewrite
	// after downloading.
	Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error)
	// Open a write stream to generate sst files
	Write(ctx context.Context, opts ...grpc.CallOption) (ImportSST_WriteClient, error)
	RawWrite(ctx context.Context, opts ...grpc.CallOption) (ImportSST_RawWriteClient, error)
	// Ingest Multiple files in one request
	MultiIngest(ctx context.Context, in *MultiIngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
	// Collect duplicate data from TiKV.
	DuplicateDetect(ctx context.Context, in *DuplicateDetectRequest, opts ...grpc.CallOption) (ImportSST_DuplicateDetectClient, error)
	// Apply download & apply increment kv files to TiKV.
	Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error)
	// ClearFiles clear applied file after restore succeed.
	ClearFiles(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*ClearResponse, error)
}

type importSSTClient struct {
	cc *grpc.ClientConn
}

func NewImportSSTClient(cc *grpc.ClientConn) ImportSSTClient {
	return &importSSTClient{cc}
}

func (c *importSSTClient) SwitchMode(ctx context.Context, in *SwitchModeRequest, opts ...grpc.CallOption) (*SwitchModeResponse, error) {
	out := new(SwitchModeResponse)
	err := grpc.Invoke(ctx, "/import_sstpb.ImportSST/SwitchMode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) GetMode(ctx context.Context, in *GetModeRequest, opts ...grpc.CallOption) (*GetModeResponse, error) {
	out := new(GetModeResponse)
	err := grpc.Invoke(ctx, "/import_sstpb.ImportSST/GetMode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Upload(ctx context.Context, opts ...grpc.CallOption) (ImportSST_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ImportSST_serviceDesc.Streams[0], c.cc, "/import_sstpb.ImportSST/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &importSSTUploadClient{stream}
	return x, nil
}

type ImportSST_UploadClient interface {
	Send(*UploadRequest) error
	CloseAndRecv() (*UploadResponse, error)
	grpc.ClientStream
}

type importSSTUploadClient struct {
	grpc.ClientStream
}

func (x *importSSTUploadClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *importSSTUploadClient) CloseAndRecv() (*UploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *importSSTClient) Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := grpc.Invoke(ctx, "/import_sstpb.ImportSST/Ingest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error) {
	out := new(CompactResponse)
	err := grpc.Invoke(ctx, "/import_sstpb.ImportSST/Compact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) SetDownloadSpeedLimit(ctx context.Context, in *SetDownloadSpeedLimitRequest, opts ...grpc.CallOption) (*SetDownloadSpeedLimitResponse, error) {
	out := new(SetDownloadSpeedLimitResponse)
	err := grpc.Invoke(ctx, "/import_sstpb.ImportSST/SetDownloadSpeedLimit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error) {
	out := new(DownloadResponse)
	err := grpc.Invoke(ctx, "/import_sstpb.ImportSST/Download", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Write(ctx context.Context, opts ...grpc.CallOption) (ImportSST_WriteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ImportSST_serviceDesc.Streams[1], c.cc, "/import_sstpb.ImportSST/Write", opts...)
	if err != nil {
		return nil, err
	}
	x := &importSSTWriteClient{stream}
	return x, nil
}

type ImportSST_WriteClient interface {
	Send(*WriteRequest) error
	CloseAndRecv() (*WriteResponse, error)
	grpc.ClientStream
}

type importSSTWriteClient struct {
	grpc.ClientStream
}

func (x *importSSTWriteClient) Send(m *WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *importSSTWriteClient) CloseAndRecv() (*WriteResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *importSSTClient) RawWrite(ctx context.Context, opts ...grpc.CallOption) (ImportSST_RawWriteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ImportSST_serviceDesc.Streams[2], c.cc, "/import_sstpb.ImportSST/RawWrite", opts...)
	if err != nil {
		return nil, err
	}
	x := &importSSTRawWriteClient{stream}
	return x, nil
}

type ImportSST_RawWriteClient interface {
	Send(*RawWriteRequest) error
	CloseAndRecv() (*RawWriteResponse, error)
	grpc.ClientStream
}

type importSSTRawWriteClient struct {
	grpc.ClientStream
}

func (x *importSSTRawWriteClient) Send(m *RawWriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *importSSTRawWriteClient) CloseAndRecv() (*RawWriteResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RawWriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *importSSTClient) MultiIngest(ctx context.Context, in *MultiIngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := grpc.Invoke(ctx, "/import_sstpb.ImportSST/MultiIngest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) DuplicateDetect(ctx context.Context, in *DuplicateDetectRequest, opts ...grpc.CallOption) (ImportSST_DuplicateDetectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ImportSST_serviceDesc.Streams[3], c.cc, "/import_sstpb.ImportSST/DuplicateDetect", opts...)
	if err != nil {
		return nil, err
	}
	x := &importSSTDuplicateDetectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ImportSST_DuplicateDetectClient interface {
	Recv() (*DuplicateDetectResponse, error)
	grpc.ClientStream
}

type importSSTDuplicateDetectClient struct {
	grpc.ClientStream
}

func (x *importSSTDuplicateDetectClient) Recv() (*DuplicateDetectResponse, error) {
	m := new(DuplicateDetectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *importSSTClient) Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error) {
	out := new(ApplyResponse)
	err := grpc.Invoke(ctx, "/import_sstpb.ImportSST/Apply", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) ClearFiles(ctx context.Context, in *ClearRequest, opts ...grpc.CallOption) (*ClearResponse, error) {
	out := new(ClearResponse)
	err := grpc.Invoke(ctx, "/import_sstpb.ImportSST/ClearFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ImportSST service

type ImportSSTServer interface {
	// Switch to normal/import mode.
	SwitchMode(context.Context, *SwitchModeRequest) (*SwitchModeResponse, error)
	// Get import mode(normal/import).
	GetMode(context.Context, *GetModeRequest) (*GetModeResponse, error)
	// Upload an SST file to a server.
	Upload(ImportSST_UploadServer) error
	// Ingest an uploaded SST file to a region.
	Ingest(context.Context, *IngestRequest) (*IngestResponse, error)
	// Compact the specific range for better performance.
	Compact(context.Context, *CompactRequest) (*CompactResponse, error)
	SetDownloadSpeedLimit(context.Context, *SetDownloadSpeedLimitRequest) (*SetDownloadSpeedLimitResponse, error)
	// Download an SST file from an external storage, and performs key-rewrite
	// after downloading.
	Download(context.Context, *DownloadRequest) (*DownloadResponse, error)
	// Open a write stream to generate sst files
	Write(ImportSST_WriteServer) error
	RawWrite(ImportSST_RawWriteServer) error
	// Ingest Multiple files in one request
	MultiIngest(context.Context, *MultiIngestRequest) (*IngestResponse, error)
	// Collect duplicate data from TiKV.
	DuplicateDetect(*DuplicateDetectRequest, ImportSST_DuplicateDetectServer) error
	// Apply download & apply increment kv files to TiKV.
	Apply(context.Context, *ApplyRequest) (*ApplyResponse, error)
	// ClearFiles clear applied file after restore succeed.
	ClearFiles(context.Context, *ClearRequest) (*ClearResponse, error)
}

func RegisterImportSSTServer(s *grpc.Server, srv ImportSSTServer) {
	s.RegisterService(&_ImportSST_serviceDesc, srv)
}

func _ImportSST_SwitchMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).SwitchMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/SwitchMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).SwitchMode(ctx, req.(*SwitchModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_GetMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).GetMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/GetMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).GetMode(ctx, req.(*GetModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImportSSTServer).Upload(&importSSTUploadServer{stream})
}

type ImportSST_UploadServer interface {
	SendAndClose(*UploadResponse) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type importSSTUploadServer struct {
	grpc.ServerStream
}

func (x *importSSTUploadServer) SendAndClose(m *UploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *importSSTUploadServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ImportSST_Ingest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Ingest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/Ingest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Ingest(ctx, req.(*IngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/Compact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Compact(ctx, req.(*CompactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_SetDownloadSpeedLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDownloadSpeedLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).SetDownloadSpeedLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/SetDownloadSpeedLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).SetDownloadSpeedLimit(ctx, req.(*SetDownloadSpeedLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Download_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Download(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/Download",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Download(ctx, req.(*DownloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Write_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImportSSTServer).Write(&importSSTWriteServer{stream})
}

type ImportSST_WriteServer interface {
	SendAndClose(*WriteResponse) error
	Recv() (*WriteRequest, error)
	grpc.ServerStream
}

type importSSTWriteServer struct {
	grpc.ServerStream
}

func (x *importSSTWriteServer) SendAndClose(m *WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *importSSTWriteServer) Recv() (*WriteRequest, error) {
	m := new(WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ImportSST_RawWrite_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImportSSTServer).RawWrite(&importSSTRawWriteServer{stream})
}

type ImportSST_RawWriteServer interface {
	SendAndClose(*RawWriteResponse) error
	Recv() (*RawWriteRequest, error)
	grpc.ServerStream
}

type importSSTRawWriteServer struct {
	grpc.ServerStream
}

func (x *importSSTRawWriteServer) SendAndClose(m *RawWriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *importSSTRawWriteServer) Recv() (*RawWriteRequest, error) {
	m := new(RawWriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ImportSST_MultiIngest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultiIngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).MultiIngest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/MultiIngest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).MultiIngest(ctx, req.(*MultiIngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_DuplicateDetect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DuplicateDetectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ImportSSTServer).DuplicateDetect(m, &importSSTDuplicateDetectServer{stream})
}

type ImportSST_DuplicateDetectServer interface {
	Send(*DuplicateDetectResponse) error
	grpc.ServerStream
}

type importSSTDuplicateDetectServer struct {
	grpc.ServerStream
}

func (x *importSSTDuplicateDetectServer) Send(m *DuplicateDetectResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ImportSST_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/Apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Apply(ctx, req.(*ApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_ClearFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).ClearFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/ClearFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).ClearFiles(ctx, req.(*ClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImportSST_serviceDesc = grpc.ServiceDesc{
	ServiceName: "import_sstpb.ImportSST",
	HandlerType: (*ImportSSTServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SwitchMode",
			Handler:    _ImportSST_SwitchMode_Handler,
		},
		{
			MethodName: "GetMode",
			Handler:    _ImportSST_GetMode_Handler,
		},
		{
			MethodName: "Ingest",
			Handler:    _ImportSST_Ingest_Handler,
		},
		{
			MethodName: "Compact",
			Handler:    _ImportSST_Compact_Handler,
		},
		{
			MethodName: "SetDownloadSpeedLimit",
			Handler:    _ImportSST_SetDownloadSpeedLimit_Handler,
		},
		{
			MethodName: "Download",
			Handler:    _ImportSST_Download_Handler,
		},
		{
			MethodName: "MultiIngest",
			Handler:    _ImportSST_MultiIngest_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _ImportSST_Apply_Handler,
		},
		{
			MethodName: "ClearFiles",
			Handler:    _ImportSST_ClearFiles_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _ImportSST_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Write",
			Handler:       _ImportSST_Write_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "RawWrite",
			Handler:       _ImportSST_RawWrite_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DuplicateDetect",
			Handler:       _ImportSST_DuplicateDetect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "import_sstpb.proto",
}

func (m *SwitchModeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchModeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Mode))
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SwitchModeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchModeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetModeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetModeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetModeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetModeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Mode))
	}
	return i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	return i, nil
}

func (m *SSTMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSTMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Range.Size()))
		n1, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Crc32 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Crc32))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Length))
	}
	if len(m.CfName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.CfName)))
		i += copy(dAtA[i:], m.CfName)
	}
	if m.RegionId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RegionId))
	}
	if m.RegionEpoch != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RegionEpoch.Size()))
		n2, err := m.RegionEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.EndKeyExclusive {
		dAtA[i] = 0x40
		i++
		if m.EndKeyExclusive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TotalKvs != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.TotalBytes))
	}
	if m.ApiVersion != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.ApiVersion))
	}
	if len(m.CipherIv) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.CipherIv)))
		i += copy(dAtA[i:], m.CipherIv)
	}
	return i, nil
}

func (m *RewriteRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewriteRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OldKeyPrefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.OldKeyPrefix)))
		i += copy(dAtA[i:], m.OldKeyPrefix)
	}
	if len(m.NewKeyPrefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.NewKeyPrefix)))
		i += copy(dAtA[i:], m.NewKeyPrefix)
	}
	if m.NewTimestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.NewTimestamp))
	}
	return i, nil
}

func (m *UploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		nn3, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	return i, nil
}

func (m *UploadRequest_Meta) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Meta.Size()))
		n4, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *UploadRequest_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}
func (m *UploadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *IngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n5, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Sst != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Sst.Size()))
		n6, err := m.Sst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *MultiIngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiIngestRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n7, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Ssts) > 0 {
		for _, msg := range m.Ssts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IngestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n8, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *CompactRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Range.Size()))
		n9, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.OutputLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.OutputLevel))
	}
	if m.Context != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n10, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *CompactResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DownloadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintImportSstpb(dAtA, i, uint64(m.Sst.Size()))
	n11, err := m.Sst.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if len(m.Name) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	dAtA[i] = 0x6a
	i++
	i = encodeVarintImportSstpb(dAtA, i, uint64(m.RewriteRule.Size()))
	n12, err := m.RewriteRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if m.StorageBackend != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.StorageBackend.Size()))
		n13, err := m.StorageBackend.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.IsRawKv {
		dAtA[i] = 0x78
		i++
		if m.IsRawKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CipherInfo != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.CipherInfo.Size()))
		n14, err := m.CipherInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.StorageCacheId) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.StorageCacheId)))
		i += copy(dAtA[i:], m.StorageCacheId)
	}
	if m.RequestType != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RequestType))
	}
	if m.Context != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n15, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.StoreError != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.StoreError.Size()))
		n16, err := m.StoreError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *DownloadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintImportSstpb(dAtA, i, uint64(m.Range.Size()))
	n17, err := m.Range.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if m.IsEmpty {
		dAtA[i] = 0x10
		i++
		if m.IsEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Error != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n18, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Crc32 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Crc32))
	}
	if m.Length != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Length))
	}
	return i, nil
}

func (m *SetDownloadSpeedLimitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDownloadSpeedLimitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SpeedLimit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.SpeedLimit))
	}
	return i, nil
}

func (m *SetDownloadSpeedLimitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDownloadSpeedLimitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Op != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Op))
	}
	return i, nil
}

func (m *WriteBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommitTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.CommitTs))
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		nn19, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn19
	}
	if m.Context != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n20, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *WriteRequest_Meta) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Meta.Size()))
		n21, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *WriteRequest_Batch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Batch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Batch.Size()))
		n22, err := m.Batch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *WriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n23, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.Metas) > 0 {
		for _, msg := range m.Metas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawWriteBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawWriteBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ttl != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Ttl))
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Ts))
	}
	return i, nil
}

func (m *RawWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		nn24, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	if m.Context != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n25, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *RawWriteRequest_Meta) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Meta.Size()))
		n26, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *RawWriteRequest_Batch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Batch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Batch.Size()))
		n27, err := m.Batch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}
func (m *RawWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n28, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if len(m.Metas) > 0 {
		for _, msg := range m.Metas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DuplicateDetectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DuplicateDetectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n29, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.KeyOnly {
		dAtA[i] = 0x20
		i++
		if m.KeyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MinCommitTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.MinCommitTs))
	}
	return i, nil
}

func (m *KvPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KvPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.CommitTs))
	}
	return i, nil
}

func (m *DuplicateDetectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DuplicateDetectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RegionError.Size()))
		n30, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.KeyError != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.KeyError.Size()))
		n31, err := m.KeyError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *KVMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Length))
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	if m.IsDelete {
		dAtA[i] = 0x20
		i++
		if m.IsDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RestoreTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RestoreTs))
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if len(m.Sha256) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Sha256)))
		i += copy(dAtA[i:], m.Sha256)
	}
	if m.StartSnapshotTs != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.StartSnapshotTs))
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.StartTs))
	}
	if m.RangeOffset != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RangeOffset))
	}
	if m.RangeLength != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RangeLength))
	}
	if m.CompressionType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.CompressionType))
	}
	return i, nil
}

func (m *ApplyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Meta.Size()))
		n32, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintImportSstpb(dAtA, i, uint64(m.RewriteRule.Size()))
	n33, err := m.RewriteRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n33
	if m.StorageBackend != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.StorageBackend.Size()))
		n34, err := m.StorageBackend.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Context != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n35, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if len(m.StorageCacheId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.StorageCacheId)))
		i += copy(dAtA[i:], m.StorageCacheId)
	}
	if m.CipherInfo != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.CipherInfo.Size()))
		n36, err := m.CipherInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if len(m.Metas) > 0 {
		for _, msg := range m.Metas {
			dAtA[i] = 0x62
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RewriteRules) > 0 {
		for _, msg := range m.RewriteRules {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ApplyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintImportSstpb(dAtA, i, uint64(m.Range.Size()))
	n37, err := m.Range.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n37
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n38, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *ClearRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	return i, nil
}

func (m *ClearResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n39, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func encodeVarintImportSstpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SwitchModeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovImportSstpb(uint64(m.Mode))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	return n
}

func (m *SwitchModeResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetModeRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetModeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovImportSstpb(uint64(m.Mode))
	}
	return n
}

func (m *Range) Size() (n int) {
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *SSTMeta) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Crc32 != 0 {
		n += 1 + sovImportSstpb(uint64(m.Crc32))
	}
	if m.Length != 0 {
		n += 1 + sovImportSstpb(uint64(m.Length))
	}
	l = len(m.CfName)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.RegionId != 0 {
		n += 1 + sovImportSstpb(uint64(m.RegionId))
	}
	if m.RegionEpoch != nil {
		l = m.RegionEpoch.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.EndKeyExclusive {
		n += 2
	}
	if m.TotalKvs != 0 {
		n += 1 + sovImportSstpb(uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovImportSstpb(uint64(m.TotalBytes))
	}
	if m.ApiVersion != 0 {
		n += 1 + sovImportSstpb(uint64(m.ApiVersion))
	}
	l = len(m.CipherIv)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *RewriteRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.OldKeyPrefix)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.NewKeyPrefix)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.NewTimestamp != 0 {
		n += 1 + sovImportSstpb(uint64(m.NewTimestamp))
	}
	return n
}

func (m *UploadRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chunk != nil {
		n += m.Chunk.Size()
	}
	return n
}

func (m *UploadRequest_Meta) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *UploadRequest_Data) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *UploadResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *IngestRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Sst != nil {
		l = m.Sst.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *MultiIngestRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if len(m.Ssts) > 0 {
		for _, e := range m.Ssts {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	return n
}

func (m *IngestResponse) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *CompactRequest) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.OutputLevel != 0 {
		n += 1 + sovImportSstpb(uint64(m.OutputLevel))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *CompactResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DownloadRequest) Size() (n int) {
	var l int
	_ = l
	l = m.Sst.Size()
	n += 1 + l + sovImportSstpb(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = m.RewriteRule.Size()
	n += 1 + l + sovImportSstpb(uint64(l))
	if m.StorageBackend != nil {
		l = m.StorageBackend.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.IsRawKv {
		n += 2
	}
	if m.CipherInfo != nil {
		l = m.CipherInfo.Size()
		n += 2 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.StorageCacheId)
	if l > 0 {
		n += 2 + l + sovImportSstpb(uint64(l))
	}
	if m.RequestType != 0 {
		n += 2 + sovImportSstpb(uint64(m.RequestType))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 2 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.StoreError != nil {
		l = m.StoreError.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *DownloadResponse) Size() (n int) {
	var l int
	_ = l
	l = m.Range.Size()
	n += 1 + l + sovImportSstpb(uint64(l))
	if m.IsEmpty {
		n += 2
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Crc32 != 0 {
		n += 1 + sovImportSstpb(uint64(m.Crc32))
	}
	if m.Length != 0 {
		n += 1 + sovImportSstpb(uint64(m.Length))
	}
	return n
}

func (m *SetDownloadSpeedLimitRequest) Size() (n int) {
	var l int
	_ = l
	if m.SpeedLimit != 0 {
		n += 1 + sovImportSstpb(uint64(m.SpeedLimit))
	}
	return n
}

func (m *SetDownloadSpeedLimitResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Pair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovImportSstpb(uint64(m.Op))
	}
	return n
}

func (m *WriteBatch) Size() (n int) {
	var l int
	_ = l
	if m.CommitTs != 0 {
		n += 1 + sovImportSstpb(uint64(m.CommitTs))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	return n
}

func (m *WriteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chunk != nil {
		n += m.Chunk.Size()
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *WriteRequest_Meta) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *WriteRequest_Batch) Size() (n int) {
	var l int
	_ = l
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *WriteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if len(m.Metas) > 0 {
		for _, e := range m.Metas {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	return n
}

func (m *RawWriteBatch) Size() (n int) {
	var l int
	_ = l
	if m.Ttl != 0 {
		n += 1 + sovImportSstpb(uint64(m.Ttl))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	if m.Ts != 0 {
		n += 1 + sovImportSstpb(uint64(m.Ts))
	}
	return n
}

func (m *RawWriteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chunk != nil {
		n += m.Chunk.Size()
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *RawWriteRequest_Meta) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *RawWriteRequest_Batch) Size() (n int) {
	var l int
	_ = l
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *RawWriteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if len(m.Metas) > 0 {
		for _, e := range m.Metas {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	return n
}

func (m *DuplicateDetectRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.KeyOnly {
		n += 2
	}
	if m.MinCommitTs != 0 {
		n += 1 + sovImportSstpb(uint64(m.MinCommitTs))
	}
	return n
}

func (m *KvPair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.CommitTs != 0 {
		n += 1 + sovImportSstpb(uint64(m.CommitTs))
	}
	return n
}

func (m *DuplicateDetectResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.KeyError != nil {
		l = m.KeyError.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	return n
}

func (m *KVMeta) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovImportSstpb(uint64(m.Length))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.IsDelete {
		n += 2
	}
	if m.RestoreTs != 0 {
		n += 1 + sovImportSstpb(uint64(m.RestoreTs))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.Sha256)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.StartSnapshotTs != 0 {
		n += 1 + sovImportSstpb(uint64(m.StartSnapshotTs))
	}
	if m.StartTs != 0 {
		n += 1 + sovImportSstpb(uint64(m.StartTs))
	}
	if m.RangeOffset != 0 {
		n += 1 + sovImportSstpb(uint64(m.RangeOffset))
	}
	if m.RangeLength != 0 {
		n += 1 + sovImportSstpb(uint64(m.RangeLength))
	}
	if m.CompressionType != 0 {
		n += 1 + sovImportSstpb(uint64(m.CompressionType))
	}
	return n
}

func (m *ApplyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = m.RewriteRule.Size()
	n += 1 + l + sovImportSstpb(uint64(l))
	if m.StorageBackend != nil {
		l = m.StorageBackend.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.StorageCacheId)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.CipherInfo != nil {
		l = m.CipherInfo.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if len(m.Metas) > 0 {
		for _, e := range m.Metas {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	if len(m.RewriteRules) > 0 {
		for _, e := range m.RewriteRules {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	return n
}

func (m *ApplyResponse) Size() (n int) {
	var l int
	_ = l
	l = m.Range.Size()
	n += 1 + l + sovImportSstpb(uint64(l))
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *ClearRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func (m *ClearResponse) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}

func sovImportSstpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImportSstpb(x uint64) (n int) {
	return sovImportSstpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SwitchModeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchModeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchModeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (SwitchMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &Range{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchModeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchModeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchModeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetModeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetModeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetModeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetModeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetModeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetModeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (SwitchMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSTMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSTMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSTMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc32", wireType)
			}
			m.Crc32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc32 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionEpoch == nil {
				m.RegionEpoch = &metapb.RegionEpoch{}
			}
			if err := m.RegionEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKeyExclusive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndKeyExclusive = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalKvs", wireType)
			}
			m.TotalKvs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalKvs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			m.ApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiVersion |= (kvrpcpb.APIVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherIv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherIv = append(m.CipherIv[:0], dAtA[iNdEx:postIndex]...)
			if m.CipherIv == nil {
				m.CipherIv = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewriteRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewriteRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewriteRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldKeyPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldKeyPrefix = append(m.OldKeyPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.OldKeyPrefix == nil {
				m.OldKeyPrefix = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeyPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKeyPrefix = append(m.NewKeyPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.NewKeyPrefix == nil {
				m.NewKeyPrefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTimestamp", wireType)
			}
			m.NewTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewTimestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SSTMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &UploadRequest_Meta{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Chunk = &UploadRequest_Data{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sst == nil {
				m.Sst = &SSTMeta{}
			}
			if err := m.Sst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiIngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiIngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiIngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ssts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ssts = append(m.Ssts, &SSTMeta{})
			if err := m.Ssts[len(m.Ssts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &errorpb.Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputLevel", wireType)
			}
			m.OutputLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewriteRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewriteRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageBackend == nil {
				m.StorageBackend = &backup.StorageBackend{}
			}
			if err := m.StorageBackend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRawKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRawKv = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CipherInfo == nil {
				m.CipherInfo = &backup.CipherInfo{}
			}
			if err := m.CipherInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageCacheId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageCacheId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestType", wireType)
			}
			m.RequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestType |= (DownloadRequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoreError == nil {
				m.StoreError = &errorpb.Error{}
			}
			if err := m.StoreError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEmpty = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc32", wireType)
			}
			m.Crc32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc32 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDownloadSpeedLimitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDownloadSpeedLimitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDownloadSpeedLimitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedLimit", wireType)
			}
			m.SpeedLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDownloadSpeedLimitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDownloadSpeedLimitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDownloadSpeedLimitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (Pair_OP(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &Pair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SSTMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &WriteRequest_Meta{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WriteBatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &WriteRequest_Batch{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metas = append(m.Metas, &SSTMeta{})
			if err := m.Metas[len(m.Metas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawWriteBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawWriteBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawWriteBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &Pair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SSTMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &RawWriteRequest_Meta{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RawWriteBatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &RawWriteRequest_Batch{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metas = append(m.Metas, &SSTMeta{})
			if err := m.Metas[len(m.Metas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DuplicateDetectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DuplicateDetectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DuplicateDetectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOnly = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCommitTs", wireType)
			}
			m.MinCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KvPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KvPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KvPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DuplicateDetectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DuplicateDetectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DuplicateDetectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyError == nil {
				m.KeyError = &Error{}
			}
			if err := m.KeyError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &KvPair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDelete = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoreTs", wireType)
			}
			m.RestoreTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestoreTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256 = append(m.Sha256[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha256 == nil {
				m.Sha256 = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartSnapshotTs", wireType)
			}
			m.StartSnapshotTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartSnapshotTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeOffset", wireType)
			}
			m.RangeOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeOffset |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeLength", wireType)
			}
			m.RangeLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeLength |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionType", wireType)
			}
			m.CompressionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionType |= (backup.CompressionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &KVMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewriteRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewriteRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageBackend == nil {
				m.StorageBackend = &backup.StorageBackend{}
			}
			if err := m.StorageBackend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageCacheId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageCacheId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CipherInfo == nil {
				m.CipherInfo = &backup.CipherInfo{}
			}
			if err := m.CipherInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metas = append(m.Metas, &KVMeta{})
			if err := m.Metas[len(m.Metas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewriteRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewriteRules = append(m.RewriteRules, &RewriteRule{})
			if err := m.RewriteRules[len(m.RewriteRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImportSstpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImportSstpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImportSstpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImportSstpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImportSstpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImportSstpb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("import_sstpb.proto", fileDescriptorImportSstpb) }

var fileDescriptorImportSstpb = []byte{
	// 2017 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4f, 0x73, 0x1b, 0x49,
	0x15, 0xf7, 0xe8, 0xbf, 0x9e, 0xfe, 0xa6, 0xe3, 0x75, 0x26, 0x4a, 0x62, 0x7b, 0x87, 0xec, 0xa2,
	0x38, 0x60, 0x07, 0x07, 0x72, 0xe0, 0x40, 0x6a, 0xfd, 0x87, 0x8d, 0x71, 0xbc, 0x36, 0x23, 0x13,
	0x0e, 0x1c, 0xa6, 0xc6, 0xa3, 0xb6, 0x3d, 0x68, 0x34, 0x33, 0x4c, 0xb7, 0xe4, 0xe8, 0xc2, 0x07,
	0xe0, 0x13, 0x50, 0x5c, 0x28, 0x38, 0x6d, 0x71, 0xa6, 0x8a, 0xe2, 0x1b, 0xec, 0x11, 0x6e, 0x9c,
	0x28, 0x2a, 0x7c, 0x11, 0xaa, 0x5f, 0xf7, 0x48, 0x33, 0x13, 0x39, 0x8a, 0x5d, 0xcb, 0x49, 0xdd,
	0xaf, 0xdf, 0xbc, 0x7e, 0xfd, 0xfe, 0xfc, 0xfa, 0xd7, 0x02, 0xe2, 0x0e, 0xc3, 0x20, 0xe2, 0x16,
	0x63, 0x3c, 0x3c, 0xdb, 0x0c, 0xa3, 0x80, 0x07, 0xa4, 0x9e, 0x94, 0x75, 0xea, 0x43, 0xca, 0xed,
	0x78, 0xad, 0xd3, 0xa0, 0x51, 0x14, 0x44, 0xb3, 0xe9, 0x60, 0x1c, 0x85, 0xce, 0x74, 0xba, 0x7c,
	0x11, 0x5c, 0x04, 0x38, 0xdc, 0x12, 0x23, 0x25, 0x6d, 0x45, 0x23, 0xc6, 0x71, 0xa8, 0x04, 0x70,
	0x36, 0xb5, 0x60, 0xf8, 0x70, 0xa7, 0x77, 0xe5, 0x72, 0xe7, 0xf2, 0x28, 0xe8, 0x53, 0x93, 0xfe,
	0x66, 0x44, 0x19, 0x27, 0xdf, 0x83, 0xc2, 0x30, 0xe8, 0x53, 0x5d, 0x5b, 0xd7, 0xba, 0xcd, 0x6d,
	0x7d, 0x33, 0xe5, 0x64, 0x42, 0x1d, 0xb5, 0xc8, 0x53, 0x28, 0x45, 0xb6, 0x7f, 0x41, 0x99, 0x9e,
	0x5b, 0xcf, 0x77, 0x6b, 0xdb, 0x77, 0xd3, 0xfa, 0xa6, 0x58, 0x33, 0x95, 0x8a, 0xb1, 0x0c, 0x24,
	0xb9, 0x1f, 0x0b, 0x03, 0x9f, 0x51, 0xa3, 0x0d, 0xcd, 0x2f, 0x29, 0x4f, 0xb8, 0x60, 0xbc, 0x84,
	0xd6, 0x54, 0x22, 0x95, 0x6e, 0xe6, 0x95, 0xb1, 0x05, 0x45, 0xdc, 0x99, 0x2c, 0x43, 0x91, 0x71,
	0x3b, 0xe2, 0xf8, 0x5d, 0xdd, 0x94, 0x13, 0xd2, 0x86, 0x3c, 0xf5, 0xfb, 0x7a, 0x0e, 0x65, 0x62,
	0x68, 0xfc, 0x29, 0x0f, 0xe5, 0x5e, 0xef, 0xf4, 0x88, 0x72, 0x9b, 0x10, 0x28, 0x8c, 0x46, 0x6e,
	0x5f, 0x7d, 0x82, 0x63, 0xf2, 0x04, 0x8a, 0x78, 0x06, 0xfc, 0xe6, 0x9a, 0x53, 0x4a, 0x0d, 0xb1,
	0xa5, 0x13, 0x39, 0xcf, 0xb7, 0xf5, 0xfc, 0xba, 0xd6, 0x6d, 0x98, 0x72, 0x42, 0x56, 0xa0, 0xe4,
	0x51, 0xff, 0x82, 0x5f, 0xea, 0x85, 0x75, 0xad, 0x5b, 0x30, 0xd5, 0x8c, 0xdc, 0x83, 0xb2, 0x73,
	0x6e, 0xf9, 0xf6, 0x90, 0xea, 0xc5, 0x75, 0xad, 0x5b, 0x35, 0x4b, 0xce, 0xf9, 0x57, 0xf6, 0x90,
	0x92, 0x07, 0x50, 0x8d, 0xe8, 0x85, 0x1b, 0xf8, 0x96, 0xdb, 0xd7, 0x4b, 0xf8, 0x4d, 0x45, 0x0a,
	0x0e, 0xfa, 0xe4, 0x05, 0xd4, 0xd5, 0x22, 0x0d, 0x03, 0xe7, 0x52, 0x2f, 0x2b, 0xaf, 0x54, 0xb9,
	0x98, 0xb8, 0xb6, 0x2f, 0x96, 0xcc, 0x5a, 0x34, 0x9b, 0x90, 0x0d, 0xb8, 0x43, 0xfd, 0xbe, 0x35,
	0xa0, 0x13, 0x8b, 0xbe, 0x75, 0xbc, 0x11, 0x73, 0xc7, 0x54, 0xaf, 0xac, 0x6b, 0xdd, 0x8a, 0xd9,
	0xa2, 0x7e, 0xff, 0x90, 0x4e, 0xf6, 0x63, 0xb1, 0x70, 0x80, 0x07, 0xdc, 0xf6, 0xac, 0xc1, 0x98,
	0xe9, 0x55, 0xe9, 0x00, 0x0a, 0x0e, 0xc7, 0x8c, 0xac, 0x41, 0x4d, 0x2e, 0x9e, 0x4d, 0x38, 0x65,
	0x3a, 0xe0, 0x32, 0xa0, 0x68, 0x47, 0x48, 0xc8, 0x0f, 0xa1, 0x66, 0x87, 0xae, 0x35, 0xa6, 0x11,
	0x73, 0x03, 0x5f, 0xaf, 0x61, 0xda, 0xee, 0x6e, 0xc6, 0x25, 0xfb, 0xc5, 0xc9, 0xc1, 0x1b, 0xb9,
	0x64, 0x82, 0x1d, 0xba, 0x6a, 0x2c, 0xf6, 0x74, 0xdc, 0xf0, 0x92, 0x46, 0x96, 0x3b, 0xd6, 0xeb,
	0x18, 0xff, 0x8a, 0x14, 0x1c, 0x8c, 0x8d, 0xdf, 0x42, 0xcd, 0xa4, 0x57, 0x91, 0xcb, 0xa9, 0x39,
	0xf2, 0x28, 0x79, 0x0c, 0xcd, 0xc0, 0x93, 0x67, 0x09, 0x23, 0x7a, 0xee, 0xbe, 0x55, 0x09, 0xab,
	0x07, 0x9e, 0x38, 0xc8, 0x09, 0xca, 0x84, 0x96, 0x4f, 0xaf, 0x92, 0x5a, 0x32, 0xeb, 0x75, 0x9f,
	0x5e, 0xcd, 0xb4, 0xbe, 0x03, 0x0d, 0xa1, 0xc5, 0xdd, 0x21, 0x65, 0xdc, 0x1e, 0x86, 0x98, 0xbb,
	0x02, 0x2a, 0x9d, 0xc6, 0x32, 0xe3, 0x57, 0xd0, 0xf8, 0x45, 0xe8, 0x05, 0x76, 0x3f, 0xee, 0x94,
	0xa7, 0x50, 0x10, 0x01, 0xc7, 0x7d, 0x6b, 0xdb, 0x9f, 0x64, 0x6a, 0x52, 0x56, 0xd3, 0xab, 0x25,
	0x13, 0x95, 0xc8, 0x32, 0x14, 0xfa, 0x36, 0xb7, 0xe5, 0xf6, 0x42, 0x2a, 0x66, 0x3b, 0x65, 0x28,
	0x3a, 0x97, 0x23, 0x7f, 0x20, 0x9a, 0x20, 0x36, 0xae, 0xda, 0xa2, 0x0f, 0x8d, 0x03, 0xd1, 0x35,
	0x3c, 0xde, 0x6e, 0x03, 0xca, 0x4e, 0xe0, 0x73, 0xfa, 0x96, 0xab, 0x1d, 0xdb, 0xd3, 0x70, 0xee,
	0x4a, 0xb9, 0x19, 0x2b, 0x90, 0xef, 0x42, 0x9e, 0x31, 0xae, 0xaa, 0x75, 0xbe, 0x67, 0xa6, 0xd0,
	0x30, 0x06, 0x40, 0x8e, 0x46, 0x1e, 0x77, 0x6f, 0xbf, 0xd5, 0x13, 0x28, 0x30, 0xc6, 0xe3, 0xfe,
	0xbf, 0x66, 0x2f, 0x54, 0x31, 0x5e, 0x40, 0x33, 0xde, 0x47, 0xb5, 0xf5, 0x63, 0x28, 0x22, 0xa8,
	0xa9, 0x6d, 0x9a, 0x9b, 0x31, 0xc4, 0xed, 0x8b, 0x5f, 0x53, 0x2e, 0x1a, 0xbf, 0xd3, 0xa0, 0xb9,
	0x1b, 0x0c, 0x43, 0xdb, 0x99, 0x7a, 0x38, 0x6d, 0x48, 0x6d, 0x61, 0x43, 0x7e, 0x0a, 0xf5, 0x60,
	0xc4, 0xc3, 0x11, 0xb7, 0x3c, 0x3a, 0xa6, 0x1e, 0x06, 0xa5, 0x68, 0xd6, 0xa4, 0xec, 0xb5, 0x10,
	0x25, 0xcf, 0x9b, 0x5f, 0x70, 0x5e, 0xe3, 0x0e, 0xb4, 0xa6, 0xbe, 0xa8, 0x54, 0xfd, 0x33, 0x0f,
	0xad, 0xbd, 0xe0, 0xca, 0x4f, 0x16, 0xc7, 0xf7, 0x17, 0x67, 0x60, 0xa7, 0xf0, 0xcd, 0xbf, 0xd7,
	0x96, 0x30, 0x0f, 0x02, 0x74, 0x10, 0x04, 0xaa, 0x08, 0x02, 0x38, 0x26, 0x3b, 0xa2, 0xcb, 0xb1,
	0xe0, 0xad, 0x68, 0xe4, 0x51, 0xbd, 0x81, 0xb6, 0xee, 0x67, 0x8e, 0x3a, 0x6b, 0x09, 0x65, 0xaf,
	0x16, 0x25, 0xba, 0xe4, 0x25, 0xb4, 0x18, 0x0f, 0x22, 0xfb, 0x82, 0x5a, 0x67, 0xb6, 0x33, 0x10,
	0xb0, 0xd7, 0x44, 0x33, 0x2b, 0x9b, 0x62, 0x3e, 0x0a, 0x37, 0x7b, 0x72, 0x79, 0x47, 0xae, 0x9a,
	0x4d, 0x96, 0x9a, 0x93, 0x0e, 0x54, 0x5d, 0x66, 0x45, 0xf6, 0x95, 0x35, 0x18, 0xeb, 0x2d, 0x84,
	0x8a, 0xb2, 0xcb, 0x4c, 0xfb, 0xea, 0x70, 0x4c, 0x9e, 0x43, 0x2d, 0x6e, 0x57, 0xff, 0x3c, 0xd0,
	0xdb, 0x68, 0x98, 0xc4, 0x86, 0x77, 0x65, 0xe3, 0xfa, 0xe7, 0x81, 0x09, 0xce, 0x74, 0x4c, 0xba,
	0xd0, 0x8e, 0x3d, 0x72, 0x6c, 0xe7, 0x92, 0x0a, 0x7c, 0xbb, 0x83, 0xa7, 0x8e, 0xb7, 0xde, 0x15,
	0xe2, 0x83, 0x3e, 0xd9, 0x13, 0xe7, 0xc7, 0x68, 0x5a, 0x7c, 0x12, 0x52, 0x9d, 0x20, 0x88, 0x7c,
	0x9a, 0x3e, 0x7f, 0x26, 0xee, 0xa7, 0x93, 0x90, 0x8a, 0x08, 0x4c, 0x27, 0xc9, 0xdc, 0xde, 0x5d,
	0x90, 0xdb, 0x9f, 0x15, 0x2a, 0x95, 0x76, 0xd5, 0xcc, 0x8f, 0x22, 0xcf, 0x30, 0xa1, 0x88, 0x35,
	0x48, 0x74, 0x28, 0x0f, 0x29, 0x63, 0xb6, 0xaa, 0xb5, 0xaa, 0x19, 0x4f, 0xc9, 0x16, 0xd4, 0x84,
	0xc7, 0xd4, 0x92, 0x25, 0x9c, 0x9b, 0x5b, 0xc2, 0x80, 0x2a, 0x38, 0x36, 0xfe, 0xa6, 0x41, 0x7b,
	0xe6, 0xaf, 0x6a, 0x81, 0xad, 0xc5, 0x95, 0xac, 0x12, 0xab, 0xea, 0xf9, 0x3e, 0x54, 0x5c, 0x66,
	0xd1, 0x61, 0xc8, 0x27, 0xb8, 0x27, 0x26, 0x64, 0x5f, 0x4c, 0x45, 0x57, 0x48, 0x5f, 0xf2, 0xf3,
	0x6c, 0x25, 0x7b, 0x6a, 0x76, 0x4d, 0x15, 0xe6, 0x5f, 0x53, 0xc5, 0xe4, 0x35, 0x65, 0xbc, 0x84,
	0x87, 0x3d, 0xca, 0x63, 0xdf, 0x7b, 0x21, 0xa5, 0xfd, 0xd7, 0xee, 0xd0, 0x9d, 0xb6, 0xe3, 0x1a,
	0xd4, 0x98, 0x10, 0x5a, 0x9e, 0x90, 0xe2, 0x51, 0x0a, 0x26, 0xb0, 0xa9, 0x9e, 0xb1, 0x06, 0x8f,
	0xae, 0x31, 0xa0, 0x7a, 0x28, 0x84, 0xc2, 0x89, 0xed, 0x46, 0xe2, 0x6e, 0x1e, 0xd0, 0x89, 0xc2,
	0x72, 0x31, 0x14, 0x9e, 0x8e, 0x6d, 0x6f, 0x44, 0x15, 0x72, 0xcb, 0x09, 0xf9, 0x0c, 0x72, 0x81,
	0xc4, 0xe9, 0x66, 0xb6, 0xbd, 0x84, 0x9d, 0xcd, 0xe3, 0x13, 0x33, 0x17, 0x84, 0xc6, 0x7d, 0xc8,
	0x1d, 0x9f, 0x90, 0x32, 0xe4, 0x4f, 0x46, 0xbc, 0xbd, 0x44, 0x00, 0x4a, 0x7b, 0xd4, 0xa3, 0x9c,
	0xb6, 0x35, 0xa3, 0x07, 0xf0, 0x4b, 0xd1, 0x27, 0x3b, 0x36, 0x77, 0x2e, 0xf1, 0xea, 0x09, 0x86,
	0x43, 0x97, 0x5b, 0x9c, 0x29, 0xff, 0x2b, 0x52, 0x70, 0xca, 0x48, 0x17, 0x8a, 0xa1, 0xed, 0x46,
	0x31, 0xc8, 0x91, 0xf7, 0xf7, 0x33, 0xa5, 0x82, 0xf1, 0x67, 0x0d, 0xea, 0x68, 0xf5, 0x56, 0x97,
	0xc4, 0x33, 0x28, 0x9e, 0x09, 0x6f, 0x54, 0x2d, 0x65, 0x68, 0xce, 0xcc, 0xdb, 0x57, 0x4b, 0xa6,
	0x54, 0xbc, 0x09, 0x72, 0xcd, 0x2e, 0x9b, 0x0b, 0x68, 0x28, 0x1f, 0x55, 0x0d, 0x3e, 0x49, 0xc3,
	0xf0, 0x87, 0xea, 0xe6, 0x29, 0x14, 0x85, 0xab, 0x0b, 0xf0, 0x5e, 0xea, 0x88, 0x2b, 0xd3, 0xb4,
	0xaf, 0x12, 0x51, 0x6e, 0x43, 0x9e, 0x73, 0x4f, 0xc5, 0x57, 0x0c, 0x3f, 0x3e, 0xb4, 0xa4, 0x09,
	0x39, 0xce, 0xd4, 0xcd, 0x9c, 0xe3, 0xcc, 0xf8, 0x5a, 0x83, 0x56, 0x6c, 0xfd, 0x56, 0xd1, 0x7e,
	0x9e, 0x8e, 0xf6, 0x83, 0x6c, 0xe7, 0x5d, 0x7d, 0x6b, 0x01, 0xff, 0x35, 0xb4, 0x67, 0x9e, 0xfe,
	0x9f, 0x63, 0xfe, 0x77, 0x0d, 0x56, 0xf6, 0x46, 0xa1, 0xe7, 0x3a, 0x36, 0xa7, 0x7b, 0x94, 0x53,
	0xe7, 0x56, 0xd7, 0xfa, 0x03, 0xa8, 0x22, 0x59, 0x16, 0xd4, 0x49, 0x75, 0x5e, 0x05, 0x05, 0x87,
	0x74, 0x22, 0x58, 0xab, 0xe2, 0x91, 0x18, 0x84, 0xba, 0x59, 0x92, 0xec, 0x51, 0x60, 0x93, 0xa0,
	0x5a, 0x81, 0xef, 0x4d, 0x10, 0x58, 0x2a, 0x66, 0x79, 0x40, 0x27, 0xc7, 0xbe, 0x37, 0x21, 0x06,
	0x34, 0x86, 0xae, 0x6f, 0xcd, 0x9a, 0x4c, 0x22, 0x4c, 0x6d, 0xe8, 0xfa, 0xbb, 0xaa, 0xcf, 0x8c,
	0x23, 0x28, 0x1d, 0x8e, 0x6f, 0x04, 0x03, 0xa9, 0xb6, 0xcd, 0xa7, 0xdb, 0xd6, 0xf8, 0x8b, 0x06,
	0xf7, 0xde, 0x0b, 0x85, 0x0a, 0xff, 0x0f, 0x66, 0x14, 0xfa, 0x03, 0x04, 0x24, 0x66, 0xcf, 0x98,
	0x86, 0x67, 0x50, 0x45, 0xe6, 0x9c, 0x40, 0xfb, 0xb9, 0x59, 0x13, 0x21, 0x90, 0x5f, 0x6c, 0xc4,
	0xc5, 0x9d, 0xc7, 0xc4, 0x2d, 0xa7, 0xb5, 0xe5, 0x51, 0x63, 0xe4, 0xf8, 0x63, 0x1e, 0x4a, 0x87,
	0x6f, 0xe2, 0x17, 0x08, 0x92, 0x01, 0x2d, 0x41, 0x06, 0x66, 0xc8, 0x9c, 0x4b, 0x3d, 0x20, 0x9a,
	0x90, 0x73, 0xce, 0xf1, 0xe4, 0x55, 0x33, 0xe7, 0x9c, 0x8b, 0x80, 0xb8, 0xcc, 0xea, 0x23, 0xc8,
	0xa9, 0x14, 0x54, 0x5c, 0x26, 0x41, 0x8f, 0x3c, 0x02, 0x88, 0xa8, 0xbc, 0xb3, 0xa6, 0x09, 0xa8,
	0x2a, 0xc9, 0x29, 0x4b, 0xe7, 0xbc, 0x74, 0x7d, 0xce, 0xcb, 0xa9, 0x9c, 0xaf, 0x40, 0x89, 0x5d,
	0xda, 0xdb, 0x3f, 0x7a, 0x81, 0x2f, 0x89, 0xba, 0xa9, 0x66, 0xe2, 0xb1, 0x21, 0xad, 0x31, 0xdf,
	0x0e, 0xd9, 0x65, 0x80, 0x29, 0x92, 0x0f, 0x89, 0x16, 0x2e, 0xf4, 0x94, 0xfc, 0x94, 0x89, 0xba,
	0x91, 0xba, 0x3c, 0x7e, 0x4c, 0x94, 0x71, 0x7e, 0xca, 0x04, 0x7d, 0xc3, 0x7b, 0xcf, 0x0a, 0xce,
	0xcf, 0x19, 0xe5, 0xf8, 0x94, 0x28, 0x98, 0x35, 0x94, 0x1d, 0xa3, 0x68, 0xa6, 0xa2, 0x22, 0x54,
	0x4f, 0xa8, 0xbc, 0x96, 0x61, 0xda, 0x81, 0xb6, 0x13, 0x0c, 0xc3, 0x88, 0x32, 0xf1, 0xd0, 0x90,
	0x7c, 0xa2, 0x81, 0x97, 0xc7, 0xbd, 0x29, 0x5f, 0x99, 0xad, 0x23, 0x8b, 0x68, 0x39, 0x69, 0x81,
	0xf1, 0xd7, 0x3c, 0xd4, 0xbf, 0x08, 0x43, 0x6f, 0x12, 0xf7, 0x53, 0x37, 0x85, 0x36, 0xd9, 0xec,
	0xbe, 0x91, 0xcc, 0x17, 0xa1, 0x26, 0x4b, 0xe5, 0x72, 0xdf, 0x0e, 0x95, 0xcb, 0xdf, 0x88, 0xca,
	0x25, 0xda, 0xbf, 0xb0, 0xa8, 0xfd, 0xe7, 0xb1, 0xb4, 0xe2, 0x5c, 0x96, 0x96, 0x21, 0x81, 0xb5,
	0x8f, 0x22, 0x81, 0x1b, 0x31, 0xa2, 0xd5, 0xe7, 0x36, 0xc6, 0x9b, 0x04, 0xa0, 0x91, 0x9f, 0x40,
	0x23, 0x19, 0x3b, 0xa6, 0x37, 0xf0, 0x9b, 0xeb, 0x83, 0x67, 0xd6, 0x13, 0x61, 0x63, 0xc6, 0x00,
	0x1a, 0x2a, 0x6b, 0xb7, 0x65, 0x5c, 0x53, 0xa8, 0xce, 0x2d, 0x82, 0x6a, 0xe3, 0x73, 0xa8, 0xef,
	0x7a, 0xd4, 0x8e, 0xe2, 0x12, 0x59, 0x81, 0x52, 0xe2, 0x75, 0x5a, 0x35, 0xd5, 0xcc, 0xf8, 0x31,
	0x34, 0x94, 0xde, 0x8d, 0xaf, 0x83, 0x8d, 0xc7, 0x00, 0xb3, 0x7f, 0x3c, 0x04, 0xa5, 0xf9, 0x2a,
	0x88, 0x86, 0xb6, 0x27, 0xe9, 0xcd, 0x01, 0x7e, 0xd6, 0xd6, 0x36, 0xb6, 0xe0, 0xee, 0x1c, 0x6e,
	0x2c, 0x54, 0x5e, 0xd3, 0x0b, 0xdb, 0x99, 0xb4, 0x97, 0x48, 0x1d, 0x2a, 0x87, 0x74, 0xc2, 0x42,
	0xdb, 0xa1, 0x6d, 0x6d, 0xfb, 0x0f, 0x15, 0xa8, 0xca, 0xaf, 0x7b, 0xbd, 0x53, 0xf2, 0xf3, 0xd4,
	0x26, 0x6b, 0xd7, 0xfe, 0xe1, 0x22, 0x4d, 0x77, 0xd6, 0xaf, 0x57, 0x50, 0x04, 0x6f, 0x89, 0xbc,
	0x82, 0xb2, 0xfa, 0x5b, 0x87, 0x3c, 0x4c, 0xab, 0xa7, 0xff, 0xff, 0xe9, 0x3c, 0xba, 0x66, 0x75,
	0x6a, 0xe9, 0x4b, 0x28, 0xc9, 0xd7, 0x32, 0xc9, 0x5c, 0xda, 0xa9, 0x07, 0x7a, 0xe7, 0xe1, 0xfc,
	0xc5, 0xd8, 0x4c, 0x57, 0x23, 0xfb, 0x50, 0x92, 0x2f, 0xd2, 0xac, 0xa1, 0xd4, 0x7b, 0x38, 0x6b,
	0x28, 0xfd, 0x88, 0x95, 0x27, 0x53, 0x6f, 0xc2, 0xec, 0xc9, 0xd2, 0xcf, 0xd6, 0xec, 0xc9, 0xb2,
	0x0f, 0xc9, 0x25, 0x12, 0xc1, 0x27, 0x73, 0x79, 0x32, 0xd9, 0xc8, 0x04, 0xf8, 0x03, 0x6c, 0xbc,
	0xf3, 0xf4, 0xa3, 0x74, 0xa7, 0x7b, 0x1e, 0x42, 0x25, 0x5e, 0x27, 0x8f, 0x3e, 0xf8, 0xba, 0xea,
	0xac, 0x5e, 0xb7, 0x3c, 0x35, 0xb6, 0x07, 0x45, 0xe4, 0x39, 0xa4, 0x33, 0x87, 0xbc, 0xc6, 0x66,
	0x1e, 0xcc, 0x5d, 0x4b, 0xe4, 0xe5, 0x08, 0x2a, 0x31, 0x61, 0xca, 0xba, 0x94, 0xa1, 0x7c, 0x59,
	0x97, 0xb2, 0x3c, 0x0b, 0xcd, 0x1d, 0x43, 0x2d, 0xf1, 0x2f, 0x07, 0xc9, 0x14, 0xeb, 0xfb, 0x7f,
	0x80, 0x2c, 0x4c, 0xf8, 0x19, 0xb4, 0x32, 0xc4, 0x82, 0x3c, 0xce, 0x84, 0x66, 0x2e, 0x05, 0xeb,
	0x7c, 0xb6, 0x40, 0x2b, 0xde, 0xe1, 0x99, 0x46, 0x76, 0xa0, 0x88, 0xb8, 0x95, 0x8d, 0x64, 0xf2,
	0x0a, 0xca, 0x46, 0x32, 0x05, 0x74, 0xd8, 0x28, 0x80, 0x30, 0xf3, 0x53, 0xd7, 0xa3, 0x2c, 0x6b,
	0x28, 0x09, 0x54, 0x59, 0x43, 0x29, 0x70, 0x32, 0x96, 0x76, 0x3e, 0xff, 0xd7, 0xd7, 0x15, 0xed,
	0x9b, 0x77, 0xab, 0xda, 0x3f, 0xde, 0xad, 0x6a, 0xff, 0x79, 0xb7, 0xaa, 0xfd, 0xfe, 0xbf, 0xab,
	0x4b, 0xd0, 0x0e, 0xa2, 0x8b, 0x4d, 0xee, 0x0e, 0xc6, 0x9b, 0x83, 0x31, 0xfe, 0xa5, 0x7c, 0x56,
	0xc2, 0x9f, 0xe7, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x21, 0xbb, 0xea, 0x1e, 0xdc, 0x16, 0x00,
	0x00,
}
