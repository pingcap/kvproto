// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tici.proto

package tici

import (
	"context"
	"fmt"
	"io"
	"math"
	math_bits "math/bits"

	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ErrorCode int32

const (
	ErrorCode_SUCCESS              ErrorCode = 0
	ErrorCode_UNKNOWN_ERROR        ErrorCode = 1
	ErrorCode_INVALID_ARGUMENTS    ErrorCode = 2
	ErrorCode_TRY_AGAIN            ErrorCode = 3
	ErrorCode_SHARD_NOT_FOUND      ErrorCode = 11
	ErrorCode_INDEX_NOT_FOUND      ErrorCode = 12
	ErrorCode_WORKER_NOT_FOUND     ErrorCode = 13
	ErrorCode_SHARD_NOT_SCHEDULED  ErrorCode = 14
	ErrorCode_COMPACTION_NOT_FOUND ErrorCode = 15
	ErrorCode_FRAG_RANGE_MISMATCH  ErrorCode = 16
)

var ErrorCode_name = map[int32]string{
	0:  "SUCCESS",
	1:  "UNKNOWN_ERROR",
	2:  "INVALID_ARGUMENTS",
	3:  "TRY_AGAIN",
	11: "SHARD_NOT_FOUND",
	12: "INDEX_NOT_FOUND",
	13: "WORKER_NOT_FOUND",
	14: "SHARD_NOT_SCHEDULED",
	15: "COMPACTION_NOT_FOUND",
	16: "FRAG_RANGE_MISMATCH",
}

var ErrorCode_value = map[string]int32{
	"SUCCESS":              0,
	"UNKNOWN_ERROR":        1,
	"INVALID_ARGUMENTS":    2,
	"TRY_AGAIN":            3,
	"SHARD_NOT_FOUND":      11,
	"INDEX_NOT_FOUND":      12,
	"WORKER_NOT_FOUND":     13,
	"SHARD_NOT_SCHEDULED":  14,
	"COMPACTION_NOT_FOUND": 15,
	"FRAG_RANGE_MISMATCH":  16,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}

func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{0}
}

type GetIndexProgressResponse_State int32

const (
	GetIndexProgressResponse_PENDING   GetIndexProgressResponse_State = 0
	GetIndexProgressResponse_RUNNING   GetIndexProgressResponse_State = 1
	GetIndexProgressResponse_COMPLETED GetIndexProgressResponse_State = 2
	GetIndexProgressResponse_FAILED    GetIndexProgressResponse_State = 3
	GetIndexProgressResponse_NOTFOUND  GetIndexProgressResponse_State = 4
	GetIndexProgressResponse_ERROR     GetIndexProgressResponse_State = 5
)

var GetIndexProgressResponse_State_name = map[int32]string{
	0: "PENDING",
	1: "RUNNING",
	2: "COMPLETED",
	3: "FAILED",
	4: "NOTFOUND",
	5: "ERROR",
}

var GetIndexProgressResponse_State_value = map[string]int32{
	"PENDING":   0,
	"RUNNING":   1,
	"COMPLETED": 2,
	"FAILED":    3,
	"NOTFOUND":  4,
	"ERROR":     5,
}

func (x GetIndexProgressResponse_State) String() string {
	return proto.EnumName(GetIndexProgressResponse_State_name, int32(x))
}

func (GetIndexProgressResponse_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{11, 0}
}

// Key range definition
type KeyRange struct {
	// Inclusive lower key bound
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// Exclusive upper key bound
	EndKey               []byte   `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyRange) Reset()         { *m = KeyRange{} }
func (m *KeyRange) String() string { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()    {}
func (*KeyRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{0}
}
func (m *KeyRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRange.Merge(m, src)
}
func (m *KeyRange) XXX_Size() int {
	return m.Size()
}
func (m *KeyRange) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRange.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRange proto.InternalMessageInfo

func (m *KeyRange) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *KeyRange) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

// Shard local cache information
type ShardLocalCacheInfo struct {
	Shard                *ShardManifestHeader `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard,omitempty"`
	LocalCacheAddrs      []string             `protobuf:"bytes,2,rep,name=local_cache_addrs,json=localCacheAddrs,proto3" json:"local_cache_addrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ShardLocalCacheInfo) Reset()         { *m = ShardLocalCacheInfo{} }
func (m *ShardLocalCacheInfo) String() string { return proto.CompactTextString(m) }
func (*ShardLocalCacheInfo) ProtoMessage()    {}
func (*ShardLocalCacheInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{1}
}
func (m *ShardLocalCacheInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardLocalCacheInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardLocalCacheInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardLocalCacheInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardLocalCacheInfo.Merge(m, src)
}
func (m *ShardLocalCacheInfo) XXX_Size() int {
	return m.Size()
}
func (m *ShardLocalCacheInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardLocalCacheInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ShardLocalCacheInfo proto.InternalMessageInfo

func (m *ShardLocalCacheInfo) GetShard() *ShardManifestHeader {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *ShardLocalCacheInfo) GetLocalCacheAddrs() []string {
	if m != nil {
		return m.LocalCacheAddrs
	}
	return nil
}

// Request to get shard local cache information
type GetShardLocalCacheRequest struct {
	// Table ID to filter shards
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID to filter shards
	IndexId    int64       `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	KeyspaceId uint32      `protobuf:"varint,3,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	KeyRanges  []*KeyRange `protobuf:"bytes,4,rep,name=key_ranges,json=keyRanges,proto3" json:"key_ranges,omitempty"`
	// at most `limit` shards can be returned
	Limit                int32    `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetShardLocalCacheRequest) Reset()         { *m = GetShardLocalCacheRequest{} }
func (m *GetShardLocalCacheRequest) String() string { return proto.CompactTextString(m) }
func (*GetShardLocalCacheRequest) ProtoMessage()    {}
func (*GetShardLocalCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{2}
}
func (m *GetShardLocalCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardLocalCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardLocalCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardLocalCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardLocalCacheRequest.Merge(m, src)
}
func (m *GetShardLocalCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetShardLocalCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardLocalCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardLocalCacheRequest proto.InternalMessageInfo

func (m *GetShardLocalCacheRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetShardLocalCacheRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *GetShardLocalCacheRequest) GetKeyspaceId() uint32 {
	if m != nil {
		return m.KeyspaceId
	}
	return 0
}

func (m *GetShardLocalCacheRequest) GetKeyRanges() []*KeyRange {
	if m != nil {
		return m.KeyRanges
	}
	return nil
}

func (m *GetShardLocalCacheRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// Response containing shard local cache information
type GetShardLocalCacheResponse struct {
	Status               int32                  `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	ShardLocalCacheInfos []*ShardLocalCacheInfo `protobuf:"bytes,2,rep,name=shard_local_cache_infos,json=shardLocalCacheInfos,proto3" json:"shard_local_cache_infos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *GetShardLocalCacheResponse) Reset()         { *m = GetShardLocalCacheResponse{} }
func (m *GetShardLocalCacheResponse) String() string { return proto.CompactTextString(m) }
func (*GetShardLocalCacheResponse) ProtoMessage()    {}
func (*GetShardLocalCacheResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{3}
}
func (m *GetShardLocalCacheResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardLocalCacheResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardLocalCacheResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardLocalCacheResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardLocalCacheResponse.Merge(m, src)
}
func (m *GetShardLocalCacheResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetShardLocalCacheResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardLocalCacheResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardLocalCacheResponse proto.InternalMessageInfo

func (m *GetShardLocalCacheResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *GetShardLocalCacheResponse) GetShardLocalCacheInfos() []*ShardLocalCacheInfo {
	if m != nil {
		return m.ShardLocalCacheInfos
	}
	return nil
}

type ShardManifestHeader struct {
	ShardId              uint64   `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	StartKey             []byte   `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey               []byte   `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Epoch                uint64   `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Seq                  uint64   `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardManifestHeader) Reset()         { *m = ShardManifestHeader{} }
func (m *ShardManifestHeader) String() string { return proto.CompactTextString(m) }
func (*ShardManifestHeader) ProtoMessage()    {}
func (*ShardManifestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{4}
}
func (m *ShardManifestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardManifestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardManifestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardManifestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardManifestHeader.Merge(m, src)
}
func (m *ShardManifestHeader) XXX_Size() int {
	return m.Size()
}
func (m *ShardManifestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardManifestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ShardManifestHeader proto.InternalMessageInfo

func (m *ShardManifestHeader) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *ShardManifestHeader) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *ShardManifestHeader) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *ShardManifestHeader) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ShardManifestHeader) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type S3Location struct {
	Bucket               string   `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix               string   `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S3Location) Reset()         { *m = S3Location{} }
func (m *S3Location) String() string { return proto.CompactTextString(m) }
func (*S3Location) ProtoMessage()    {}
func (*S3Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{5}
}
func (m *S3Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S3Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S3Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3Location.Merge(m, src)
}
func (m *S3Location) XXX_Size() int {
	return m.Size()
}
func (m *S3Location) XXX_DiscardUnknown() {
	xxx_messageInfo_S3Location.DiscardUnknown(m)
}

var xxx_messageInfo_S3Location proto.InternalMessageInfo

func (m *S3Location) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *S3Location) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// CreateIndexRequest is a request to create an index
type CreateIndexRequest struct {
	DatabaseName string `protobuf:"bytes,1,opt,name=database_name,json=databaseName,proto3" json:"database_name,omitempty"`
	TableInfo    []byte `protobuf:"bytes,2,opt,name=table_info,json=tableInfo,proto3" json:"table_info,omitempty"`
	IndexId      int64  `protobuf:"varint,3,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	// Keyspace ID
	KeyspaceId           uint32   `protobuf:"varint,4,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateIndexRequest) Reset()         { *m = CreateIndexRequest{} }
func (m *CreateIndexRequest) String() string { return proto.CompactTextString(m) }
func (*CreateIndexRequest) ProtoMessage()    {}
func (*CreateIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{6}
}
func (m *CreateIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndexRequest.Merge(m, src)
}
func (m *CreateIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndexRequest proto.InternalMessageInfo

func (m *CreateIndexRequest) GetDatabaseName() string {
	if m != nil {
		return m.DatabaseName
	}
	return ""
}

func (m *CreateIndexRequest) GetTableInfo() []byte {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

func (m *CreateIndexRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *CreateIndexRequest) GetKeyspaceId() uint32 {
	if m != nil {
		return m.KeyspaceId
	}
	return 0
}

// CreateIndexResponse is a response to the index creation request
type CreateIndexResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Created index ID
	IndexId              string   `protobuf:"bytes,3,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateIndexResponse) Reset()         { *m = CreateIndexResponse{} }
func (m *CreateIndexResponse) String() string { return proto.CompactTextString(m) }
func (*CreateIndexResponse) ProtoMessage()    {}
func (*CreateIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{7}
}
func (m *CreateIndexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndexResponse.Merge(m, src)
}
func (m *CreateIndexResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndexResponse proto.InternalMessageInfo

func (m *CreateIndexResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *CreateIndexResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CreateIndexResponse) GetIndexId() string {
	if m != nil {
		return m.IndexId
	}
	return ""
}

// DropIndexRequest is a request to drop an index
type DropIndexRequest struct {
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	// Keyspace ID
	KeyspaceId           uint32   `protobuf:"varint,3,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropIndexRequest) Reset()         { *m = DropIndexRequest{} }
func (m *DropIndexRequest) String() string { return proto.CompactTextString(m) }
func (*DropIndexRequest) ProtoMessage()    {}
func (*DropIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{8}
}
func (m *DropIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndexRequest.Merge(m, src)
}
func (m *DropIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *DropIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndexRequest proto.InternalMessageInfo

func (m *DropIndexRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DropIndexRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *DropIndexRequest) GetKeyspaceId() uint32 {
	if m != nil {
		return m.KeyspaceId
	}
	return 0
}

// DropIndexResponse is a response to the index drop request
type DropIndexResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage         string   `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DropIndexResponse) Reset()         { *m = DropIndexResponse{} }
func (m *DropIndexResponse) String() string { return proto.CompactTextString(m) }
func (*DropIndexResponse) ProtoMessage()    {}
func (*DropIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{9}
}
func (m *DropIndexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndexResponse.Merge(m, src)
}
func (m *DropIndexResponse) XXX_Size() int {
	return m.Size()
}
func (m *DropIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndexResponse proto.InternalMessageInfo

func (m *DropIndexResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *DropIndexResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// GetIndexProgressRequest is a request to get the progress of an index build
type GetIndexProgressRequest struct {
	// Table ID
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID
	IndexId              int64    `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetIndexProgressRequest) Reset()         { *m = GetIndexProgressRequest{} }
func (m *GetIndexProgressRequest) String() string { return proto.CompactTextString(m) }
func (*GetIndexProgressRequest) ProtoMessage()    {}
func (*GetIndexProgressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{10}
}
func (m *GetIndexProgressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexProgressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexProgressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexProgressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexProgressRequest.Merge(m, src)
}
func (m *GetIndexProgressRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexProgressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexProgressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexProgressRequest proto.InternalMessageInfo

func (m *GetIndexProgressRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetIndexProgressRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

// GetIndexProgressResponse is a response containing index build progress
type GetIndexProgressResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Number of documents indexed so far
	DocumentCount uint64 `protobuf:"varint,3,opt,name=document_count,json=documentCount,proto3" json:"document_count,omitempty"`
	// Build task state (PENDING, RUNNING, COMPLETED, FAILED)
	State GetIndexProgressResponse_State `protobuf:"varint,4,opt,name=state,proto3,enum=tici.GetIndexProgressResponse_State" json:"state,omitempty"`
	// Whether index has been uploaded to S3
	IsUploaded bool `protobuf:"varint,5,opt,name=is_uploaded,json=isUploaded,proto3" json:"is_uploaded,omitempty"`
	// Last S3 upload time in RFC3339 format
	LastUploadTime string `protobuf:"bytes,6,opt,name=last_upload_time,json=lastUploadTime,proto3" json:"last_upload_time,omitempty"`
	// S3 path where the index is stored
	S3Path               string   `protobuf:"bytes,7,opt,name=s3_path,json=s3Path,proto3" json:"s3_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetIndexProgressResponse) Reset()         { *m = GetIndexProgressResponse{} }
func (m *GetIndexProgressResponse) String() string { return proto.CompactTextString(m) }
func (*GetIndexProgressResponse) ProtoMessage()    {}
func (*GetIndexProgressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{11}
}
func (m *GetIndexProgressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexProgressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexProgressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexProgressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexProgressResponse.Merge(m, src)
}
func (m *GetIndexProgressResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexProgressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexProgressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexProgressResponse proto.InternalMessageInfo

func (m *GetIndexProgressResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *GetIndexProgressResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *GetIndexProgressResponse) GetDocumentCount() uint64 {
	if m != nil {
		return m.DocumentCount
	}
	return 0
}

func (m *GetIndexProgressResponse) GetState() GetIndexProgressResponse_State {
	if m != nil {
		return m.State
	}
	return GetIndexProgressResponse_PENDING
}

func (m *GetIndexProgressResponse) GetIsUploaded() bool {
	if m != nil {
		return m.IsUploaded
	}
	return false
}

func (m *GetIndexProgressResponse) GetLastUploadTime() string {
	if m != nil {
		return m.LastUploadTime
	}
	return ""
}

func (m *GetIndexProgressResponse) GetS3Path() string {
	if m != nil {
		return m.S3Path
	}
	return ""
}

type GetImportStoragePrefixRequest struct {
	// TiDB unique task ID for this Import Into/Index Backfilling job.
	TidbTaskId string `protobuf:"bytes,1,opt,name=tidb_task_id,json=tidbTaskId,proto3" json:"tidb_task_id,omitempty"`
	// Table ID of the target table.
	TableId int64 `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID of the target index. If this is an Import Into job that relates
	// to multiple indexes, this field should contain all the index IDs.
	IndexIds []int64 `protobuf:"varint,3,rep,packed,name=index_ids,json=indexIds,proto3" json:"index_ids,omitempty"`
	// Keyspace ID
	KeyspaceId           uint32   `protobuf:"varint,4,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetImportStoragePrefixRequest) Reset()         { *m = GetImportStoragePrefixRequest{} }
func (m *GetImportStoragePrefixRequest) String() string { return proto.CompactTextString(m) }
func (*GetImportStoragePrefixRequest) ProtoMessage()    {}
func (*GetImportStoragePrefixRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{12}
}
func (m *GetImportStoragePrefixRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImportStoragePrefixRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImportStoragePrefixRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImportStoragePrefixRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImportStoragePrefixRequest.Merge(m, src)
}
func (m *GetImportStoragePrefixRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetImportStoragePrefixRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImportStoragePrefixRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetImportStoragePrefixRequest proto.InternalMessageInfo

func (m *GetImportStoragePrefixRequest) GetTidbTaskId() string {
	if m != nil {
		return m.TidbTaskId
	}
	return ""
}

func (m *GetImportStoragePrefixRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetImportStoragePrefixRequest) GetIndexIds() []int64 {
	if m != nil {
		return m.IndexIds
	}
	return nil
}

func (m *GetImportStoragePrefixRequest) GetKeyspaceId() uint32 {
	if m != nil {
		return m.KeyspaceId
	}
	return 0
}

type GetImportStoragePrefixResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Optional human‑readable diagnostics, only defined when status is not
	// SUCCESS.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// The import index job_id in TiCI
	JobId uint64 `protobuf:"varint,3,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// The cloud storage prefix where the import data should be written.
	// The format is "s3://bucket/prefix/".
	StorageUri           string   `protobuf:"bytes,4,opt,name=storage_uri,json=storageUri,proto3" json:"storage_uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetImportStoragePrefixResponse) Reset()         { *m = GetImportStoragePrefixResponse{} }
func (m *GetImportStoragePrefixResponse) String() string { return proto.CompactTextString(m) }
func (*GetImportStoragePrefixResponse) ProtoMessage()    {}
func (*GetImportStoragePrefixResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{13}
}
func (m *GetImportStoragePrefixResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImportStoragePrefixResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImportStoragePrefixResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImportStoragePrefixResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImportStoragePrefixResponse.Merge(m, src)
}
func (m *GetImportStoragePrefixResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetImportStoragePrefixResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImportStoragePrefixResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetImportStoragePrefixResponse proto.InternalMessageInfo

func (m *GetImportStoragePrefixResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *GetImportStoragePrefixResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *GetImportStoragePrefixResponse) GetJobId() uint64 {
	if m != nil {
		return m.JobId
	}
	return 0
}

func (m *GetImportStoragePrefixResponse) GetStorageUri() string {
	if m != nil {
		return m.StorageUri
	}
	return ""
}

type FinishImportPartitionUploadRequest struct {
	// TiDB unique task ID for this Import Into/Index Backfilling job.
	TidbTaskId string `protobuf:"bytes,1,opt,name=tidb_task_id,json=tidbTaskId,proto3" json:"tidb_task_id,omitempty"`
	// Key range for the partition uploaded.
	KeyRange *KeyRange `protobuf:"bytes,2,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// The cloud storage path where the partition data is written.
	// The format is "s3://bucket/prefix/filename".
	StorageUri string `protobuf:"bytes,3,opt,name=storage_uri,json=storageUri,proto3" json:"storage_uri,omitempty"`
	// Keyspace ID
	KeyspaceId           uint32   `protobuf:"varint,4,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FinishImportPartitionUploadRequest) Reset()         { *m = FinishImportPartitionUploadRequest{} }
func (m *FinishImportPartitionUploadRequest) String() string { return proto.CompactTextString(m) }
func (*FinishImportPartitionUploadRequest) ProtoMessage()    {}
func (*FinishImportPartitionUploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{14}
}
func (m *FinishImportPartitionUploadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishImportPartitionUploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishImportPartitionUploadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishImportPartitionUploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishImportPartitionUploadRequest.Merge(m, src)
}
func (m *FinishImportPartitionUploadRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishImportPartitionUploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishImportPartitionUploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishImportPartitionUploadRequest proto.InternalMessageInfo

func (m *FinishImportPartitionUploadRequest) GetTidbTaskId() string {
	if m != nil {
		return m.TidbTaskId
	}
	return ""
}

func (m *FinishImportPartitionUploadRequest) GetKeyRange() *KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

func (m *FinishImportPartitionUploadRequest) GetStorageUri() string {
	if m != nil {
		return m.StorageUri
	}
	return ""
}

func (m *FinishImportPartitionUploadRequest) GetKeyspaceId() uint32 {
	if m != nil {
		return m.KeyspaceId
	}
	return 0
}

type FinishImportIndexUploadRequest struct {
	// TiDB unique task ID for this Import Into/Index Backfilling job.
	TidbTaskId string `protobuf:"bytes,1,opt,name=tidb_task_id,json=tidbTaskId,proto3" json:"tidb_task_id,omitempty"`
	// If status is SUCCESS, the job is finished successfully.
	// If status is not SUCCESS, the job is aborted or cancelled in TiDB side,
	// and TiCI should clean up all the related data.
	Status ErrorCode `protobuf:"varint,2,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// The error_message if the status is not SUCCESS.
	ErrorMessage string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Keyspace ID
	KeyspaceId           uint32   `protobuf:"varint,4,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FinishImportIndexUploadRequest) Reset()         { *m = FinishImportIndexUploadRequest{} }
func (m *FinishImportIndexUploadRequest) String() string { return proto.CompactTextString(m) }
func (*FinishImportIndexUploadRequest) ProtoMessage()    {}
func (*FinishImportIndexUploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{15}
}
func (m *FinishImportIndexUploadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishImportIndexUploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishImportIndexUploadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishImportIndexUploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishImportIndexUploadRequest.Merge(m, src)
}
func (m *FinishImportIndexUploadRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishImportIndexUploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishImportIndexUploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishImportIndexUploadRequest proto.InternalMessageInfo

func (m *FinishImportIndexUploadRequest) GetTidbTaskId() string {
	if m != nil {
		return m.TidbTaskId
	}
	return ""
}

func (m *FinishImportIndexUploadRequest) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *FinishImportIndexUploadRequest) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *FinishImportIndexUploadRequest) GetKeyspaceId() uint32 {
	if m != nil {
		return m.KeyspaceId
	}
	return 0
}

type FinishImportResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Optional human‑readable diagnostics, only defined when status is not
	// SUCCESS.
	ErrorMessage         string   `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FinishImportResponse) Reset()         { *m = FinishImportResponse{} }
func (m *FinishImportResponse) String() string { return proto.CompactTextString(m) }
func (*FinishImportResponse) ProtoMessage()    {}
func (*FinishImportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{16}
}
func (m *FinishImportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishImportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishImportResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishImportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishImportResponse.Merge(m, src)
}
func (m *FinishImportResponse) XXX_Size() int {
	return m.Size()
}
func (m *FinishImportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishImportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FinishImportResponse proto.InternalMessageInfo

func (m *FinishImportResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *FinishImportResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func init() {
	proto.RegisterEnum("tici.ErrorCode", ErrorCode_name, ErrorCode_value)
	proto.RegisterEnum("tici.GetIndexProgressResponse_State", GetIndexProgressResponse_State_name, GetIndexProgressResponse_State_value)
	proto.RegisterType((*KeyRange)(nil), "tici.KeyRange")
	proto.RegisterType((*ShardLocalCacheInfo)(nil), "tici.ShardLocalCacheInfo")
	proto.RegisterType((*GetShardLocalCacheRequest)(nil), "tici.GetShardLocalCacheRequest")
	proto.RegisterType((*GetShardLocalCacheResponse)(nil), "tici.GetShardLocalCacheResponse")
	proto.RegisterType((*ShardManifestHeader)(nil), "tici.ShardManifestHeader")
	proto.RegisterType((*S3Location)(nil), "tici.S3Location")
	proto.RegisterType((*CreateIndexRequest)(nil), "tici.CreateIndexRequest")
	proto.RegisterType((*CreateIndexResponse)(nil), "tici.CreateIndexResponse")
	proto.RegisterType((*DropIndexRequest)(nil), "tici.DropIndexRequest")
	proto.RegisterType((*DropIndexResponse)(nil), "tici.DropIndexResponse")
	proto.RegisterType((*GetIndexProgressRequest)(nil), "tici.GetIndexProgressRequest")
	proto.RegisterType((*GetIndexProgressResponse)(nil), "tici.GetIndexProgressResponse")
	proto.RegisterType((*GetImportStoragePrefixRequest)(nil), "tici.GetImportStoragePrefixRequest")
	proto.RegisterType((*GetImportStoragePrefixResponse)(nil), "tici.GetImportStoragePrefixResponse")
	proto.RegisterType((*FinishImportPartitionUploadRequest)(nil), "tici.FinishImportPartitionUploadRequest")
	proto.RegisterType((*FinishImportIndexUploadRequest)(nil), "tici.FinishImportIndexUploadRequest")
	proto.RegisterType((*FinishImportResponse)(nil), "tici.FinishImportResponse")
}

func init() { proto.RegisterFile("tici.proto", fileDescriptor_80e84b3910d5cd39) }

var fileDescriptor_80e84b3910d5cd39 = []byte{
	// 1247 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x41, 0x6f, 0x1a, 0xc7,
	0x17, 0xcf, 0xb2, 0x60, 0xb3, 0x0f, 0x63, 0xaf, 0xc7, 0x4e, 0x8c, 0x89, 0x42, 0xd0, 0x26, 0x7f,
	0xfd, 0x51, 0xaa, 0xa6, 0x92, 0x7d, 0xab, 0x72, 0x28, 0x01, 0x8c, 0x57, 0x36, 0x0b, 0x1d, 0xa0,
	0x69, 0xd5, 0xc3, 0x6a, 0x60, 0xc7, 0xf6, 0xc6, 0xb0, 0x4b, 0x76, 0x86, 0x2a, 0xbe, 0xf4, 0x98,
	0x63, 0x4f, 0x3d, 0x54, 0xfd, 0x00, 0xbd, 0xf7, 0x50, 0xf5, 0x2b, 0xf4, 0xd8, 0x2f, 0x50, 0xa9,
	0x4a, 0xa5, 0x7e, 0x8e, 0x6a, 0x66, 0x16, 0x0c, 0xc6, 0xd8, 0x8d, 0x2a, 0xdf, 0x78, 0xbf, 0x99,
	0x79, 0xef, 0x37, 0xef, 0xfd, 0xde, 0x9b, 0x05, 0x80, 0xfb, 0x7d, 0xff, 0xf9, 0x28, 0x0a, 0x79,
	0x88, 0x92, 0xe2, 0xb7, 0xf5, 0x19, 0xa4, 0x8f, 0xe8, 0x05, 0x26, 0xc1, 0x29, 0x45, 0x0f, 0xc1,
	0x60, 0x9c, 0x44, 0xdc, 0x3d, 0xa7, 0x17, 0x39, 0xad, 0xa8, 0x95, 0xd6, 0x70, 0x5a, 0x02, 0x47,
	0xf4, 0x02, 0xed, 0xc0, 0x2a, 0x0d, 0x3c, 0xb9, 0x94, 0x90, 0x4b, 0x2b, 0x34, 0xf0, 0x8e, 0xe8,
	0x85, 0x15, 0xc1, 0x56, 0xfb, 0x8c, 0x44, 0xde, 0x71, 0xd8, 0x27, 0x83, 0x0a, 0xe9, 0x9f, 0x51,
	0x3b, 0x38, 0x09, 0xd1, 0x27, 0x90, 0x62, 0x02, 0x96, 0x8e, 0x32, 0x7b, 0xbb, 0xcf, 0x65, 0x68,
	0xb9, 0xb3, 0x41, 0x02, 0xff, 0x84, 0x32, 0x7e, 0x48, 0x89, 0x47, 0x23, 0xac, 0xf6, 0xa1, 0x67,
	0xb0, 0x39, 0x10, 0x2e, 0xdc, 0xbe, 0xf0, 0xe1, 0x12, 0xcf, 0x8b, 0x58, 0x2e, 0x51, 0xd4, 0x4b,
	0x06, 0xde, 0x18, 0x4c, 0x7d, 0x97, 0x05, 0x6c, 0xfd, 0xaa, 0xc1, 0x6e, 0x9d, 0xf2, 0x2b, 0x71,
	0x31, 0x7d, 0x33, 0xa6, 0x8c, 0xa3, 0x5d, 0x48, 0x73, 0xd2, 0x1b, 0x50, 0xd7, 0x57, 0xd1, 0x75,
	0xbc, 0x2a, 0x6d, 0xdb, 0x13, 0x4b, 0x7e, 0xe0, 0xd1, 0xb7, 0x62, 0x29, 0xa1, 0x96, 0xa4, 0x6d,
	0x7b, 0xe8, 0x31, 0x64, 0xce, 0xe9, 0x05, 0x1b, 0x91, 0xbe, 0x3c, 0xa8, 0x17, 0xb5, 0x52, 0x16,
	0xc3, 0x04, 0xb2, 0x3d, 0xf4, 0x31, 0x08, 0xcb, 0x8d, 0x44, 0xae, 0x58, 0x2e, 0x59, 0xd4, 0x4b,
	0x99, 0xbd, 0x75, 0x75, 0xad, 0x49, 0x0a, 0xb1, 0x71, 0x1e, 0xff, 0x62, 0x68, 0x1b, 0x52, 0x03,
	0x7f, 0xe8, 0xf3, 0x5c, 0xaa, 0xa8, 0x95, 0x52, 0x58, 0x19, 0xd6, 0x3b, 0x0d, 0xf2, 0xd7, 0x31,
	0x67, 0xa3, 0x30, 0x60, 0x14, 0x3d, 0x80, 0x15, 0xc6, 0x09, 0x1f, 0x33, 0x49, 0x3c, 0x85, 0x63,
	0x0b, 0xb5, 0x60, 0x47, 0x66, 0xc9, 0x9d, 0x4d, 0x91, 0x1f, 0x9c, 0x84, 0x2a, 0x45, 0xf3, 0xf9,
	0x9d, 0xaf, 0x04, 0xde, 0x66, 0x8b, 0x20, 0xb3, 0xbe, 0xd3, 0xe2, 0xba, 0xcd, 0x57, 0x43, 0x64,
	0x48, 0x45, 0x8a, 0x93, 0x97, 0xc4, 0xab, 0xd2, 0xb6, 0xbd, 0x79, 0x7d, 0x24, 0x96, 0xeb, 0x43,
	0x9f, 0xd5, 0x87, 0xc8, 0x03, 0x1d, 0x85, 0xfd, 0xb3, 0x5c, 0x52, 0x7a, 0x53, 0x06, 0x32, 0x41,
	0x67, 0xf4, 0x8d, 0xcc, 0x4d, 0x12, 0x8b, 0x9f, 0xd6, 0x0b, 0x80, 0xf6, 0xbe, 0x60, 0xc9, 0xfd,
	0x30, 0x10, 0x89, 0xe8, 0x8d, 0xfb, 0xe7, 0x94, 0x4b, 0x12, 0x06, 0x8e, 0x2d, 0x81, 0x8f, 0x22,
	0x7a, 0xe2, 0xbf, 0x95, 0x04, 0x0c, 0x1c, 0x5b, 0xd6, 0xf7, 0x1a, 0xa0, 0x4a, 0x44, 0x09, 0xa7,
	0xb6, 0xa8, 0xe7, 0x44, 0x0a, 0x4f, 0x20, 0xeb, 0x11, 0x4e, 0x7a, 0x84, 0x51, 0x37, 0x20, 0x43,
	0x1a, 0x7b, 0x5b, 0x9b, 0x80, 0x0e, 0x19, 0x52, 0xf4, 0x08, 0x20, 0xd6, 0x4b, 0x70, 0x12, 0xc6,
	0x17, 0x33, 0x94, 0x62, 0x84, 0x92, 0x67, 0x35, 0xa3, 0xdf, 0xa8, 0x99, 0xe4, 0x55, 0xcd, 0x58,
	0xdf, 0xc2, 0xd6, 0x1c, 0xab, 0xb8, 0xcc, 0xff, 0x9f, 0x2b, 0xf3, 0xfa, 0xde, 0x86, 0xaa, 0x5e,
	0x2d, 0x8a, 0xc2, 0xa8, 0x12, 0x7a, 0x74, 0x5a, 0xf7, 0x27, 0x90, 0xa5, 0x02, 0x74, 0x87, 0x94,
	0x31, 0x72, 0x4a, 0xe3, 0x5b, 0xaf, 0x49, 0xb0, 0xa1, 0xb0, 0x05, 0x82, 0xc6, 0x94, 0xa0, 0xe5,
	0x83, 0x59, 0x8d, 0xc2, 0xd1, 0x5c, 0x4e, 0xee, 0xa6, 0x3d, 0x2c, 0x02, 0x9b, 0x33, 0xa1, 0xee,
	0xe2, 0xa2, 0x56, 0x13, 0x76, 0xea, 0x94, 0xcb, 0x08, 0xad, 0x28, 0x3c, 0x8d, 0x28, 0x63, 0xff,
	0xe9, 0x52, 0xd6, 0x3b, 0x1d, 0x72, 0x8b, 0x1e, 0xef, 0xa4, 0x48, 0xff, 0x83, 0x75, 0x2f, 0xec,
	0x8f, 0x87, 0x34, 0xe0, 0x6e, 0x3f, 0x1c, 0x07, 0x5c, 0xa6, 0x30, 0x89, 0xb3, 0x13, 0xb4, 0x22,
	0x40, 0xf4, 0x29, 0xa4, 0x84, 0x57, 0x2a, 0xb5, 0xb4, 0xbe, 0xf7, 0x54, 0xc5, 0x5c, 0xc6, 0xf1,
	0x79, 0x5b, 0xec, 0xc5, 0xea, 0x88, 0x28, 0x91, 0xcf, 0xdc, 0xf1, 0x68, 0x10, 0x12, 0x8f, 0x7a,
	0xb2, 0xb7, 0xd2, 0x18, 0x7c, 0xd6, 0x8d, 0x11, 0x54, 0x02, 0x73, 0x40, 0x18, 0x8f, 0xb7, 0xb8,
	0xdc, 0x1f, 0xd2, 0xdc, 0x8a, 0xe4, 0xba, 0x2e, 0x70, 0xb5, 0xaf, 0xe3, 0x0f, 0xa9, 0xe8, 0x66,
	0xb6, 0xef, 0x8e, 0x08, 0x3f, 0xcb, 0xad, 0xaa, 0x3e, 0x63, 0xfb, 0x2d, 0xc2, 0xcf, 0xac, 0x2e,
	0xa4, 0x64, 0x4c, 0x94, 0x81, 0xd5, 0x56, 0xcd, 0xa9, 0xda, 0x4e, 0xdd, 0xbc, 0x27, 0x0c, 0xdc,
	0x75, 0x1c, 0x61, 0x68, 0x28, 0x0b, 0x46, 0xa5, 0xd9, 0x68, 0x1d, 0xd7, 0x3a, 0xb5, 0xaa, 0x99,
	0x40, 0x00, 0x2b, 0x07, 0x65, 0xfb, 0xb8, 0x56, 0x35, 0x75, 0xb4, 0x06, 0x69, 0xa7, 0xd9, 0x39,
	0x68, 0x76, 0x9d, 0xaa, 0x99, 0x44, 0x06, 0xa4, 0x6a, 0x18, 0x37, 0xb1, 0x99, 0xb2, 0x7e, 0xd4,
	0xe0, 0x91, 0xb8, 0xe4, 0x70, 0x14, 0x46, 0xbc, 0xcd, 0xc3, 0x88, 0x9c, 0xd2, 0x96, 0xec, 0xec,
	0x49, 0x81, 0x8b, 0xb0, 0xc6, 0x7d, 0xaf, 0xe7, 0x72, 0xc2, 0xce, 0x27, 0x45, 0x36, 0x30, 0x08,
	0xac, 0x43, 0xd8, 0xb9, 0xaa, 0xf3, 0x54, 0x02, 0x89, 0x79, 0x09, 0x3c, 0x04, 0x63, 0x22, 0x01,
	0x96, 0xd3, 0x8b, 0x7a, 0x49, 0xc7, 0xe9, 0x58, 0x03, 0xec, 0xf6, 0x26, 0xfe, 0x49, 0x83, 0xc2,
	0x32, 0x72, 0x77, 0xa2, 0x95, 0xfb, 0xb0, 0xf2, 0x3a, 0xec, 0x4d, 0xda, 0x2c, 0x89, 0x53, 0xaf,
	0xc3, 0x9e, 0x6a, 0x41, 0xa6, 0xa2, 0xbb, 0xe3, 0xc8, 0x97, 0x44, 0x0d, 0x0c, 0x31, 0xd4, 0x8d,
	0x7c, 0xeb, 0x17, 0x0d, 0xac, 0x03, 0x3f, 0xf0, 0xd9, 0x99, 0xe2, 0xda, 0x22, 0x11, 0xf7, 0xc5,
	0x38, 0x55, 0x95, 0xfd, 0xf7, 0xa9, 0xfc, 0x08, 0x8c, 0xe9, 0x53, 0x27, 0x19, 0x2e, 0xbe, 0x74,
	0xe9, 0xc9, 0x4b, 0x77, 0x95, 0x96, 0x7e, 0x95, 0xd6, 0xed, 0x09, 0xfe, 0x59, 0x83, 0xc2, 0x2c,
	0x6f, 0xa9, 0xf5, 0x0f, 0xe5, 0x7c, 0x59, 0x82, 0xc4, 0x07, 0x96, 0x40, 0xbf, 0xa6, 0x04, 0xb7,
	0x72, 0xf6, 0x60, 0x7b, 0x96, 0xf2, 0xdd, 0x28, 0xe1, 0xd9, 0x1f, 0x1a, 0x18, 0xd3, 0xa3, 0xa2,
	0xcd, 0xda, 0xdd, 0x4a, 0xa5, 0xd6, 0x6e, 0x9b, 0xf7, 0xd0, 0x26, 0x64, 0xbb, 0xce, 0x91, 0xd3,
	0x7c, 0xe5, 0xb8, 0xaa, 0x8b, 0x34, 0x74, 0x1f, 0x36, 0x6d, 0xe7, 0x8b, 0xf2, 0xb1, 0x5d, 0x75,
	0xcb, 0xb8, 0xde, 0x6d, 0xd4, 0x9c, 0x4e, 0xdb, 0x4c, 0x88, 0x86, 0xec, 0xe0, 0xaf, 0xdc, 0x72,
	0xbd, 0x6c, 0x3b, 0xa6, 0x8e, 0xb6, 0x60, 0xa3, 0x7d, 0x58, 0xc6, 0x55, 0xd7, 0x69, 0x76, 0x5c,
	0xd5, 0x8b, 0x19, 0x01, 0xda, 0x4e, 0xb5, 0xf6, 0xe5, 0x0c, 0xb8, 0x86, 0xb6, 0xc1, 0x7c, 0xd5,
	0xc4, 0x47, 0x35, 0x3c, 0x83, 0x66, 0xd1, 0x0e, 0x6c, 0x5d, 0x9e, 0x6f, 0x57, 0x0e, 0x6b, 0xd5,
	0xae, 0xe8, 0xee, 0x75, 0x94, 0x83, 0x6d, 0xd1, 0xf8, 0xe5, 0x4a, 0xc7, 0x6e, 0x3a, 0x33, 0x47,
	0x36, 0xc4, 0x91, 0x03, 0x5c, 0xae, 0xbb, 0xb8, 0xec, 0xd4, 0x6b, 0x6e, 0xc3, 0x6e, 0x37, 0xca,
	0x9d, 0xca, 0xa1, 0x69, 0xee, 0xfd, 0x9d, 0x84, 0x4c, 0x83, 0x72, 0xd2, 0xa6, 0xd1, 0x37, 0x7e,
	0x9f, 0xa2, 0x97, 0x90, 0x99, 0x79, 0x2f, 0x51, 0x4e, 0x25, 0x6f, 0xf1, 0x61, 0xcf, 0xef, 0x5e,
	0xb3, 0x12, 0x57, 0xe0, 0x05, 0x18, 0xd3, 0x87, 0x08, 0x3d, 0x50, 0xfb, 0xae, 0x3e, 0x82, 0xf9,
	0x9d, 0x05, 0x3c, 0x3e, 0xfd, 0x39, 0x98, 0x57, 0xa7, 0x2d, 0x7a, 0xb4, 0x6c, 0x0a, 0x2b, 0x5f,
	0x85, 0x9b, 0x87, 0x34, 0xfa, 0x1a, 0x1e, 0x2c, 0x7e, 0xf2, 0xc9, 0x4f, 0x8b, 0xc7, 0xd3, 0x93,
	0xd7, 0x7f, 0xca, 0xe6, 0x8b, 0xcb, 0x37, 0xc4, 0xce, 0xfb, 0xd2, 0xf9, 0x35, 0xb3, 0x09, 0x3d,
	0xb9, 0xa4, 0xb5, 0x74, 0xac, 0xe6, 0x9f, 0xde, 0xbc, 0x69, 0x1a, 0xe4, 0xe1, 0x0d, 0x73, 0x05,
	0x95, 0x94, 0x93, 0xdb, 0x47, 0x4f, 0x3e, 0xbf, 0xb8, 0x73, 0x26, 0x4d, 0x3b, 0x4b, 0x86, 0x00,
	0x7a, 0xba, 0x78, 0x6c, 0x71, 0x46, 0xdc, 0xe4, 0xfc, 0xa5, 0xf9, 0xdb, 0xfb, 0x82, 0xf6, 0xfb,
	0xfb, 0x82, 0xf6, 0xe7, 0xfb, 0x82, 0xf6, 0xc3, 0x5f, 0x85, 0x7b, 0xbd, 0x15, 0xf9, 0x37, 0x68,
	0xff, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x26, 0xad, 0x3f, 0x79, 0x14, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MetaServiceClient is the client API for MetaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetaServiceClient interface {
	// CreateIndex creates a new index
	CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error)
	// DropIndex removes an existing index
	DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error)
	// GetIndexProgress retrieves the current progress of an index build
	GetIndexProgress(ctx context.Context, in *GetIndexProgressRequest, opts ...grpc.CallOption) (*GetIndexProgressResponse, error)
	// Get shard local cache information
	GetShardLocalCacheInfo(ctx context.Context, in *GetShardLocalCacheRequest, opts ...grpc.CallOption) (*GetShardLocalCacheResponse, error)
	// Get a cloud storage prefix for importing data.
	// This will create a new import job with a unique job_id and a cloud storage
	// prefix for the import data. The caller should generate files under the
	// cloud storage prefix and call `FinishImportPartitionUpload` after uploading
	// each partition. If there is an existing running import job for the same
	// identifier, it will return the existing job_id.
	GetImportStoragePrefix(ctx context.Context, in *GetImportStoragePrefixRequest, opts ...grpc.CallOption) (*GetImportStoragePrefixResponse, error)
	// Called by Import DXF to notify Meta Service after a partition for
	// the given index are uploaded.
	FinishImportPartitionUpload(ctx context.Context, in *FinishImportPartitionUploadRequest, opts ...grpc.CallOption) (*FinishImportResponse, error)
	// Called to notify Meta Service that the whole table/index upload is
	// finished.
	FinishImportIndexUpload(ctx context.Context, in *FinishImportIndexUploadRequest, opts ...grpc.CallOption) (*FinishImportResponse, error)
}

type metaServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetaServiceClient(cc *grpc.ClientConn) MetaServiceClient {
	return &metaServiceClient{cc}
}

func (c *metaServiceClient) CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error) {
	out := new(CreateIndexResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/CreateIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error) {
	out := new(DropIndexResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/DropIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetIndexProgress(ctx context.Context, in *GetIndexProgressRequest, opts ...grpc.CallOption) (*GetIndexProgressResponse, error) {
	out := new(GetIndexProgressResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/GetIndexProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetShardLocalCacheInfo(ctx context.Context, in *GetShardLocalCacheRequest, opts ...grpc.CallOption) (*GetShardLocalCacheResponse, error) {
	out := new(GetShardLocalCacheResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/GetShardLocalCacheInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetImportStoragePrefix(ctx context.Context, in *GetImportStoragePrefixRequest, opts ...grpc.CallOption) (*GetImportStoragePrefixResponse, error) {
	out := new(GetImportStoragePrefixResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/GetImportStoragePrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) FinishImportPartitionUpload(ctx context.Context, in *FinishImportPartitionUploadRequest, opts ...grpc.CallOption) (*FinishImportResponse, error) {
	out := new(FinishImportResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/FinishImportPartitionUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) FinishImportIndexUpload(ctx context.Context, in *FinishImportIndexUploadRequest, opts ...grpc.CallOption) (*FinishImportResponse, error) {
	out := new(FinishImportResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/FinishImportIndexUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetaServiceServer is the server API for MetaService service.
type MetaServiceServer interface {
	// CreateIndex creates a new index
	CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error)
	// DropIndex removes an existing index
	DropIndex(context.Context, *DropIndexRequest) (*DropIndexResponse, error)
	// GetIndexProgress retrieves the current progress of an index build
	GetIndexProgress(context.Context, *GetIndexProgressRequest) (*GetIndexProgressResponse, error)
	// Get shard local cache information
	GetShardLocalCacheInfo(context.Context, *GetShardLocalCacheRequest) (*GetShardLocalCacheResponse, error)
	// Get a cloud storage prefix for importing data.
	// This will create a new import job with a unique job_id and a cloud storage
	// prefix for the import data. The caller should generate files under the
	// cloud storage prefix and call `FinishImportPartitionUpload` after uploading
	// each partition. If there is an existing running import job for the same
	// identifier, it will return the existing job_id.
	GetImportStoragePrefix(context.Context, *GetImportStoragePrefixRequest) (*GetImportStoragePrefixResponse, error)
	// Called by Import DXF to notify Meta Service after a partition for
	// the given index are uploaded.
	FinishImportPartitionUpload(context.Context, *FinishImportPartitionUploadRequest) (*FinishImportResponse, error)
	// Called to notify Meta Service that the whole table/index upload is
	// finished.
	FinishImportIndexUpload(context.Context, *FinishImportIndexUploadRequest) (*FinishImportResponse, error)
}

// UnimplementedMetaServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMetaServiceServer struct {
}

func (*UnimplementedMetaServiceServer) CreateIndex(ctx context.Context, req *CreateIndexRequest) (*CreateIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIndex not implemented")
}
func (*UnimplementedMetaServiceServer) DropIndex(ctx context.Context, req *DropIndexRequest) (*DropIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropIndex not implemented")
}
func (*UnimplementedMetaServiceServer) GetIndexProgress(ctx context.Context, req *GetIndexProgressRequest) (*GetIndexProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndexProgress not implemented")
}
func (*UnimplementedMetaServiceServer) GetShardLocalCacheInfo(ctx context.Context, req *GetShardLocalCacheRequest) (*GetShardLocalCacheResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShardLocalCacheInfo not implemented")
}
func (*UnimplementedMetaServiceServer) GetImportStoragePrefix(ctx context.Context, req *GetImportStoragePrefixRequest) (*GetImportStoragePrefixResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImportStoragePrefix not implemented")
}
func (*UnimplementedMetaServiceServer) FinishImportPartitionUpload(ctx context.Context, req *FinishImportPartitionUploadRequest) (*FinishImportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishImportPartitionUpload not implemented")
}
func (*UnimplementedMetaServiceServer) FinishImportIndexUpload(ctx context.Context, req *FinishImportIndexUploadRequest) (*FinishImportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishImportIndexUpload not implemented")
}

func RegisterMetaServiceServer(s *grpc.Server, srv MetaServiceServer) {
	s.RegisterService(&_MetaService_serviceDesc, srv)
}

func _MetaService_CreateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).CreateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/CreateIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).CreateIndex(ctx, req.(*CreateIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_DropIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).DropIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/DropIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).DropIndex(ctx, req.(*DropIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_GetIndexProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).GetIndexProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/GetIndexProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).GetIndexProgress(ctx, req.(*GetIndexProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_GetShardLocalCacheInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetShardLocalCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).GetShardLocalCacheInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/GetShardLocalCacheInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).GetShardLocalCacheInfo(ctx, req.(*GetShardLocalCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_GetImportStoragePrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImportStoragePrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).GetImportStoragePrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/GetImportStoragePrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).GetImportStoragePrefix(ctx, req.(*GetImportStoragePrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_FinishImportPartitionUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishImportPartitionUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).FinishImportPartitionUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/FinishImportPartitionUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).FinishImportPartitionUpload(ctx, req.(*FinishImportPartitionUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_FinishImportIndexUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishImportIndexUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).FinishImportIndexUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/FinishImportIndexUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).FinishImportIndexUpload(ctx, req.(*FinishImportIndexUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetaService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tici.MetaService",
	HandlerType: (*MetaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateIndex",
			Handler:    _MetaService_CreateIndex_Handler,
		},
		{
			MethodName: "DropIndex",
			Handler:    _MetaService_DropIndex_Handler,
		},
		{
			MethodName: "GetIndexProgress",
			Handler:    _MetaService_GetIndexProgress_Handler,
		},
		{
			MethodName: "GetShardLocalCacheInfo",
			Handler:    _MetaService_GetShardLocalCacheInfo_Handler,
		},
		{
			MethodName: "GetImportStoragePrefix",
			Handler:    _MetaService_GetImportStoragePrefix_Handler,
		},
		{
			MethodName: "FinishImportPartitionUpload",
			Handler:    _MetaService_FinishImportPartitionUpload_Handler,
		},
		{
			MethodName: "FinishImportIndexUpload",
			Handler:    _MetaService_FinishImportIndexUpload_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tici.proto",
}

func (m *KeyRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardLocalCacheInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardLocalCacheInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardLocalCacheInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LocalCacheAddrs) > 0 {
		for iNdEx := len(m.LocalCacheAddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LocalCacheAddrs[iNdEx])
			copy(dAtA[i:], m.LocalCacheAddrs[iNdEx])
			i = encodeVarintTici(dAtA, i, uint64(len(m.LocalCacheAddrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetShardLocalCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardLocalCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardLocalCacheRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if len(m.KeyRanges) > 0 {
		for iNdEx := len(m.KeyRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KeyRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.KeyspaceId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.KeyspaceId))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetShardLocalCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardLocalCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardLocalCacheResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShardLocalCacheInfos) > 0 {
		for iNdEx := len(m.ShardLocalCacheInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardLocalCacheInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardManifestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardManifestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardManifestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Seq != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x28
	}
	if m.Epoch != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.ShardId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S3Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeyspaceId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.KeyspaceId))
		i--
		dAtA[i] = 0x20
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TableInfo) > 0 {
		i -= len(m.TableInfo)
		copy(dAtA[i:], m.TableInfo)
		i = encodeVarintTici(dAtA, i, uint64(len(m.TableInfo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintTici(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IndexId) > 0 {
		i -= len(m.IndexId)
		copy(dAtA[i:], m.IndexId)
		i = encodeVarintTici(dAtA, i, uint64(len(m.IndexId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeyspaceId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.KeyspaceId))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetIndexProgressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexProgressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexProgressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetIndexProgressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexProgressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexProgressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.S3Path) > 0 {
		i -= len(m.S3Path)
		copy(dAtA[i:], m.S3Path)
		i = encodeVarintTici(dAtA, i, uint64(len(m.S3Path)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LastUploadTime) > 0 {
		i -= len(m.LastUploadTime)
		copy(dAtA[i:], m.LastUploadTime)
		i = encodeVarintTici(dAtA, i, uint64(len(m.LastUploadTime)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsUploaded {
		i--
		if m.IsUploaded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.DocumentCount != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.DocumentCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetImportStoragePrefixRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImportStoragePrefixRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImportStoragePrefixRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeyspaceId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.KeyspaceId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.IndexIds) > 0 {
		dAtA3 := make([]byte, len(m.IndexIds)*10)
		var j2 int
		for _, num1 := range m.IndexIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTici(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x1a
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TidbTaskId) > 0 {
		i -= len(m.TidbTaskId)
		copy(dAtA[i:], m.TidbTaskId)
		i = encodeVarintTici(dAtA, i, uint64(len(m.TidbTaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetImportStoragePrefixResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImportStoragePrefixResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImportStoragePrefixResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StorageUri) > 0 {
		i -= len(m.StorageUri)
		copy(dAtA[i:], m.StorageUri)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StorageUri)))
		i--
		dAtA[i] = 0x22
	}
	if m.JobId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.JobId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinishImportPartitionUploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishImportPartitionUploadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishImportPartitionUploadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeyspaceId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.KeyspaceId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.StorageUri) > 0 {
		i -= len(m.StorageUri)
		copy(dAtA[i:], m.StorageUri)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StorageUri)))
		i--
		dAtA[i] = 0x1a
	}
	if m.KeyRange != nil {
		{
			size, err := m.KeyRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TidbTaskId) > 0 {
		i -= len(m.TidbTaskId)
		copy(dAtA[i:], m.TidbTaskId)
		i = encodeVarintTici(dAtA, i, uint64(len(m.TidbTaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinishImportIndexUploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishImportIndexUploadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishImportIndexUploadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeyspaceId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.KeyspaceId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TidbTaskId) > 0 {
		i -= len(m.TidbTaskId)
		copy(dAtA[i:], m.TidbTaskId)
		i = encodeVarintTici(dAtA, i, uint64(len(m.TidbTaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinishImportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishImportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishImportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTici(dAtA []byte, offset int, v uint64) int {
	offset -= sovTici(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *KeyRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardLocalCacheInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.LocalCacheAddrs) > 0 {
		for _, s := range m.LocalCacheAddrs {
			l = len(s)
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardLocalCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.KeyspaceId != 0 {
		n += 1 + sovTici(uint64(m.KeyspaceId))
	}
	if len(m.KeyRanges) > 0 {
		for _, e := range m.KeyRanges {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.Limit != 0 {
		n += 1 + sovTici(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetShardLocalCacheResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	if len(m.ShardLocalCacheInfos) > 0 {
		for _, e := range m.ShardLocalCacheInfos {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardManifestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovTici(uint64(m.ShardId))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovTici(uint64(m.Epoch))
	}
	if m.Seq != 0 {
		n += 1 + sovTici(uint64(m.Seq))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S3Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DatabaseName)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.TableInfo)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.KeyspaceId != 0 {
		n += 1 + sovTici(uint64(m.KeyspaceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateIndexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.IndexId)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.KeyspaceId != 0 {
		n += 1 + sovTici(uint64(m.KeyspaceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropIndexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetIndexProgressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetIndexProgressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.DocumentCount != 0 {
		n += 1 + sovTici(uint64(m.DocumentCount))
	}
	if m.State != 0 {
		n += 1 + sovTici(uint64(m.State))
	}
	if m.IsUploaded {
		n += 2
	}
	l = len(m.LastUploadTime)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.S3Path)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetImportStoragePrefixRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TidbTaskId)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if len(m.IndexIds) > 0 {
		l = 0
		for _, e := range m.IndexIds {
			l += sovTici(uint64(e))
		}
		n += 1 + sovTici(uint64(l)) + l
	}
	if m.KeyspaceId != 0 {
		n += 1 + sovTici(uint64(m.KeyspaceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetImportStoragePrefixResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.JobId != 0 {
		n += 1 + sovTici(uint64(m.JobId))
	}
	l = len(m.StorageUri)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FinishImportPartitionUploadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TidbTaskId)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.StorageUri)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.KeyspaceId != 0 {
		n += 1 + sovTici(uint64(m.KeyspaceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FinishImportIndexUploadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TidbTaskId)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.KeyspaceId != 0 {
		n += 1 + sovTici(uint64(m.KeyspaceId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FinishImportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTici(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTici(x uint64) (n int) {
	return sovTici(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *KeyRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardLocalCacheInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardLocalCacheInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardLocalCacheInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &ShardManifestHeader{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalCacheAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalCacheAddrs = append(m.LocalCacheAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardLocalCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardLocalCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardLocalCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			m.KeyspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRanges = append(m.KeyRanges, &KeyRange{})
			if err := m.KeyRanges[len(m.KeyRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardLocalCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardLocalCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardLocalCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardLocalCacheInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardLocalCacheInfos = append(m.ShardLocalCacheInfos, &ShardLocalCacheInfo{})
			if err := m.ShardLocalCacheInfos[len(m.ShardLocalCacheInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardManifestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardManifestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardManifestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableInfo = append(m.TableInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.TableInfo == nil {
				m.TableInfo = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			m.KeyspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			m.KeyspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexProgressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexProgressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexProgressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexProgressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexProgressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexProgressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentCount", wireType)
			}
			m.DocumentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocumentCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= GetIndexProgressResponse_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUploaded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUploaded = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUploadTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastUploadTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImportStoragePrefixRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImportStoragePrefixRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImportStoragePrefixRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TidbTaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TidbTaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IndexIds = append(m.IndexIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTici
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTici
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IndexIds) == 0 {
					m.IndexIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IndexIds = append(m.IndexIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexIds", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			m.KeyspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImportStoragePrefixResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImportStoragePrefixResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImportStoragePrefixResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishImportPartitionUploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishImportPartitionUploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishImportPartitionUploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TidbTaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TidbTaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			m.KeyspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishImportIndexUploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishImportIndexUploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishImportIndexUploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TidbTaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TidbTaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			m.KeyspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishImportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishImportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishImportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTici(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTici
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTici
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTici
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTici
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTici
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTici
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTici        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTici          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTici = fmt.Errorf("proto: unexpected end of group")
)
