// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tici.proto

package tici

import (
	"context"
	encoding_binary "encoding/binary"
	"fmt"
	"io"
	"math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ErrorCode int32

const (
	ErrorCode_SUCCESS             ErrorCode = 0
	ErrorCode_UNKNOWN_ERROR       ErrorCode = 1
	ErrorCode_INVALID_ARGUMENTS   ErrorCode = 2
	ErrorCode_SHARD_NOT_FOUND     ErrorCode = 11
	ErrorCode_INDEX_NOT_FOUND     ErrorCode = 12
	ErrorCode_WORKER_NOT_FOUND    ErrorCode = 13
	ErrorCode_SHARD_NOT_SCHEDULED ErrorCode = 14
)

var ErrorCode_name = map[int32]string{
	0:  "SUCCESS",
	1:  "UNKNOWN_ERROR",
	2:  "INVALID_ARGUMENTS",
	11: "SHARD_NOT_FOUND",
	12: "INDEX_NOT_FOUND",
	13: "WORKER_NOT_FOUND",
	14: "SHARD_NOT_SCHEDULED",
}

var ErrorCode_value = map[string]int32{
	"SUCCESS":             0,
	"UNKNOWN_ERROR":       1,
	"INVALID_ARGUMENTS":   2,
	"SHARD_NOT_FOUND":     11,
	"INDEX_NOT_FOUND":     12,
	"WORKER_NOT_FOUND":    13,
	"SHARD_NOT_SCHEDULED": 14,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}

func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{0}
}

type CompactType int32

const (
	CompactType_Delta CompactType = 0
	CompactType_Base  CompactType = 1
	CompactType_Full  CompactType = 2
)

var CompactType_name = map[int32]string{
	0: "Delta",
	1: "Base",
	2: "Full",
}

var CompactType_value = map[string]int32{
	"Delta": 0,
	"Base":  1,
	"Full":  2,
}

func (x CompactType) String() string {
	return proto.EnumName(CompactType_name, int32(x))
}

func (CompactType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{1}
}

// IndexType represents the type of index
type IndexType int32

const (
	// Default value must be 0 in proto3
	IndexType_UNKNOWN IndexType = 0
	// Full-text index type
	IndexType_FULL_TEXT IndexType = 1
	// Custom index type
	IndexType_CUSTOM IndexType = 2
)

var IndexType_name = map[int32]string{
	0: "UNKNOWN",
	1: "FULL_TEXT",
	2: "CUSTOM",
}

var IndexType_value = map[string]int32{
	"UNKNOWN":   0,
	"FULL_TEXT": 1,
	"CUSTOM":    2,
}

func (x IndexType) String() string {
	return proto.EnumName(IndexType_name, int32(x))
}

func (IndexType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{2}
}

// ParserType represents the type of parser
type ParserType int32

const (
	// Default value must be 0 in proto3
	ParserType_UNKNOWN_PARSER ParserType = 0
	// Default parser
	ParserType_DEFAULT_PARSER ParserType = 1
	// Other parser types
	ParserType_OTHER_PARSER ParserType = 2
)

var ParserType_name = map[int32]string{
	0: "UNKNOWN_PARSER",
	1: "DEFAULT_PARSER",
	2: "OTHER_PARSER",
}

var ParserType_value = map[string]int32{
	"UNKNOWN_PARSER": 0,
	"DEFAULT_PARSER": 1,
	"OTHER_PARSER":   2,
}

func (x ParserType) String() string {
	return proto.EnumName(ParserType_name, int32(x))
}

func (ParserType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{3}
}

type GetIndexProgressResponse_State int32

const (
	GetIndexProgressResponse_PENDING   GetIndexProgressResponse_State = 0
	GetIndexProgressResponse_RUNNING   GetIndexProgressResponse_State = 1
	GetIndexProgressResponse_COMPLETED GetIndexProgressResponse_State = 2
	GetIndexProgressResponse_FAILED    GetIndexProgressResponse_State = 3
	GetIndexProgressResponse_NOTFOUND  GetIndexProgressResponse_State = 4
	GetIndexProgressResponse_ERROR     GetIndexProgressResponse_State = 5
)

var GetIndexProgressResponse_State_name = map[int32]string{
	0: "PENDING",
	1: "RUNNING",
	2: "COMPLETED",
	3: "FAILED",
	4: "NOTFOUND",
	5: "ERROR",
}

var GetIndexProgressResponse_State_value = map[string]int32{
	"PENDING":   0,
	"RUNNING":   1,
	"COMPLETED": 2,
	"FAILED":    3,
	"NOTFOUND":  4,
	"ERROR":     5,
}

func (x GetIndexProgressResponse_State) String() string {
	return proto.EnumName(GetIndexProgressResponse_State_name, int32(x))
}

func (GetIndexProgressResponse_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{36, 0}
}

type WorkerNodeStatus struct {
	// TODO Need more metrics, such as disk usage, quotas, cache miss rates
	CpuUsage    float64 `protobuf:"fixed64,1,opt,name=cpu_usage,json=cpuUsage,proto3" json:"cpu_usage,omitempty"`
	MemoryUsage uint64  `protobuf:"varint,2,opt,name=memory_usage,json=memoryUsage,proto3" json:"memory_usage,omitempty"`
}

func (m *WorkerNodeStatus) Reset()         { *m = WorkerNodeStatus{} }
func (m *WorkerNodeStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeStatus) ProtoMessage()    {}
func (*WorkerNodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{0}
}
func (m *WorkerNodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeStatus.Merge(m, src)
}
func (m *WorkerNodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeStatus proto.InternalMessageInfo

func (m *WorkerNodeStatus) GetCpuUsage() float64 {
	if m != nil {
		return m.CpuUsage
	}
	return 0
}

func (m *WorkerNodeStatus) GetMemoryUsage() uint64 {
	if m != nil {
		return m.MemoryUsage
	}
	return 0
}

// Reader node status information
type ReaderNodeStatus struct {
	// CPU usage percentage (0.0 to 100.0)
	CpuUsage float64 `protobuf:"fixed64,1,opt,name=cpu_usage,json=cpuUsage,proto3" json:"cpu_usage,omitempty"`
	// Memory usage in bytes
	MemoryUsage uint64 `protobuf:"varint,2,opt,name=memory_usage,json=memoryUsage,proto3" json:"memory_usage,omitempty"`
	// Number of requests processed in current heartbeat cycle
	RequestsInCycle uint32 `protobuf:"varint,3,opt,name=requests_in_cycle,json=requestsInCycle,proto3" json:"requests_in_cycle,omitempty"`
	// Cache hit rate percentage (0.0 to 100.0)
	CacheHitRate float64 `protobuf:"fixed64,4,opt,name=cache_hit_rate,json=cacheHitRate,proto3" json:"cache_hit_rate,omitempty"`
}

func (m *ReaderNodeStatus) Reset()         { *m = ReaderNodeStatus{} }
func (m *ReaderNodeStatus) String() string { return proto.CompactTextString(m) }
func (*ReaderNodeStatus) ProtoMessage()    {}
func (*ReaderNodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{1}
}
func (m *ReaderNodeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReaderNodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReaderNodeStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReaderNodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReaderNodeStatus.Merge(m, src)
}
func (m *ReaderNodeStatus) XXX_Size() int {
	return m.Size()
}
func (m *ReaderNodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ReaderNodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ReaderNodeStatus proto.InternalMessageInfo

func (m *ReaderNodeStatus) GetCpuUsage() float64 {
	if m != nil {
		return m.CpuUsage
	}
	return 0
}

func (m *ReaderNodeStatus) GetMemoryUsage() uint64 {
	if m != nil {
		return m.MemoryUsage
	}
	return 0
}

func (m *ReaderNodeStatus) GetRequestsInCycle() uint32 {
	if m != nil {
		return m.RequestsInCycle
	}
	return 0
}

func (m *ReaderNodeStatus) GetCacheHitRate() float64 {
	if m != nil {
		return m.CacheHitRate
	}
	return 0
}

// Some fields may be duplicated with ShardManifestHeader,
// however, just leave them here.
type WorkerNodeShardStatus struct {
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// TODO shard_id is unique across tables and indexes.
	// We still need them because in meta service we are not currently maintain
	// this correspondence.
	TableId int64  `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId int64  `protobuf:"varint,4,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	ShardId uint64 `protobuf:"varint,5,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	Epoch   uint64 `protobuf:"varint,6,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Seq     uint64 `protobuf:"varint,7,opt,name=seq,proto3" json:"seq,omitempty"`
}

func (m *WorkerNodeShardStatus) Reset()         { *m = WorkerNodeShardStatus{} }
func (m *WorkerNodeShardStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeShardStatus) ProtoMessage()    {}
func (*WorkerNodeShardStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{2}
}
func (m *WorkerNodeShardStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeShardStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeShardStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeShardStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeShardStatus.Merge(m, src)
}
func (m *WorkerNodeShardStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeShardStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeShardStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeShardStatus proto.InternalMessageInfo

func (m *WorkerNodeShardStatus) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *WorkerNodeShardStatus) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *WorkerNodeShardStatus) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *WorkerNodeShardStatus) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *WorkerNodeShardStatus) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *WorkerNodeShardStatus) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *WorkerNodeShardStatus) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type WorkerNodeCompactionStatus struct {
	Req *CompactFragRequest `protobuf:"bytes,1,opt,name=req,proto3" json:"req,omitempty"`
}

func (m *WorkerNodeCompactionStatus) Reset()         { *m = WorkerNodeCompactionStatus{} }
func (m *WorkerNodeCompactionStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeCompactionStatus) ProtoMessage()    {}
func (*WorkerNodeCompactionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{3}
}
func (m *WorkerNodeCompactionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeCompactionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeCompactionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeCompactionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeCompactionStatus.Merge(m, src)
}
func (m *WorkerNodeCompactionStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeCompactionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeCompactionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeCompactionStatus proto.InternalMessageInfo

func (m *WorkerNodeCompactionStatus) GetReq() *CompactFragRequest {
	if m != nil {
		return m.Req
	}
	return nil
}

type WorkerNodeHeartbeatRequest struct {
	Addr        string                        `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Status      *WorkerNodeStatus             `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	Shards      []*WorkerNodeShardStatus      `protobuf:"bytes,3,rep,name=shards,proto3" json:"shards,omitempty"`
	Compactions []*WorkerNodeCompactionStatus `protobuf:"bytes,4,rep,name=compactions,proto3" json:"compactions,omitempty"`
}

func (m *WorkerNodeHeartbeatRequest) Reset()         { *m = WorkerNodeHeartbeatRequest{} }
func (m *WorkerNodeHeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeHeartbeatRequest) ProtoMessage()    {}
func (*WorkerNodeHeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{4}
}
func (m *WorkerNodeHeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeHeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeHeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeHeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeHeartbeatRequest.Merge(m, src)
}
func (m *WorkerNodeHeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeHeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeHeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeHeartbeatRequest proto.InternalMessageInfo

func (m *WorkerNodeHeartbeatRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *WorkerNodeHeartbeatRequest) GetStatus() *WorkerNodeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *WorkerNodeHeartbeatRequest) GetShards() []*WorkerNodeShardStatus {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *WorkerNodeHeartbeatRequest) GetCompactions() []*WorkerNodeCompactionStatus {
	if m != nil {
		return m.Compactions
	}
	return nil
}

type WorkerNodeHeartbeatResponse struct {
	Status      ErrorCode          `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	ToAddShards []*AddShardRequest `protobuf:"bytes,2,rep,name=to_add_shards,json=toAddShards,proto3" json:"to_add_shards,omitempty"`
	// We assume the `shard_id`s are unique across tables,
	// So using `shard_id` is enough here.
	ToRemoveShards []uint64 `protobuf:"varint,3,rep,packed,name=to_remove_shards,json=toRemoveShards,proto3" json:"to_remove_shards,omitempty"`
}

func (m *WorkerNodeHeartbeatResponse) Reset()         { *m = WorkerNodeHeartbeatResponse{} }
func (m *WorkerNodeHeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*WorkerNodeHeartbeatResponse) ProtoMessage()    {}
func (*WorkerNodeHeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{5}
}
func (m *WorkerNodeHeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerNodeHeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerNodeHeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerNodeHeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerNodeHeartbeatResponse.Merge(m, src)
}
func (m *WorkerNodeHeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *WorkerNodeHeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerNodeHeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerNodeHeartbeatResponse proto.InternalMessageInfo

func (m *WorkerNodeHeartbeatResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *WorkerNodeHeartbeatResponse) GetToAddShards() []*AddShardRequest {
	if m != nil {
		return m.ToAddShards
	}
	return nil
}

func (m *WorkerNodeHeartbeatResponse) GetToRemoveShards() []uint64 {
	if m != nil {
		return m.ToRemoveShards
	}
	return nil
}

// Reader node heartbeat request
type ReaderNodeHeartbeatRequest struct {
	// Reader node address
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	// Reader node status
	Status *ReaderNodeStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// TiFlash server address
	TiflashServerAddr string `protobuf:"bytes,3,opt,name=tiflash_server_addr,json=tiflashServerAddr,proto3" json:"tiflash_server_addr,omitempty"`
	// List of cached shard IDs on this reader
	CachedShardIds []uint64 `protobuf:"varint,4,rep,packed,name=cached_shard_ids,json=cachedShardIds,proto3" json:"cached_shard_ids,omitempty"`
}

func (m *ReaderNodeHeartbeatRequest) Reset()         { *m = ReaderNodeHeartbeatRequest{} }
func (m *ReaderNodeHeartbeatRequest) String() string { return proto.CompactTextString(m) }
func (*ReaderNodeHeartbeatRequest) ProtoMessage()    {}
func (*ReaderNodeHeartbeatRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{6}
}
func (m *ReaderNodeHeartbeatRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReaderNodeHeartbeatRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReaderNodeHeartbeatRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReaderNodeHeartbeatRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReaderNodeHeartbeatRequest.Merge(m, src)
}
func (m *ReaderNodeHeartbeatRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReaderNodeHeartbeatRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReaderNodeHeartbeatRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReaderNodeHeartbeatRequest proto.InternalMessageInfo

func (m *ReaderNodeHeartbeatRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *ReaderNodeHeartbeatRequest) GetStatus() *ReaderNodeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ReaderNodeHeartbeatRequest) GetTiflashServerAddr() string {
	if m != nil {
		return m.TiflashServerAddr
	}
	return ""
}

func (m *ReaderNodeHeartbeatRequest) GetCachedShardIds() []uint64 {
	if m != nil {
		return m.CachedShardIds
	}
	return nil
}

// Reader node heartbeat response
type ReaderNodeHeartbeatResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *ReaderNodeHeartbeatResponse) Reset()         { *m = ReaderNodeHeartbeatResponse{} }
func (m *ReaderNodeHeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*ReaderNodeHeartbeatResponse) ProtoMessage()    {}
func (*ReaderNodeHeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{7}
}
func (m *ReaderNodeHeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReaderNodeHeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReaderNodeHeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReaderNodeHeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReaderNodeHeartbeatResponse.Merge(m, src)
}
func (m *ReaderNodeHeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReaderNodeHeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReaderNodeHeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReaderNodeHeartbeatResponse proto.InternalMessageInfo

func (m *ReaderNodeHeartbeatResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

func (m *ReaderNodeHeartbeatResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// Fragment metadata primarily stores all data files under a
// ​​fragment​​
type FragProperty struct {
	// Total file size of fragment.
	Size_ uint64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	// Distinct handle count in fragment.
	Count     uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	MinHandle []byte `protobuf:"bytes,3,opt,name=min_handle,json=minHandle,proto3" json:"min_handle,omitempty"`
	MidHandle []byte `protobuf:"bytes,4,opt,name=mid_handle,json=midHandle,proto3" json:"mid_handle,omitempty"`
	MaxHandle []byte `protobuf:"bytes,5,opt,name=max_handle,json=maxHandle,proto3" json:"max_handle,omitempty"`
}

func (m *FragProperty) Reset()         { *m = FragProperty{} }
func (m *FragProperty) String() string { return proto.CompactTextString(m) }
func (*FragProperty) ProtoMessage()    {}
func (*FragProperty) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{8}
}
func (m *FragProperty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FragProperty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FragProperty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FragProperty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FragProperty.Merge(m, src)
}
func (m *FragProperty) XXX_Size() int {
	return m.Size()
}
func (m *FragProperty) XXX_DiscardUnknown() {
	xxx_messageInfo_FragProperty.DiscardUnknown(m)
}

var xxx_messageInfo_FragProperty proto.InternalMessageInfo

func (m *FragProperty) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *FragProperty) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *FragProperty) GetMinHandle() []byte {
	if m != nil {
		return m.MinHandle
	}
	return nil
}

func (m *FragProperty) GetMidHandle() []byte {
	if m != nil {
		return m.MidHandle
	}
	return nil
}

func (m *FragProperty) GetMaxHandle() []byte {
	if m != nil {
		return m.MaxHandle
	}
	return nil
}

type FragMeta struct {
	// Data format version​​, used for future iterative upgrades
	FormatVersion uint64 `protobuf:"varint,1,opt,name=format_version,json=formatVersion,proto3" json:"format_version,omitempty"`
	// Root path of the fragment​​
	FragPath      string                   `protobuf:"bytes,2,opt,name=frag_path,json=fragPath,proto3" json:"frag_path,omitempty"`
	HasDeletedSet bool                     `protobuf:"varint,3,opt,name=has_deleted_set,json=hasDeletedSet,proto3" json:"has_deleted_set,omitempty"`
	Segs          []*FragMeta_IndexSegment `protobuf:"bytes,4,rep,name=segs,proto3" json:"segs,omitempty"`
	Property      *FragProperty            `protobuf:"bytes,5,opt,name=property,proto3" json:"property,omitempty"`
}

func (m *FragMeta) Reset()         { *m = FragMeta{} }
func (m *FragMeta) String() string { return proto.CompactTextString(m) }
func (*FragMeta) ProtoMessage()    {}
func (*FragMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{9}
}
func (m *FragMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FragMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FragMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FragMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FragMeta.Merge(m, src)
}
func (m *FragMeta) XXX_Size() int {
	return m.Size()
}
func (m *FragMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_FragMeta.DiscardUnknown(m)
}

var xxx_messageInfo_FragMeta proto.InternalMessageInfo

func (m *FragMeta) GetFormatVersion() uint64 {
	if m != nil {
		return m.FormatVersion
	}
	return 0
}

func (m *FragMeta) GetFragPath() string {
	if m != nil {
		return m.FragPath
	}
	return ""
}

func (m *FragMeta) GetHasDeletedSet() bool {
	if m != nil {
		return m.HasDeletedSet
	}
	return false
}

func (m *FragMeta) GetSegs() []*FragMeta_IndexSegment {
	if m != nil {
		return m.Segs
	}
	return nil
}

func (m *FragMeta) GetProperty() *FragProperty {
	if m != nil {
		return m.Property
	}
	return nil
}

type FragMeta_IndexSegment struct {
	SegId     string `protobuf:"bytes,1,opt,name=seg_id,json=segId,proto3" json:"seg_id,omitempty"`
	DelSuffix string `protobuf:"bytes,2,opt,name=del_suffix,json=delSuffix,proto3" json:"del_suffix,omitempty"`
}

func (m *FragMeta_IndexSegment) Reset()         { *m = FragMeta_IndexSegment{} }
func (m *FragMeta_IndexSegment) String() string { return proto.CompactTextString(m) }
func (*FragMeta_IndexSegment) ProtoMessage()    {}
func (*FragMeta_IndexSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{9, 0}
}
func (m *FragMeta_IndexSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FragMeta_IndexSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FragMeta_IndexSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FragMeta_IndexSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FragMeta_IndexSegment.Merge(m, src)
}
func (m *FragMeta_IndexSegment) XXX_Size() int {
	return m.Size()
}
func (m *FragMeta_IndexSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_FragMeta_IndexSegment.DiscardUnknown(m)
}

var xxx_messageInfo_FragMeta_IndexSegment proto.InternalMessageInfo

func (m *FragMeta_IndexSegment) GetSegId() string {
	if m != nil {
		return m.SegId
	}
	return ""
}

func (m *FragMeta_IndexSegment) GetDelSuffix() string {
	if m != nil {
		return m.DelSuffix
	}
	return ""
}

type ShardWatermark struct {
	// Types that are valid to be assigned to Watermark:
	//	*ShardWatermark_CdcFile
	//	*ShardWatermark_ImportFile
	Watermark isShardWatermark_Watermark `protobuf_oneof:"watermark"`
}

func (m *ShardWatermark) Reset()         { *m = ShardWatermark{} }
func (m *ShardWatermark) String() string { return proto.CompactTextString(m) }
func (*ShardWatermark) ProtoMessage()    {}
func (*ShardWatermark) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{10}
}
func (m *ShardWatermark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardWatermark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardWatermark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardWatermark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardWatermark.Merge(m, src)
}
func (m *ShardWatermark) XXX_Size() int {
	return m.Size()
}
func (m *ShardWatermark) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardWatermark.DiscardUnknown(m)
}

var xxx_messageInfo_ShardWatermark proto.InternalMessageInfo

type isShardWatermark_Watermark interface {
	isShardWatermark_Watermark()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ShardWatermark_CdcFile struct {
	CdcFile string `protobuf:"bytes,1,opt,name=cdc_file,json=cdcFile,proto3,oneof" json:"cdc_file,omitempty"`
}
type ShardWatermark_ImportFile struct {
	ImportFile string `protobuf:"bytes,2,opt,name=import_file,json=importFile,proto3,oneof" json:"import_file,omitempty"`
}

func (*ShardWatermark_CdcFile) isShardWatermark_Watermark()    {}
func (*ShardWatermark_ImportFile) isShardWatermark_Watermark() {}

func (m *ShardWatermark) GetWatermark() isShardWatermark_Watermark {
	if m != nil {
		return m.Watermark
	}
	return nil
}

func (m *ShardWatermark) GetCdcFile() string {
	if x, ok := m.GetWatermark().(*ShardWatermark_CdcFile); ok {
		return x.CdcFile
	}
	return ""
}

func (m *ShardWatermark) GetImportFile() string {
	if x, ok := m.GetWatermark().(*ShardWatermark_ImportFile); ok {
		return x.ImportFile
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ShardWatermark) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ShardWatermark_CdcFile)(nil),
		(*ShardWatermark_ImportFile)(nil),
	}
}

type AppendFragMetaRequest struct {
	TableId        int64           `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId        int64           `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	ShardId        uint64          `protobuf:"varint,3,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	WorkerNodeAddr string          `protobuf:"bytes,4,opt,name=worker_node_addr,json=workerNodeAddr,proto3" json:"worker_node_addr,omitempty"`
	FragMetas      []*FragMeta     `protobuf:"bytes,5,rep,name=frag_metas,json=fragMetas,proto3" json:"frag_metas,omitempty"`
	Watermark      *ShardWatermark `protobuf:"bytes,6,opt,name=watermark,proto3" json:"watermark,omitempty"`
}

func (m *AppendFragMetaRequest) Reset()         { *m = AppendFragMetaRequest{} }
func (m *AppendFragMetaRequest) String() string { return proto.CompactTextString(m) }
func (*AppendFragMetaRequest) ProtoMessage()    {}
func (*AppendFragMetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{11}
}
func (m *AppendFragMetaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendFragMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendFragMetaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendFragMetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendFragMetaRequest.Merge(m, src)
}
func (m *AppendFragMetaRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppendFragMetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendFragMetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendFragMetaRequest proto.InternalMessageInfo

func (m *AppendFragMetaRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *AppendFragMetaRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *AppendFragMetaRequest) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *AppendFragMetaRequest) GetWorkerNodeAddr() string {
	if m != nil {
		return m.WorkerNodeAddr
	}
	return ""
}

func (m *AppendFragMetaRequest) GetFragMetas() []*FragMeta {
	if m != nil {
		return m.FragMetas
	}
	return nil
}

func (m *AppendFragMetaRequest) GetWatermark() *ShardWatermark {
	if m != nil {
		return m.Watermark
	}
	return nil
}

type AppendFragMetaResponse struct {
	Status ErrorCode `protobuf:"varint,1,opt,name=status,proto3,enum=tici.ErrorCode" json:"status,omitempty"`
}

func (m *AppendFragMetaResponse) Reset()         { *m = AppendFragMetaResponse{} }
func (m *AppendFragMetaResponse) String() string { return proto.CompactTextString(m) }
func (*AppendFragMetaResponse) ProtoMessage()    {}
func (*AppendFragMetaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{12}
}
func (m *AppendFragMetaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendFragMetaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendFragMetaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendFragMetaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendFragMetaResponse.Merge(m, src)
}
func (m *AppendFragMetaResponse) XXX_Size() int {
	return m.Size()
}
func (m *AppendFragMetaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendFragMetaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AppendFragMetaResponse proto.InternalMessageInfo

func (m *AppendFragMetaResponse) GetStatus() ErrorCode {
	if m != nil {
		return m.Status
	}
	return ErrorCode_SUCCESS
}

// Key range definition
type KeyRange struct {
	// Inclusive lower key bound
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// Exclusive upper key bound
	EndKey []byte `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *KeyRange) Reset()         { *m = KeyRange{} }
func (m *KeyRange) String() string { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()    {}
func (*KeyRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{13}
}
func (m *KeyRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRange.Merge(m, src)
}
func (m *KeyRange) XXX_Size() int {
	return m.Size()
}
func (m *KeyRange) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRange.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRange proto.InternalMessageInfo

func (m *KeyRange) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *KeyRange) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

// Shard local cache information
type ShardLocalCacheInfo struct {
	Shard           *ShardManifestHeader `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard,omitempty"`
	LocalCacheAddrs []string             `protobuf:"bytes,2,rep,name=local_cache_addrs,json=localCacheAddrs,proto3" json:"local_cache_addrs,omitempty"`
}

func (m *ShardLocalCacheInfo) Reset()         { *m = ShardLocalCacheInfo{} }
func (m *ShardLocalCacheInfo) String() string { return proto.CompactTextString(m) }
func (*ShardLocalCacheInfo) ProtoMessage()    {}
func (*ShardLocalCacheInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{14}
}
func (m *ShardLocalCacheInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardLocalCacheInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardLocalCacheInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardLocalCacheInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardLocalCacheInfo.Merge(m, src)
}
func (m *ShardLocalCacheInfo) XXX_Size() int {
	return m.Size()
}
func (m *ShardLocalCacheInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardLocalCacheInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ShardLocalCacheInfo proto.InternalMessageInfo

func (m *ShardLocalCacheInfo) GetShard() *ShardManifestHeader {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *ShardLocalCacheInfo) GetLocalCacheAddrs() []string {
	if m != nil {
		return m.LocalCacheAddrs
	}
	return nil
}

// Request to get shard local cache information
type GetShardLocalCacheRequest struct {
	// Table ID to filter shards
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID to filter shards
	IndexId   int64       `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	KeyRanges []*KeyRange `protobuf:"bytes,3,rep,name=key_ranges,json=keyRanges,proto3" json:"key_ranges,omitempty"`
	// at most `limit` shards can be returned
	Limit int32 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *GetShardLocalCacheRequest) Reset()         { *m = GetShardLocalCacheRequest{} }
func (m *GetShardLocalCacheRequest) String() string { return proto.CompactTextString(m) }
func (*GetShardLocalCacheRequest) ProtoMessage()    {}
func (*GetShardLocalCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{15}
}
func (m *GetShardLocalCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardLocalCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardLocalCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardLocalCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardLocalCacheRequest.Merge(m, src)
}
func (m *GetShardLocalCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetShardLocalCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardLocalCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardLocalCacheRequest proto.InternalMessageInfo

func (m *GetShardLocalCacheRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetShardLocalCacheRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *GetShardLocalCacheRequest) GetKeyRanges() []*KeyRange {
	if m != nil {
		return m.KeyRanges
	}
	return nil
}

func (m *GetShardLocalCacheRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// Response containing shard local cache information
type GetShardLocalCacheResponse struct {
	Status               int32                  `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	ShardLocalCacheInfos []*ShardLocalCacheInfo `protobuf:"bytes,2,rep,name=shard_local_cache_infos,json=shardLocalCacheInfos,proto3" json:"shard_local_cache_infos,omitempty"`
}

func (m *GetShardLocalCacheResponse) Reset()         { *m = GetShardLocalCacheResponse{} }
func (m *GetShardLocalCacheResponse) String() string { return proto.CompactTextString(m) }
func (*GetShardLocalCacheResponse) ProtoMessage()    {}
func (*GetShardLocalCacheResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{16}
}
func (m *GetShardLocalCacheResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetShardLocalCacheResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetShardLocalCacheResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetShardLocalCacheResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetShardLocalCacheResponse.Merge(m, src)
}
func (m *GetShardLocalCacheResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetShardLocalCacheResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetShardLocalCacheResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetShardLocalCacheResponse proto.InternalMessageInfo

func (m *GetShardLocalCacheResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *GetShardLocalCacheResponse) GetShardLocalCacheInfos() []*ShardLocalCacheInfo {
	if m != nil {
		return m.ShardLocalCacheInfos
	}
	return nil
}

type DebugGetShardManifestRequest struct {
	TableId  int64     `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId  int64     `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	KeyRange *KeyRange `protobuf:"bytes,3,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
}

func (m *DebugGetShardManifestRequest) Reset()         { *m = DebugGetShardManifestRequest{} }
func (m *DebugGetShardManifestRequest) String() string { return proto.CompactTextString(m) }
func (*DebugGetShardManifestRequest) ProtoMessage()    {}
func (*DebugGetShardManifestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{17}
}
func (m *DebugGetShardManifestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugGetShardManifestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugGetShardManifestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugGetShardManifestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugGetShardManifestRequest.Merge(m, src)
}
func (m *DebugGetShardManifestRequest) XXX_Size() int {
	return m.Size()
}
func (m *DebugGetShardManifestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugGetShardManifestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DebugGetShardManifestRequest proto.InternalMessageInfo

func (m *DebugGetShardManifestRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DebugGetShardManifestRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *DebugGetShardManifestRequest) GetKeyRange() *KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

type DebugGetShardManifestResponse struct {
	FragMetas []*FragMeta `protobuf:"bytes,1,rep,name=frag_metas,json=fragMetas,proto3" json:"frag_metas,omitempty"`
}

func (m *DebugGetShardManifestResponse) Reset()         { *m = DebugGetShardManifestResponse{} }
func (m *DebugGetShardManifestResponse) String() string { return proto.CompactTextString(m) }
func (*DebugGetShardManifestResponse) ProtoMessage()    {}
func (*DebugGetShardManifestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{18}
}
func (m *DebugGetShardManifestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DebugGetShardManifestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DebugGetShardManifestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DebugGetShardManifestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugGetShardManifestResponse.Merge(m, src)
}
func (m *DebugGetShardManifestResponse) XXX_Size() int {
	return m.Size()
}
func (m *DebugGetShardManifestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugGetShardManifestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DebugGetShardManifestResponse proto.InternalMessageInfo

func (m *DebugGetShardManifestResponse) GetFragMetas() []*FragMeta {
	if m != nil {
		return m.FragMetas
	}
	return nil
}

type CompactFragRequest struct {
	Shard          *ShardManifestHeader `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard,omitempty"`
	TableId        int64                `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId        int64                `protobuf:"varint,3,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	Seq            uint64               `protobuf:"varint,4,opt,name=seq,proto3" json:"seq,omitempty"`
	Timestamp      uint64               `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	LeaderTerm     string               `protobuf:"bytes,6,opt,name=leader_term,json=leaderTerm,proto3" json:"leader_term,omitempty"`
	InputFrags     []*FragMeta          `protobuf:"bytes,7,rep,name=input_frags,json=inputFrags,proto3" json:"input_frags,omitempty"`
	UploadLocation *S3Location          `protobuf:"bytes,8,opt,name=upload_location,json=uploadLocation,proto3" json:"upload_location,omitempty"`
	CompactType    CompactType          `protobuf:"varint,9,opt,name=compact_type,json=compactType,proto3,enum=tici.CompactType" json:"compact_type,omitempty"`
	Worker         string               `protobuf:"bytes,10,opt,name=worker,proto3" json:"worker,omitempty"`
}

func (m *CompactFragRequest) Reset()         { *m = CompactFragRequest{} }
func (m *CompactFragRequest) String() string { return proto.CompactTextString(m) }
func (*CompactFragRequest) ProtoMessage()    {}
func (*CompactFragRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{19}
}
func (m *CompactFragRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactFragRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactFragRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactFragRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactFragRequest.Merge(m, src)
}
func (m *CompactFragRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompactFragRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactFragRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompactFragRequest proto.InternalMessageInfo

func (m *CompactFragRequest) GetShard() *ShardManifestHeader {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *CompactFragRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *CompactFragRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *CompactFragRequest) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *CompactFragRequest) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CompactFragRequest) GetLeaderTerm() string {
	if m != nil {
		return m.LeaderTerm
	}
	return ""
}

func (m *CompactFragRequest) GetInputFrags() []*FragMeta {
	if m != nil {
		return m.InputFrags
	}
	return nil
}

func (m *CompactFragRequest) GetUploadLocation() *S3Location {
	if m != nil {
		return m.UploadLocation
	}
	return nil
}

func (m *CompactFragRequest) GetCompactType() CompactType {
	if m != nil {
		return m.CompactType
	}
	return CompactType_Delta
}

func (m *CompactFragRequest) GetWorker() string {
	if m != nil {
		return m.Worker
	}
	return ""
}

type CompactFragResponse struct {
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *CompactFragResponse) Reset()         { *m = CompactFragResponse{} }
func (m *CompactFragResponse) String() string { return proto.CompactTextString(m) }
func (*CompactFragResponse) ProtoMessage()    {}
func (*CompactFragResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{20}
}
func (m *CompactFragResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactFragResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactFragResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactFragResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactFragResponse.Merge(m, src)
}
func (m *CompactFragResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompactFragResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactFragResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompactFragResponse proto.InternalMessageInfo

func (m *CompactFragResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type FinishCompactFragRequest struct {
	Addr        string               `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Shard       *ShardManifestHeader `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	TableId     int64                `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId     int64                `protobuf:"varint,4,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	Seq         uint64               `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	Timestamp   uint64               `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	LeaderTerm  string               `protobuf:"bytes,7,opt,name=leader_term,json=leaderTerm,proto3" json:"leader_term,omitempty"`
	InputFrags  []*FragMeta          `protobuf:"bytes,8,rep,name=input_frags,json=inputFrags,proto3" json:"input_frags,omitempty"`
	OutputFrags []*FragMeta          `protobuf:"bytes,9,rep,name=output_frags,json=outputFrags,proto3" json:"output_frags,omitempty"`
}

func (m *FinishCompactFragRequest) Reset()         { *m = FinishCompactFragRequest{} }
func (m *FinishCompactFragRequest) String() string { return proto.CompactTextString(m) }
func (*FinishCompactFragRequest) ProtoMessage()    {}
func (*FinishCompactFragRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{21}
}
func (m *FinishCompactFragRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishCompactFragRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishCompactFragRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishCompactFragRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishCompactFragRequest.Merge(m, src)
}
func (m *FinishCompactFragRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishCompactFragRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishCompactFragRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishCompactFragRequest proto.InternalMessageInfo

func (m *FinishCompactFragRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *FinishCompactFragRequest) GetShard() *ShardManifestHeader {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *FinishCompactFragRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *FinishCompactFragRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *FinishCompactFragRequest) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *FinishCompactFragRequest) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FinishCompactFragRequest) GetLeaderTerm() string {
	if m != nil {
		return m.LeaderTerm
	}
	return ""
}

func (m *FinishCompactFragRequest) GetInputFrags() []*FragMeta {
	if m != nil {
		return m.InputFrags
	}
	return nil
}

func (m *FinishCompactFragRequest) GetOutputFrags() []*FragMeta {
	if m != nil {
		return m.OutputFrags
	}
	return nil
}

type FinishCompactFragResponse struct {
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *FinishCompactFragResponse) Reset()         { *m = FinishCompactFragResponse{} }
func (m *FinishCompactFragResponse) String() string { return proto.CompactTextString(m) }
func (*FinishCompactFragResponse) ProtoMessage()    {}
func (*FinishCompactFragResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{22}
}
func (m *FinishCompactFragResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishCompactFragResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishCompactFragResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishCompactFragResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishCompactFragResponse.Merge(m, src)
}
func (m *FinishCompactFragResponse) XXX_Size() int {
	return m.Size()
}
func (m *FinishCompactFragResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishCompactFragResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FinishCompactFragResponse proto.InternalMessageInfo

func (m *FinishCompactFragResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type ShardManifestHeader struct {
	ShardId  uint64 `protobuf:"varint,1,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	StartKey []byte `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Epoch    uint64 `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *ShardManifestHeader) Reset()         { *m = ShardManifestHeader{} }
func (m *ShardManifestHeader) String() string { return proto.CompactTextString(m) }
func (*ShardManifestHeader) ProtoMessage()    {}
func (*ShardManifestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{23}
}
func (m *ShardManifestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardManifestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardManifestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardManifestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardManifestHeader.Merge(m, src)
}
func (m *ShardManifestHeader) XXX_Size() int {
	return m.Size()
}
func (m *ShardManifestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardManifestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ShardManifestHeader proto.InternalMessageInfo

func (m *ShardManifestHeader) GetShardId() uint64 {
	if m != nil {
		return m.ShardId
	}
	return 0
}

func (m *ShardManifestHeader) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *ShardManifestHeader) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *ShardManifestHeader) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type S3Location struct {
	Bucket string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *S3Location) Reset()         { *m = S3Location{} }
func (m *S3Location) String() string { return proto.CompactTextString(m) }
func (*S3Location) ProtoMessage()    {}
func (*S3Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{24}
}
func (m *S3Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S3Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S3Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S3Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S3Location.Merge(m, src)
}
func (m *S3Location) XXX_Size() int {
	return m.Size()
}
func (m *S3Location) XXX_DiscardUnknown() {
	xxx_messageInfo_S3Location.DiscardUnknown(m)
}

var xxx_messageInfo_S3Location proto.InternalMessageInfo

func (m *S3Location) GetBucket() string {
	if m != nil {
		return m.Bucket
	}
	return ""
}

func (m *S3Location) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// AddShardRequest is sent from meta service to worker node
type AddShardRequest struct {
	Shard *ShardManifestHeader `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard,omitempty"`
	// Index information
	IndexInfo *IndexInfo `protobuf:"bytes,2,opt,name=index_info,json=indexInfo,proto3" json:"index_info,omitempty"`
	// Table information
	TableInfo      *TableInfo      `protobuf:"bytes,3,opt,name=table_info,json=tableInfo,proto3" json:"table_info,omitempty"`
	Watermark      *ShardWatermark `protobuf:"bytes,4,opt,name=watermark,proto3" json:"watermark,omitempty"`
	CdcLocation    *S3Location     `protobuf:"bytes,5,opt,name=cdc_location,json=cdcLocation,proto3" json:"cdc_location,omitempty"`
	UploadLocation *S3Location     `protobuf:"bytes,6,opt,name=upload_location,json=uploadLocation,proto3" json:"upload_location,omitempty"`
}

func (m *AddShardRequest) Reset()         { *m = AddShardRequest{} }
func (m *AddShardRequest) String() string { return proto.CompactTextString(m) }
func (*AddShardRequest) ProtoMessage()    {}
func (*AddShardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{25}
}
func (m *AddShardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardRequest.Merge(m, src)
}
func (m *AddShardRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddShardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardRequest proto.InternalMessageInfo

func (m *AddShardRequest) GetShard() *ShardManifestHeader {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *AddShardRequest) GetIndexInfo() *IndexInfo {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *AddShardRequest) GetTableInfo() *TableInfo {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

func (m *AddShardRequest) GetWatermark() *ShardWatermark {
	if m != nil {
		return m.Watermark
	}
	return nil
}

func (m *AddShardRequest) GetCdcLocation() *S3Location {
	if m != nil {
		return m.CdcLocation
	}
	return nil
}

func (m *AddShardRequest) GetUploadLocation() *S3Location {
	if m != nil {
		return m.UploadLocation
	}
	return nil
}

// AddShardResponse
type AddShardResponse struct {
	// Operation result status code, 0 means success
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *AddShardResponse) Reset()         { *m = AddShardResponse{} }
func (m *AddShardResponse) String() string { return proto.CompactTextString(m) }
func (*AddShardResponse) ProtoMessage()    {}
func (*AddShardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{26}
}
func (m *AddShardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddShardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddShardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddShardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddShardResponse.Merge(m, src)
}
func (m *AddShardResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddShardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddShardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddShardResponse proto.InternalMessageInfo

func (m *AddShardResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// CreateIndexRequest is a request to create an index
type CreateIndexRequest struct {
	// Index information
	IndexInfo *IndexInfo `protobuf:"bytes,1,opt,name=index_info,json=indexInfo,proto3" json:"index_info,omitempty"`
	// Table information
	TableInfo *TableInfo `protobuf:"bytes,2,opt,name=table_info,json=tableInfo,proto3" json:"table_info,omitempty"`
}

func (m *CreateIndexRequest) Reset()         { *m = CreateIndexRequest{} }
func (m *CreateIndexRequest) String() string { return proto.CompactTextString(m) }
func (*CreateIndexRequest) ProtoMessage()    {}
func (*CreateIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{27}
}
func (m *CreateIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndexRequest.Merge(m, src)
}
func (m *CreateIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndexRequest proto.InternalMessageInfo

func (m *CreateIndexRequest) GetIndexInfo() *IndexInfo {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *CreateIndexRequest) GetTableInfo() *TableInfo {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

// CreateIndexResponse is a response to the index creation request
type CreateIndexResponse struct {
	// Operation result status code, 0 means success
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Created index ID
	IndexId string `protobuf:"bytes,3,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *CreateIndexResponse) Reset()         { *m = CreateIndexResponse{} }
func (m *CreateIndexResponse) String() string { return proto.CompactTextString(m) }
func (*CreateIndexResponse) ProtoMessage()    {}
func (*CreateIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{28}
}
func (m *CreateIndexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateIndexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateIndexResponse.Merge(m, src)
}
func (m *CreateIndexResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateIndexResponse proto.InternalMessageInfo

func (m *CreateIndexResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *CreateIndexResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CreateIndexResponse) GetIndexId() string {
	if m != nil {
		return m.IndexId
	}
	return ""
}

// DropIndexRequest is a request to drop an index
type DropIndexRequest struct {
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *DropIndexRequest) Reset()         { *m = DropIndexRequest{} }
func (m *DropIndexRequest) String() string { return proto.CompactTextString(m) }
func (*DropIndexRequest) ProtoMessage()    {}
func (*DropIndexRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{29}
}
func (m *DropIndexRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndexRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndexRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndexRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndexRequest.Merge(m, src)
}
func (m *DropIndexRequest) XXX_Size() int {
	return m.Size()
}
func (m *DropIndexRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndexRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndexRequest proto.InternalMessageInfo

func (m *DropIndexRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *DropIndexRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

// DropIndexResponse is a response to the index drop request
type DropIndexResponse struct {
	// Operation result status code, 0 means success
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *DropIndexResponse) Reset()         { *m = DropIndexResponse{} }
func (m *DropIndexResponse) String() string { return proto.CompactTextString(m) }
func (*DropIndexResponse) ProtoMessage()    {}
func (*DropIndexResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{30}
}
func (m *DropIndexResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropIndexResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropIndexResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropIndexResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropIndexResponse.Merge(m, src)
}
func (m *DropIndexResponse) XXX_Size() int {
	return m.Size()
}
func (m *DropIndexResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DropIndexResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DropIndexResponse proto.InternalMessageInfo

func (m *DropIndexResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DropIndexResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// TableInfo represents table information
type TableInfo struct {
	// Table ID
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Table name
	TableName string `protobuf:"bytes,2,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	// Database name
	DatabaseName string `protobuf:"bytes,3,opt,name=database_name,json=databaseName,proto3" json:"database_name,omitempty"`
	// Table version
	Version int64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// Column information
	Columns []*ColumnInfo `protobuf:"bytes,5,rep,name=columns,proto3" json:"columns,omitempty"`
	// Whether the table is clustered
	IsClustered bool `protobuf:"varint,6,opt,name=is_clustered,json=isClustered,proto3" json:"is_clustered,omitempty"`
}

func (m *TableInfo) Reset()         { *m = TableInfo{} }
func (m *TableInfo) String() string { return proto.CompactTextString(m) }
func (*TableInfo) ProtoMessage()    {}
func (*TableInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{31}
}
func (m *TableInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableInfo.Merge(m, src)
}
func (m *TableInfo) XXX_Size() int {
	return m.Size()
}
func (m *TableInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableInfo proto.InternalMessageInfo

func (m *TableInfo) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TableInfo) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *TableInfo) GetDatabaseName() string {
	if m != nil {
		return m.DatabaseName
	}
	return ""
}

func (m *TableInfo) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *TableInfo) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *TableInfo) GetIsClustered() bool {
	if m != nil {
		return m.IsClustered
	}
	return false
}

// ColumnInfo represents column information
type ColumnInfo struct {
	// Column ID
	ColumnId int64 `protobuf:"varint,1,opt,name=column_id,json=columnId,proto3" json:"column_id,omitempty"`
	// Column name
	ColumnName string `protobuf:"bytes,2,opt,name=column_name,json=columnName,proto3" json:"column_name,omitempty"`
	// MySQL type
	Type int32 `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	// Collation
	Collation int32 `protobuf:"varint,4,opt,name=collation,proto3" json:"collation,omitempty"`
	// Column length
	ColumnLength int32 `protobuf:"varint,5,opt,name=column_length,json=columnLength,proto3" json:"column_length,omitempty"`
	// Decimal places
	Decimal int32 `protobuf:"varint,6,opt,name=decimal,proto3" json:"decimal,omitempty"`
	// Flags
	Flag uint32 `protobuf:"varint,7,opt,name=flag,proto3" json:"flag,omitempty"`
	// Enum elements
	Elems []string `protobuf:"bytes,8,rep,name=elems,proto3" json:"elems,omitempty"`
	// Default value
	DefaultVal []byte `protobuf:"bytes,9,opt,name=default_val,json=defaultVal,proto3" json:"default_val,omitempty"`
	// Whether it's a primary key
	IsPrimaryKey bool `protobuf:"varint,10,opt,name=is_primary_key,json=isPrimaryKey,proto3" json:"is_primary_key,omitempty"`
	// Whether it's an array
	IsArray bool `protobuf:"varint,11,opt,name=is_array,json=isArray,proto3" json:"is_array,omitempty"`
}

func (m *ColumnInfo) Reset()         { *m = ColumnInfo{} }
func (m *ColumnInfo) String() string { return proto.CompactTextString(m) }
func (*ColumnInfo) ProtoMessage()    {}
func (*ColumnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{32}
}
func (m *ColumnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnInfo.Merge(m, src)
}
func (m *ColumnInfo) XXX_Size() int {
	return m.Size()
}
func (m *ColumnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnInfo proto.InternalMessageInfo

func (m *ColumnInfo) GetColumnId() int64 {
	if m != nil {
		return m.ColumnId
	}
	return 0
}

func (m *ColumnInfo) GetColumnName() string {
	if m != nil {
		return m.ColumnName
	}
	return ""
}

func (m *ColumnInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ColumnInfo) GetCollation() int32 {
	if m != nil {
		return m.Collation
	}
	return 0
}

func (m *ColumnInfo) GetColumnLength() int32 {
	if m != nil {
		return m.ColumnLength
	}
	return 0
}

func (m *ColumnInfo) GetDecimal() int32 {
	if m != nil {
		return m.Decimal
	}
	return 0
}

func (m *ColumnInfo) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *ColumnInfo) GetElems() []string {
	if m != nil {
		return m.Elems
	}
	return nil
}

func (m *ColumnInfo) GetDefaultVal() []byte {
	if m != nil {
		return m.DefaultVal
	}
	return nil
}

func (m *ColumnInfo) GetIsPrimaryKey() bool {
	if m != nil {
		return m.IsPrimaryKey
	}
	return false
}

func (m *ColumnInfo) GetIsArray() bool {
	if m != nil {
		return m.IsArray
	}
	return false
}

// IndexInfo represents index information
type IndexInfo struct {
	// Table ID
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
	// Index name
	IndexName string `protobuf:"bytes,3,opt,name=index_name,json=indexName,proto3" json:"index_name,omitempty"`
	// Index type (fulltext, custom)
	IndexType IndexType `protobuf:"varint,4,opt,name=index_type,json=indexType,proto3,enum=tici.IndexType" json:"index_type,omitempty"`
	// Index columns
	Columns []*ColumnInfo `protobuf:"bytes,5,rep,name=columns,proto3" json:"columns,omitempty"`
	// Whether the index is unique
	IsUnique bool `protobuf:"varint,6,opt,name=is_unique,json=isUnique,proto3" json:"is_unique,omitempty"`
	// Parser information
	ParserInfo *ParserInfo `protobuf:"bytes,7,opt,name=parser_info,json=parserInfo,proto3" json:"parser_info,omitempty"`
	// Other index parameters
	OtherParams map[string]string `protobuf:"bytes,8,rep,name=other_params,json=otherParams,proto3" json:"other_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *IndexInfo) Reset()         { *m = IndexInfo{} }
func (m *IndexInfo) String() string { return proto.CompactTextString(m) }
func (*IndexInfo) ProtoMessage()    {}
func (*IndexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{33}
}
func (m *IndexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexInfo.Merge(m, src)
}
func (m *IndexInfo) XXX_Size() int {
	return m.Size()
}
func (m *IndexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IndexInfo proto.InternalMessageInfo

func (m *IndexInfo) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *IndexInfo) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

func (m *IndexInfo) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *IndexInfo) GetIndexType() IndexType {
	if m != nil {
		return m.IndexType
	}
	return IndexType_UNKNOWN
}

func (m *IndexInfo) GetColumns() []*ColumnInfo {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *IndexInfo) GetIsUnique() bool {
	if m != nil {
		return m.IsUnique
	}
	return false
}

func (m *IndexInfo) GetParserInfo() *ParserInfo {
	if m != nil {
		return m.ParserInfo
	}
	return nil
}

func (m *IndexInfo) GetOtherParams() map[string]string {
	if m != nil {
		return m.OtherParams
	}
	return nil
}

// ParserInfo represents parser information
type ParserInfo struct {
	// Parser type
	ParserType ParserType `protobuf:"varint,1,opt,name=parser_type,json=parserType,proto3,enum=tici.ParserType" json:"parser_type,omitempty"`
	// Parser parameters
	ParserParams map[string]string `protobuf:"bytes,2,rep,name=parser_params,json=parserParams,proto3" json:"parser_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ParserInfo) Reset()         { *m = ParserInfo{} }
func (m *ParserInfo) String() string { return proto.CompactTextString(m) }
func (*ParserInfo) ProtoMessage()    {}
func (*ParserInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{34}
}
func (m *ParserInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParserInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParserInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParserInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParserInfo.Merge(m, src)
}
func (m *ParserInfo) XXX_Size() int {
	return m.Size()
}
func (m *ParserInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ParserInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ParserInfo proto.InternalMessageInfo

func (m *ParserInfo) GetParserType() ParserType {
	if m != nil {
		return m.ParserType
	}
	return ParserType_UNKNOWN_PARSER
}

func (m *ParserInfo) GetParserParams() map[string]string {
	if m != nil {
		return m.ParserParams
	}
	return nil
}

// GetIndexProgressRequest is a request to get the progress of an index build
type GetIndexProgressRequest struct {
	// Table ID
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *GetIndexProgressRequest) Reset()         { *m = GetIndexProgressRequest{} }
func (m *GetIndexProgressRequest) String() string { return proto.CompactTextString(m) }
func (*GetIndexProgressRequest) ProtoMessage()    {}
func (*GetIndexProgressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{35}
}
func (m *GetIndexProgressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexProgressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexProgressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexProgressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexProgressRequest.Merge(m, src)
}
func (m *GetIndexProgressRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexProgressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexProgressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexProgressRequest proto.InternalMessageInfo

func (m *GetIndexProgressRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetIndexProgressRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

// GetIndexProgressResponse is a response containing index build progress
type GetIndexProgressResponse struct {
	// Operation result status code, 0 means success
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Error message, only valid when status is non-zero
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Number of documents indexed so far
	DocumentCount uint64 `protobuf:"varint,3,opt,name=document_count,json=documentCount,proto3" json:"document_count,omitempty"`
	// Build task state (PENDING, RUNNING, COMPLETED, FAILED)
	State GetIndexProgressResponse_State `protobuf:"varint,4,opt,name=state,proto3,enum=tici.GetIndexProgressResponse_State" json:"state,omitempty"`
	// Whether index has been uploaded to S3
	IsUploaded bool `protobuf:"varint,5,opt,name=is_uploaded,json=isUploaded,proto3" json:"is_uploaded,omitempty"`
	// Last S3 upload time in RFC3339 format
	LastUploadTime string `protobuf:"bytes,6,opt,name=last_upload_time,json=lastUploadTime,proto3" json:"last_upload_time,omitempty"`
	// S3 path where the index is stored
	S3Path string `protobuf:"bytes,7,opt,name=s3_path,json=s3Path,proto3" json:"s3_path,omitempty"`
}

func (m *GetIndexProgressResponse) Reset()         { *m = GetIndexProgressResponse{} }
func (m *GetIndexProgressResponse) String() string { return proto.CompactTextString(m) }
func (*GetIndexProgressResponse) ProtoMessage()    {}
func (*GetIndexProgressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{36}
}
func (m *GetIndexProgressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexProgressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexProgressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexProgressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexProgressResponse.Merge(m, src)
}
func (m *GetIndexProgressResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexProgressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexProgressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexProgressResponse proto.InternalMessageInfo

func (m *GetIndexProgressResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *GetIndexProgressResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *GetIndexProgressResponse) GetDocumentCount() uint64 {
	if m != nil {
		return m.DocumentCount
	}
	return 0
}

func (m *GetIndexProgressResponse) GetState() GetIndexProgressResponse_State {
	if m != nil {
		return m.State
	}
	return GetIndexProgressResponse_PENDING
}

func (m *GetIndexProgressResponse) GetIsUploaded() bool {
	if m != nil {
		return m.IsUploaded
	}
	return false
}

func (m *GetIndexProgressResponse) GetLastUploadTime() string {
	if m != nil {
		return m.LastUploadTime
	}
	return ""
}

func (m *GetIndexProgressResponse) GetS3Path() string {
	if m != nil {
		return m.S3Path
	}
	return ""
}

type GetImportStoragePathRequest struct {
	// Detailed schema of the fts being built.
	IndexInfo *IndexInfo `protobuf:"bytes,1,opt,name=index_info,json=indexInfo,proto3" json:"index_info,omitempty"`
	// Parent table metadata.
	TableInfo *TableInfo `protobuf:"bytes,2,opt,name=table_info,json=tableInfo,proto3" json:"table_info,omitempty"`
	// Inclusive lower key bound (encoded handle/rowID), non-empty.
	LowerBound []byte `protobuf:"bytes,3,opt,name=lower_bound,json=lowerBound,proto3" json:"lower_bound,omitempty"`
	// Exclusive upper key bound, non-empty.
	UpperBound []byte `protobuf:"bytes,4,opt,name=upper_bound,json=upperBound,proto3" json:"upper_bound,omitempty"`
}

func (m *GetImportStoragePathRequest) Reset()         { *m = GetImportStoragePathRequest{} }
func (m *GetImportStoragePathRequest) String() string { return proto.CompactTextString(m) }
func (*GetImportStoragePathRequest) ProtoMessage()    {}
func (*GetImportStoragePathRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{37}
}
func (m *GetImportStoragePathRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImportStoragePathRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImportStoragePathRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImportStoragePathRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImportStoragePathRequest.Merge(m, src)
}
func (m *GetImportStoragePathRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetImportStoragePathRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImportStoragePathRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetImportStoragePathRequest proto.InternalMessageInfo

func (m *GetImportStoragePathRequest) GetIndexInfo() *IndexInfo {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *GetImportStoragePathRequest) GetTableInfo() *TableInfo {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

func (m *GetImportStoragePathRequest) GetLowerBound() []byte {
	if m != nil {
		return m.LowerBound
	}
	return nil
}

func (m *GetImportStoragePathRequest) GetUpperBound() []byte {
	if m != nil {
		return m.UpperBound
	}
	return nil
}

type GetImportStoragePathResponse struct {
	// 0 - success
	// ... other error codes
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Optional human‑readable diagnostics, only defined when status ≠ 0.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Object key inside the bucket that TiDB Import should write to.
	// The format is "s3://bucket/prefix/filename".
	S3Path string `protobuf:"bytes,3,opt,name=s3_path,json=s3Path,proto3" json:"s3_path,omitempty"`
}

func (m *GetImportStoragePathResponse) Reset()         { *m = GetImportStoragePathResponse{} }
func (m *GetImportStoragePathResponse) String() string { return proto.CompactTextString(m) }
func (*GetImportStoragePathResponse) ProtoMessage()    {}
func (*GetImportStoragePathResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{38}
}
func (m *GetImportStoragePathResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImportStoragePathResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImportStoragePathResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImportStoragePathResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImportStoragePathResponse.Merge(m, src)
}
func (m *GetImportStoragePathResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetImportStoragePathResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImportStoragePathResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetImportStoragePathResponse proto.InternalMessageInfo

func (m *GetImportStoragePathResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *GetImportStoragePathResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *GetImportStoragePathResponse) GetS3Path() string {
	if m != nil {
		return m.S3Path
	}
	return ""
}

type MarkPartitionUploadFinishedRequest struct {
	// The same S3 path previously returned by GetCloudStoragePath.
	// We assume the path is unique for each partition so it can be used to
	// identify the partition.
	S3Path string `protobuf:"bytes,1,opt,name=s3_path,json=s3Path,proto3" json:"s3_path,omitempty"`
}

func (m *MarkPartitionUploadFinishedRequest) Reset()         { *m = MarkPartitionUploadFinishedRequest{} }
func (m *MarkPartitionUploadFinishedRequest) String() string { return proto.CompactTextString(m) }
func (*MarkPartitionUploadFinishedRequest) ProtoMessage()    {}
func (*MarkPartitionUploadFinishedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{39}
}
func (m *MarkPartitionUploadFinishedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkPartitionUploadFinishedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkPartitionUploadFinishedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkPartitionUploadFinishedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkPartitionUploadFinishedRequest.Merge(m, src)
}
func (m *MarkPartitionUploadFinishedRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkPartitionUploadFinishedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkPartitionUploadFinishedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkPartitionUploadFinishedRequest proto.InternalMessageInfo

func (m *MarkPartitionUploadFinishedRequest) GetS3Path() string {
	if m != nil {
		return m.S3Path
	}
	return ""
}

// DXF receives this in-band result so callers can
// inspect the status and customized results.
type MarkPartitionUploadFinishedResponse struct {
	// 0 - success
	// ... other error codes
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Optional human‑readable diagnostics, only defined when status ≠ 0.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *MarkPartitionUploadFinishedResponse) Reset()         { *m = MarkPartitionUploadFinishedResponse{} }
func (m *MarkPartitionUploadFinishedResponse) String() string { return proto.CompactTextString(m) }
func (*MarkPartitionUploadFinishedResponse) ProtoMessage()    {}
func (*MarkPartitionUploadFinishedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{40}
}
func (m *MarkPartitionUploadFinishedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkPartitionUploadFinishedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkPartitionUploadFinishedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkPartitionUploadFinishedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkPartitionUploadFinishedResponse.Merge(m, src)
}
func (m *MarkPartitionUploadFinishedResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkPartitionUploadFinishedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkPartitionUploadFinishedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkPartitionUploadFinishedResponse proto.InternalMessageInfo

func (m *MarkPartitionUploadFinishedResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MarkPartitionUploadFinishedResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type MarkTableUploadFinishedRequest struct {
	// Table ID of the target table.
	TableId int64 `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	// Index ID of the target index.
	IndexId int64 `protobuf:"varint,2,opt,name=index_id,json=indexId,proto3" json:"index_id,omitempty"`
}

func (m *MarkTableUploadFinishedRequest) Reset()         { *m = MarkTableUploadFinishedRequest{} }
func (m *MarkTableUploadFinishedRequest) String() string { return proto.CompactTextString(m) }
func (*MarkTableUploadFinishedRequest) ProtoMessage()    {}
func (*MarkTableUploadFinishedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{41}
}
func (m *MarkTableUploadFinishedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkTableUploadFinishedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkTableUploadFinishedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkTableUploadFinishedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkTableUploadFinishedRequest.Merge(m, src)
}
func (m *MarkTableUploadFinishedRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkTableUploadFinishedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkTableUploadFinishedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkTableUploadFinishedRequest proto.InternalMessageInfo

func (m *MarkTableUploadFinishedRequest) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *MarkTableUploadFinishedRequest) GetIndexId() int64 {
	if m != nil {
		return m.IndexId
	}
	return 0
}

type MarkTableUploadFinishedResponse struct {
	// 0 - success
	// ... other error codes
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Optional human‑readable diagnostics, only defined when status ≠ 0.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *MarkTableUploadFinishedResponse) Reset()         { *m = MarkTableUploadFinishedResponse{} }
func (m *MarkTableUploadFinishedResponse) String() string { return proto.CompactTextString(m) }
func (*MarkTableUploadFinishedResponse) ProtoMessage()    {}
func (*MarkTableUploadFinishedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_80e84b3910d5cd39, []int{42}
}
func (m *MarkTableUploadFinishedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkTableUploadFinishedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkTableUploadFinishedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkTableUploadFinishedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkTableUploadFinishedResponse.Merge(m, src)
}
func (m *MarkTableUploadFinishedResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkTableUploadFinishedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkTableUploadFinishedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkTableUploadFinishedResponse proto.InternalMessageInfo

func (m *MarkTableUploadFinishedResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *MarkTableUploadFinishedResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func init() {
	proto.RegisterEnum("tici.ErrorCode", ErrorCode_name, ErrorCode_value)
	proto.RegisterEnum("tici.CompactType", CompactType_name, CompactType_value)
	proto.RegisterEnum("tici.IndexType", IndexType_name, IndexType_value)
	proto.RegisterEnum("tici.ParserType", ParserType_name, ParserType_value)
	proto.RegisterEnum("tici.GetIndexProgressResponse_State", GetIndexProgressResponse_State_name, GetIndexProgressResponse_State_value)
	proto.RegisterType((*WorkerNodeStatus)(nil), "tici.WorkerNodeStatus")
	proto.RegisterType((*ReaderNodeStatus)(nil), "tici.ReaderNodeStatus")
	proto.RegisterType((*WorkerNodeShardStatus)(nil), "tici.WorkerNodeShardStatus")
	proto.RegisterType((*WorkerNodeCompactionStatus)(nil), "tici.WorkerNodeCompactionStatus")
	proto.RegisterType((*WorkerNodeHeartbeatRequest)(nil), "tici.WorkerNodeHeartbeatRequest")
	proto.RegisterType((*WorkerNodeHeartbeatResponse)(nil), "tici.WorkerNodeHeartbeatResponse")
	proto.RegisterType((*ReaderNodeHeartbeatRequest)(nil), "tici.ReaderNodeHeartbeatRequest")
	proto.RegisterType((*ReaderNodeHeartbeatResponse)(nil), "tici.ReaderNodeHeartbeatResponse")
	proto.RegisterType((*FragProperty)(nil), "tici.FragProperty")
	proto.RegisterType((*FragMeta)(nil), "tici.FragMeta")
	proto.RegisterType((*FragMeta_IndexSegment)(nil), "tici.FragMeta.IndexSegment")
	proto.RegisterType((*ShardWatermark)(nil), "tici.ShardWatermark")
	proto.RegisterType((*AppendFragMetaRequest)(nil), "tici.AppendFragMetaRequest")
	proto.RegisterType((*AppendFragMetaResponse)(nil), "tici.AppendFragMetaResponse")
	proto.RegisterType((*KeyRange)(nil), "tici.KeyRange")
	proto.RegisterType((*ShardLocalCacheInfo)(nil), "tici.ShardLocalCacheInfo")
	proto.RegisterType((*GetShardLocalCacheRequest)(nil), "tici.GetShardLocalCacheRequest")
	proto.RegisterType((*GetShardLocalCacheResponse)(nil), "tici.GetShardLocalCacheResponse")
	proto.RegisterType((*DebugGetShardManifestRequest)(nil), "tici.DebugGetShardManifestRequest")
	proto.RegisterType((*DebugGetShardManifestResponse)(nil), "tici.DebugGetShardManifestResponse")
	proto.RegisterType((*CompactFragRequest)(nil), "tici.CompactFragRequest")
	proto.RegisterType((*CompactFragResponse)(nil), "tici.CompactFragResponse")
	proto.RegisterType((*FinishCompactFragRequest)(nil), "tici.FinishCompactFragRequest")
	proto.RegisterType((*FinishCompactFragResponse)(nil), "tici.FinishCompactFragResponse")
	proto.RegisterType((*ShardManifestHeader)(nil), "tici.ShardManifestHeader")
	proto.RegisterType((*S3Location)(nil), "tici.S3Location")
	proto.RegisterType((*AddShardRequest)(nil), "tici.AddShardRequest")
	proto.RegisterType((*AddShardResponse)(nil), "tici.AddShardResponse")
	proto.RegisterType((*CreateIndexRequest)(nil), "tici.CreateIndexRequest")
	proto.RegisterType((*CreateIndexResponse)(nil), "tici.CreateIndexResponse")
	proto.RegisterType((*DropIndexRequest)(nil), "tici.DropIndexRequest")
	proto.RegisterType((*DropIndexResponse)(nil), "tici.DropIndexResponse")
	proto.RegisterType((*TableInfo)(nil), "tici.TableInfo")
	proto.RegisterType((*ColumnInfo)(nil), "tici.ColumnInfo")
	proto.RegisterType((*IndexInfo)(nil), "tici.IndexInfo")
	proto.RegisterMapType((map[string]string)(nil), "tici.IndexInfo.OtherParamsEntry")
	proto.RegisterType((*ParserInfo)(nil), "tici.ParserInfo")
	proto.RegisterMapType((map[string]string)(nil), "tici.ParserInfo.ParserParamsEntry")
	proto.RegisterType((*GetIndexProgressRequest)(nil), "tici.GetIndexProgressRequest")
	proto.RegisterType((*GetIndexProgressResponse)(nil), "tici.GetIndexProgressResponse")
	proto.RegisterType((*GetImportStoragePathRequest)(nil), "tici.GetImportStoragePathRequest")
	proto.RegisterType((*GetImportStoragePathResponse)(nil), "tici.GetImportStoragePathResponse")
	proto.RegisterType((*MarkPartitionUploadFinishedRequest)(nil), "tici.MarkPartitionUploadFinishedRequest")
	proto.RegisterType((*MarkPartitionUploadFinishedResponse)(nil), "tici.MarkPartitionUploadFinishedResponse")
	proto.RegisterType((*MarkTableUploadFinishedRequest)(nil), "tici.MarkTableUploadFinishedRequest")
	proto.RegisterType((*MarkTableUploadFinishedResponse)(nil), "tici.MarkTableUploadFinishedResponse")
}

func init() { proto.RegisterFile("tici.proto", fileDescriptor_80e84b3910d5cd39) }

var fileDescriptor_80e84b3910d5cd39 = []byte{
	// 2827 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x1a, 0x4d, 0x6f, 0x1b, 0xc7,
	0x55, 0xcb, 0x0f, 0x89, 0x7c, 0xa4, 0xa8, 0xf5, 0xc8, 0x1f, 0x34, 0x65, 0x2b, 0xf2, 0xc6, 0x69,
	0x55, 0xb5, 0x91, 0x11, 0xa9, 0x87, 0x26, 0x48, 0x3f, 0x64, 0x91, 0xb2, 0x04, 0x4b, 0x94, 0x3a,
	0x94, 0xec, 0x34, 0x45, 0xba, 0x1d, 0x71, 0x47, 0xe4, 0x42, 0xcb, 0x5d, 0x7a, 0x67, 0x68, 0x5b,
	0x45, 0x2f, 0xbd, 0xe4, 0xdc, 0xa2, 0x68, 0x51, 0xa0, 0xe8, 0xad, 0x87, 0x02, 0xfd, 0x07, 0x45,
	0x81, 0xde, 0xd2, 0x8f, 0x53, 0x80, 0x5e, 0xd2, 0x5b, 0x11, 0xff, 0x86, 0xdc, 0x8b, 0xf9, 0xd8,
	0xe5, 0xf2, 0x4b, 0xb2, 0x6c, 0xa3, 0xb7, 0x99, 0xf7, 0xde, 0xbc, 0x79, 0xdf, 0xef, 0xed, 0x90,
	0x00, 0xdc, 0x6d, 0xba, 0xab, 0xdd, 0x30, 0xe0, 0x01, 0xca, 0x88, 0x75, 0xe5, 0x6a, 0x2b, 0x68,
	0x05, 0x12, 0x70, 0x4f, 0xac, 0x14, 0xae, 0x32, 0x17, 0xf6, 0x18, 0x97, 0x4b, 0x05, 0xb0, 0x30,
	0x98, 0x8f, 0x83, 0xf0, 0x94, 0x86, 0xf5, 0xc0, 0xa1, 0x0d, 0x4e, 0x78, 0x8f, 0xa1, 0x05, 0xc8,
	0x37, 0xbb, 0x3d, 0xbb, 0xc7, 0x48, 0x8b, 0x96, 0x8d, 0x25, 0x63, 0xd9, 0xc0, 0xb9, 0x66, 0xb7,
	0x77, 0x24, 0xf6, 0xe8, 0x0e, 0x14, 0x3b, 0xb4, 0x13, 0x84, 0x67, 0x1a, 0x9f, 0x5a, 0x32, 0x96,
	0x33, 0xb8, 0xa0, 0x60, 0x92, 0xc4, 0xfa, 0xa3, 0x01, 0x26, 0xa6, 0xc4, 0x79, 0x93, 0x4c, 0xd1,
	0x0a, 0x5c, 0x09, 0xe9, 0x93, 0x1e, 0x65, 0x9c, 0xd9, 0xae, 0x6f, 0x37, 0xcf, 0x9a, 0x1e, 0x2d,
	0xa7, 0x97, 0x8c, 0xe5, 0x59, 0x3c, 0x17, 0x21, 0x76, 0xfc, 0x4d, 0x01, 0x46, 0x77, 0xa1, 0xd4,
	0x24, 0xcd, 0x36, 0xb5, 0xdb, 0x2e, 0xb7, 0x43, 0xc2, 0x69, 0x39, 0x23, 0x2f, 0x2c, 0x4a, 0xe8,
	0xb6, 0xcb, 0x31, 0xe1, 0xd4, 0xfa, 0xcc, 0x80, 0x6b, 0x09, 0xdd, 0xdb, 0x24, 0x74, 0xfa, 0xb2,
	0x32, 0x4e, 0x42, 0x6e, 0x9f, 0xd2, 0x33, 0x29, 0x6b, 0x11, 0xe7, 0x24, 0xe0, 0x21, 0x3d, 0x43,
	0x37, 0x60, 0x86, 0xfa, 0x8e, 0x44, 0xa5, 0x24, 0x6a, 0x9a, 0xfa, 0x8e, 0x40, 0xdc, 0x84, 0x1c,
	0x27, 0xc7, 0x1e, 0xb5, 0x5d, 0x47, 0x0a, 0x96, 0xc6, 0x33, 0x72, 0xbf, 0xe3, 0x08, 0x94, 0xeb,
	0x3b, 0xf4, 0xb9, 0x40, 0x65, 0x14, 0x4a, 0xee, 0x15, 0x8a, 0x89, 0xab, 0x05, 0x2a, 0x2b, 0xd5,
	0x9e, 0x91, 0xfb, 0x1d, 0x07, 0x5d, 0x85, 0x2c, 0xed, 0x06, 0xcd, 0x76, 0x79, 0x5a, 0xc2, 0xd5,
	0x06, 0x99, 0x90, 0x66, 0xf4, 0x49, 0x79, 0x46, 0xc2, 0xc4, 0xd2, 0xda, 0x86, 0x4a, 0x5f, 0x8f,
	0xcd, 0xa0, 0xd3, 0x25, 0x4d, 0xee, 0x06, 0xbe, 0x56, 0x66, 0x05, 0xd2, 0x21, 0x7d, 0x22, 0xd5,
	0x28, 0xac, 0x95, 0x57, 0x65, 0xa0, 0x68, 0xa2, 0xad, 0x90, 0xb4, 0xb0, 0xb2, 0x1d, 0x16, 0x44,
	0xd6, 0x7f, 0x8c, 0x24, 0xab, 0x6d, 0x4a, 0x42, 0x7e, 0x4c, 0x09, 0xd7, 0x34, 0x08, 0x41, 0x86,
	0x38, 0x4e, 0x28, 0x79, 0xe5, 0xb1, 0x5c, 0xa3, 0x55, 0x98, 0x66, 0xf2, 0x22, 0x69, 0x8d, 0xc2,
	0xda, 0x75, 0x75, 0xc3, 0x70, 0x50, 0x61, 0x4d, 0x85, 0xd6, 0x61, 0x5a, 0xea, 0xc7, 0xca, 0xe9,
	0xa5, 0xf4, 0x72, 0x61, 0x6d, 0x61, 0x84, 0xbe, 0xef, 0x08, 0xac, 0x49, 0xd1, 0x7d, 0x28, 0x34,
	0x63, 0xbd, 0x58, 0x39, 0x23, 0x4f, 0x2e, 0x0d, 0x9f, 0x1c, 0x56, 0x1d, 0x27, 0x0f, 0x59, 0x7f,
	0x36, 0x60, 0x61, 0xac, 0x6e, 0xac, 0x1b, 0xf8, 0x8c, 0xa2, 0xaf, 0xc7, 0x8a, 0x08, 0xf5, 0x4a,
	0x6b, 0x73, 0x8a, 0x7d, 0x2d, 0x0c, 0x83, 0x70, 0x33, 0x70, 0x68, 0xac, 0xc1, 0xfb, 0x30, 0xcb,
	0x03, 0x9b, 0x38, 0x8e, 0xad, 0x15, 0x49, 0x49, 0x71, 0xae, 0x29, 0xfa, 0x0d, 0xc7, 0x91, 0x1a,
	0x44, 0x76, 0x2d, 0xf0, 0x20, 0x02, 0x31, 0xb4, 0x0c, 0x26, 0x0f, 0xec, 0x90, 0x76, 0x82, 0xa7,
	0xd4, 0x4e, 0x98, 0x21, 0x83, 0x4b, 0x3c, 0xc0, 0x12, 0xac, 0x28, 0xad, 0xbf, 0x18, 0x50, 0xe9,
	0xe7, 0xd0, 0xeb, 0x78, 0x62, 0x38, 0x13, 0x63, 0x3d, 0x56, 0x61, 0x9e, 0xbb, 0x27, 0x1e, 0x61,
	0x6d, 0x9b, 0xd1, 0xf0, 0x29, 0x0d, 0x6d, 0xc9, 0x32, 0x2d, 0x59, 0x5e, 0xd1, 0xa8, 0x86, 0xc4,
	0x6c, 0x08, 0xfe, 0xcb, 0x60, 0xca, 0xfc, 0xd1, 0x7a, 0xdb, 0xae, 0xa3, 0x3c, 0x91, 0xc1, 0x2a,
	0xdb, 0x94, 0x92, 0x3b, 0x0e, 0xb3, 0x4e, 0x61, 0x61, 0xac, 0xec, 0x97, 0xb5, 0xf4, 0xdb, 0x30,
	0x4b, 0x05, 0xd0, 0xee, 0x50, 0x16, 0xd7, 0x85, 0x3c, 0x2e, 0x4a, 0xe0, 0x9e, 0x82, 0x59, 0xbf,
	0x31, 0xa0, 0x28, 0x02, 0xf9, 0x20, 0x0c, 0xba, 0x34, 0xe4, 0x67, 0xc2, 0x36, 0xcc, 0xfd, 0x99,
	0x2a, 0x32, 0x19, 0x2c, 0xd7, 0x22, 0x95, 0x9a, 0x41, 0xcf, 0xe7, 0xba, 0xb2, 0xa8, 0x0d, 0xba,
	0x0d, 0xd0, 0x71, 0x7d, 0xbb, 0x4d, 0x7c, 0x47, 0x17, 0x93, 0x22, 0xce, 0x77, 0x5c, 0x7f, 0x5b,
	0x02, 0x14, 0xda, 0x89, 0xd0, 0x99, 0x08, 0xed, 0x24, 0xd0, 0xe4, 0x79, 0x84, 0xce, 0x6a, 0x34,
	0x79, 0xae, 0xd0, 0xd6, 0x1f, 0x52, 0x90, 0x13, 0x72, 0xed, 0x51, 0x4e, 0xd0, 0x3b, 0x50, 0x3a,
	0x09, 0xc2, 0x0e, 0xe1, 0xf6, 0x53, 0x1a, 0x32, 0x37, 0xf0, 0xb5, 0x74, 0xb3, 0x0a, 0xfa, 0x48,
	0x01, 0x45, 0xe1, 0x39, 0x09, 0x49, 0xcb, 0xee, 0x12, 0xde, 0xd6, 0xca, 0xe6, 0x04, 0xe0, 0x80,
	0xf0, 0x36, 0xfa, 0x1a, 0xcc, 0xb5, 0x09, 0xb3, 0x1d, 0xea, 0x51, 0x2e, 0x9c, 0x40, 0xb9, 0x14,
	0x39, 0x87, 0x67, 0xdb, 0x84, 0x55, 0x15, 0xb4, 0x41, 0x39, 0xba, 0x07, 0x19, 0x46, 0x5b, 0x51,
	0x96, 0xe8, 0xfc, 0x8a, 0x24, 0x59, 0xdd, 0x11, 0x75, 0xa7, 0x41, 0x5b, 0x1d, 0xea, 0x73, 0x2c,
	0x09, 0xd1, 0x2a, 0xe4, 0xba, 0xda, 0x78, 0x52, 0x8d, 0xc2, 0x1a, 0xea, 0x1f, 0x8a, 0xcc, 0x8a,
	0x63, 0x9a, 0x4a, 0x15, 0x8a, 0x49, 0x2e, 0xe8, 0x1a, 0x4c, 0x33, 0xda, 0x12, 0x05, 0x4c, 0x85,
	0x63, 0x96, 0xd1, 0xd6, 0x8e, 0x23, 0xec, 0xe3, 0x50, 0xcf, 0x66, 0xbd, 0x93, 0x13, 0xf7, 0xb9,
	0xd6, 0x26, 0xef, 0x50, 0xaf, 0x21, 0x01, 0xd6, 0x27, 0x50, 0x92, 0x01, 0xf3, 0x98, 0x70, 0x1a,
	0x76, 0x48, 0x78, 0x8a, 0x16, 0x20, 0xd7, 0x74, 0x9a, 0xf6, 0x89, 0xeb, 0x29, 0xe7, 0xe5, 0xb7,
	0xa7, 0xf0, 0x4c, 0xd3, 0x69, 0x6e, 0xb9, 0x9e, 0x68, 0x11, 0x05, 0xb7, 0xd3, 0x0d, 0x42, 0xae,
	0xf0, 0x29, 0x8d, 0x07, 0x05, 0x14, 0x24, 0xf7, 0x0b, 0x90, 0x7f, 0x16, 0x31, 0xb3, 0xbe, 0x32,
	0xe0, 0xda, 0x46, 0xb7, 0x4b, 0x7d, 0x27, 0x52, 0x3d, 0xca, 0x9d, 0x64, 0x9d, 0x36, 0x26, 0xd7,
	0xe9, 0xd4, 0xe4, 0x3a, 0x9d, 0x1e, 0xac, 0xd3, 0xcb, 0x60, 0x3e, 0x93, 0x85, 0xc5, 0xf6, 0x03,
	0x87, 0xaa, 0x2c, 0xca, 0x48, 0x75, 0x4b, 0xcf, 0xe2, 0x82, 0x23, 0x53, 0xe8, 0x5d, 0x00, 0xe9,
	0xdf, 0x0e, 0xe5, 0x84, 0x95, 0xb3, 0xd2, 0x41, 0xa5, 0x41, 0x07, 0x61, 0x19, 0x01, 0x62, 0xc5,
	0xd0, 0x5a, 0x42, 0x21, 0xd9, 0x04, 0x0a, 0x6b, 0x57, 0x15, 0xf5, 0xa0, 0xe5, 0x70, 0x42, 0xef,
	0x0d, 0xb8, 0x3e, 0xac, 0xf6, 0x25, 0xd3, 0xce, 0xfa, 0x01, 0xe4, 0x1e, 0xd2, 0x33, 0x4c, 0xfc,
	0x16, 0x7d, 0xb5, 0x56, 0x68, 0x85, 0x30, 0x2f, 0x25, 0xdc, 0x0d, 0x9a, 0xc4, 0xdb, 0x14, 0xc5,
	0x61, 0xc7, 0x3f, 0x09, 0xd0, 0x3d, 0xc8, 0x4a, 0x9b, 0xe9, 0x66, 0x74, 0x33, 0xa1, 0xcb, 0x1e,
	0xf1, 0xdd, 0x13, 0xca, 0xf8, 0xb6, 0xac, 0x1b, 0x58, 0xd1, 0x89, 0xa6, 0xef, 0x09, 0x16, 0xb6,
	0x6a, 0xe7, 0xc2, 0xb2, 0xaa, 0xdc, 0xe6, 0xf1, 0x9c, 0x17, 0xf3, 0x16, 0xa6, 0x65, 0xd6, 0x6f,
	0x0d, 0xb8, 0xf9, 0x80, 0xf2, 0xa1, 0x7b, 0x5f, 0xcf, 0xe9, 0xef, 0x02, 0x9c, 0xd2, 0x33, 0x3b,
	0x14, 0xa6, 0x88, 0x1a, 0x96, 0xf6, 0x57, 0x64, 0x21, 0x9c, 0x3f, 0xd5, 0x2b, 0x26, 0xaa, 0x8c,
	0xe7, 0x76, 0x5c, 0x2e, 0xbd, 0x9f, 0xc5, 0x6a, 0x63, 0x7d, 0x6a, 0x40, 0x65, 0x9c, 0x60, 0xda,
	0x2d, 0xd7, 0x07, 0xdc, 0x92, 0x8d, 0x8b, 0xdf, 0x01, 0xdc, 0x50, 0x01, 0x97, 0xb4, 0x80, 0xeb,
	0x9f, 0x04, 0x51, 0xc3, 0x49, 0x9a, 0x6f, 0xd0, 0xd0, 0xf8, 0x2a, 0x1b, 0x05, 0x32, 0xeb, 0x17,
	0x06, 0xdc, 0xaa, 0xd2, 0xe3, 0x5e, 0x2b, 0x92, 0x26, 0x32, 0xfa, 0xeb, 0x19, 0xe9, 0x9b, 0x90,
	0x8f, 0x8d, 0x24, 0x53, 0x63, 0xd4, 0x46, 0xb9, 0xc8, 0x46, 0x56, 0x1d, 0x6e, 0x4f, 0x10, 0x41,
	0x9b, 0x63, 0x30, 0x45, 0x8c, 0x0b, 0x52, 0xc4, 0xfa, 0x34, 0x0d, 0x68, 0x74, 0x9a, 0xb9, 0x7c,
	0xa4, 0x25, 0x55, 0x4f, 0x4d, 0x56, 0x3d, 0x3d, 0xa8, 0xba, 0x9e, 0xc5, 0x32, 0xf1, 0x2c, 0x86,
	0x6e, 0x41, 0x9e, 0xbb, 0x1d, 0xca, 0x38, 0xe9, 0x74, 0xf5, 0x3c, 0xd7, 0x07, 0xa0, 0xb7, 0xa0,
	0xe0, 0xc9, 0x6b, 0x6d, 0x91, 0xae, 0x32, 0xa5, 0xf3, 0x18, 0x14, 0xe8, 0x90, 0x86, 0x1d, 0x74,
	0x0f, 0x0a, 0xae, 0xdf, 0xed, 0x71, 0x5b, 0x68, 0xc8, 0xca, 0x33, 0x63, 0xd5, 0x07, 0x49, 0x22,
	0xb6, 0x62, 0x18, 0x99, 0xeb, 0x75, 0xbd, 0x80, 0xa8, 0x30, 0x11, 0x93, 0x4e, 0x39, 0x27, 0x55,
	0x36, 0xb5, 0xca, 0xeb, 0xbb, 0x1a, 0x8e, 0x4b, 0x8a, 0x30, 0xda, 0xa3, 0x6f, 0x43, 0x51, 0xcf,
	0x47, 0x36, 0x3f, 0xeb, 0xd2, 0x72, 0x5e, 0x56, 0x85, 0x2b, 0x03, 0x13, 0xe2, 0xe1, 0x59, 0x97,
	0xc6, 0x63, 0x94, 0xd8, 0x88, 0x70, 0x55, 0x45, 0xad, 0x0c, 0x52, 0x7a, 0xbd, 0xb3, 0xde, 0x85,
	0xf9, 0x01, 0x3f, 0x9c, 0x1f, 0xdd, 0xd6, 0xbf, 0x52, 0x50, 0xde, 0x72, 0x7d, 0x97, 0xb5, 0xc7,
	0x78, 0x6f, 0xdc, 0x74, 0x13, 0x7b, 0x34, 0xf5, 0x0a, 0x1e, 0x7d, 0xf9, 0x71, 0x5c, 0x7b, 0x34,
	0x3b, 0xc1, 0xa3, 0xd3, 0x17, 0x78, 0x74, 0xe6, 0x22, 0x8f, 0xe6, 0x2e, 0xf4, 0xe8, 0x7b, 0x50,
	0x0c, 0x7a, 0xbc, 0x7f, 0x22, 0x3f, 0xf6, 0x44, 0x41, 0xd1, 0xc8, 0x23, 0xd6, 0x3a, 0xdc, 0x1c,
	0x63, 0xcb, 0x0b, 0x3c, 0xf0, 0x73, 0x5d, 0xa3, 0x07, 0xad, 0x37, 0xd0, 0xe7, 0x8c, 0xc1, 0x3e,
	0x37, 0xd0, 0x0b, 0x52, 0x93, 0x7b, 0x41, 0x7a, 0xe0, 0xb3, 0x28, 0xfe, 0x8a, 0xc9, 0x24, 0xbe,
	0x62, 0xac, 0x0f, 0x01, 0xfa, 0xa1, 0x29, 0x64, 0x3c, 0xee, 0x35, 0x4f, 0x29, 0xd7, 0x2e, 0xd7,
	0x3b, 0x01, 0xef, 0x86, 0xb4, 0x3f, 0x3e, 0xe8, 0x9d, 0xf5, 0x59, 0x0a, 0xe6, 0x86, 0x06, 0xed,
	0xcb, 0xa7, 0xfc, 0x2a, 0x80, 0x8e, 0x02, 0xff, 0x24, 0xd0, 0x61, 0xa5, 0x7b, 0xa2, 0x1c, 0x6f,
	0x64, 0x25, 0xcd, 0xbb, 0xd1, 0x52, 0xd0, 0xeb, 0x80, 0x12, 0xf4, 0xe9, 0x24, 0xfd, 0xa1, 0x0c,
	0x2c, 0x49, 0xcf, 0xa3, 0xe5, 0x60, 0xf7, 0xce, 0xbc, 0x54, 0xf7, 0x46, 0xeb, 0x50, 0x14, 0x23,
	0x50, 0x9c, 0xcb, 0xd9, 0x09, 0xb9, 0x5c, 0x68, 0x3a, 0xcd, 0xd8, 0x7a, 0x63, 0x6a, 0xc0, 0xf4,
	0xcb, 0xd5, 0x00, 0x6b, 0x05, 0xcc, 0xbe, 0x1d, 0x2f, 0x08, 0x18, 0x0e, 0x68, 0x33, 0xa4, 0x84,
	0x53, 0x69, 0x9d, 0xc8, 0xec, 0x83, 0x56, 0x34, 0x2e, 0x69, 0xc5, 0xd4, 0x45, 0x56, 0xb4, 0x3a,
	0x30, 0x3f, 0x70, 0xeb, 0x05, 0x5d, 0xf3, 0x65, 0x3e, 0x19, 0x46, 0x2a, 0x7a, 0x3e, 0xce, 0x7f,
	0x6b, 0x1b, 0xcc, 0x6a, 0x18, 0x74, 0x07, 0x54, 0x7c, 0xa5, 0xb6, 0x68, 0x1d, 0xc0, 0x95, 0x04,
	0xa7, 0x37, 0x20, 0xb6, 0xf5, 0x6f, 0x03, 0xf2, 0xb1, 0x8d, 0xce, 0x93, 0xea, 0x76, 0x64, 0x63,
	0x9f, 0x74, 0x22, 0x56, 0xca, 0xa4, 0x75, 0xd2, 0xa1, 0xe2, 0x32, 0x87, 0x70, 0x72, 0x4c, 0x98,
	0xa6, 0x50, 0x36, 0x28, 0x46, 0x40, 0x49, 0x54, 0x86, 0x99, 0xe8, 0x53, 0x45, 0x97, 0x48, 0xbd,
	0x45, 0x2b, 0x30, 0xd3, 0x0c, 0xbc, 0x5e, 0xc7, 0x8f, 0x26, 0x58, 0x33, 0x6a, 0x19, 0x02, 0x28,
	0xfd, 0x17, 0x11, 0xa0, 0x3b, 0x50, 0x74, 0x99, 0xdd, 0xf4, 0x7a, 0x8c, 0xd3, 0x90, 0x3a, 0x32,
	0x2e, 0x73, 0xb8, 0xe0, 0xb2, 0xcd, 0x08, 0x64, 0xfd, 0x3d, 0x05, 0xd0, 0x3f, 0x2a, 0xdf, 0x89,
	0xe4, 0xae, 0xaf, 0x57, 0x4e, 0x01, 0x76, 0x1c, 0x51, 0x6d, 0x35, 0x32, 0xa1, 0x19, 0x28, 0x90,
	0x94, 0x1a, 0x41, 0x46, 0xf6, 0xb2, 0xb4, 0xb4, 0xae, 0x5c, 0x8b, 0x02, 0xde, 0x0c, 0x3c, 0x4f,
	0x25, 0x86, 0x9a, 0xcc, 0xfa, 0x00, 0x61, 0x0c, 0xcd, 0xd2, 0xa3, 0x7e, 0x8b, 0xb7, 0x65, 0xca,
	0x65, 0x71, 0x51, 0x01, 0x77, 0x25, 0x4c, 0x18, 0xc3, 0xa1, 0x4d, 0xb7, 0x43, 0x3c, 0xa9, 0x41,
	0x16, 0x47, 0x5b, 0x71, 0xe1, 0x89, 0x47, 0x5a, 0xb2, 0xf0, 0xcf, 0x62, 0xb9, 0x96, 0x15, 0xcf,
	0xa3, 0x1d, 0x55, 0xec, 0xf3, 0x58, 0x6d, 0x84, 0xec, 0x0e, 0x3d, 0x21, 0x3d, 0x8f, 0xdb, 0x4f,
	0x89, 0x27, 0xbb, 0x6d, 0x11, 0x83, 0x06, 0x3d, 0x22, 0x1e, 0xba, 0x0b, 0x25, 0x97, 0xd9, 0xdd,
	0xd0, 0xed, 0x90, 0xf0, 0x4c, 0x16, 0x52, 0x90, 0xd6, 0x2a, 0xba, 0xec, 0x40, 0x01, 0xf5, 0x2b,
	0x93, 0xcb, 0x6c, 0x12, 0x86, 0xe4, 0xac, 0x5c, 0x90, 0xf8, 0x19, 0x97, 0x6d, 0x88, 0xad, 0xf5,
	0xab, 0x34, 0xe4, 0xe3, 0x9c, 0x7b, 0xc5, 0x61, 0xee, 0x76, 0x94, 0xce, 0x89, 0xc0, 0x50, 0xd9,
	0x2b, 0xed, 0x1b, 0x67, 0xbb, 0xb4, 0x72, 0x26, 0xf9, 0x1d, 0x21, 0x6f, 0x96, 0xf3, 0x82, 0xa2,
	0x97, 0xd3, 0xc2, 0x65, 0x62, 0x65, 0x01, 0xf2, 0x2e, 0xb3, 0x7b, 0xbe, 0xfb, 0xa4, 0x47, 0x75,
	0xa0, 0xe4, 0x5c, 0x76, 0x24, 0xf7, 0xe8, 0x3d, 0x28, 0x74, 0x49, 0xc8, 0x68, 0xa8, 0xea, 0xc6,
	0x4c, 0xb2, 0xbe, 0x1d, 0x48, 0x84, 0x64, 0x06, 0xdd, 0x78, 0x8d, 0x36, 0xa1, 0x18, 0xf0, 0x36,
	0x0d, 0xed, 0x2e, 0x09, 0x49, 0x27, 0x6a, 0xbd, 0x4b, 0x43, 0xb5, 0x69, 0x75, 0x5f, 0xd0, 0x1c,
	0x48, 0x92, 0x9a, 0xcf, 0xc3, 0x33, 0x5c, 0x08, 0xfa, 0x90, 0xca, 0xf7, 0xc0, 0x1c, 0x26, 0x10,
	0x33, 0x42, 0xf4, 0x35, 0x94, 0xc7, 0x62, 0x29, 0x3c, 0xfe, 0x94, 0x78, 0xbd, 0x28, 0x22, 0xd5,
	0xe6, 0x83, 0xd4, 0x77, 0x0c, 0xeb, 0x9f, 0x06, 0x40, 0x5f, 0xbe, 0x84, 0x1a, 0xd2, 0x80, 0xea,
	0x43, 0x6c, 0x40, 0x0d, 0x69, 0x41, 0xad, 0x86, 0x34, 0xe1, 0x03, 0x98, 0xd5, 0x47, 0xb4, 0x1e,
	0x6a, 0xfa, 0xb7, 0x86, 0x75, 0xd7, 0xcb, 0xa4, 0x26, 0xc5, 0x6e, 0x02, 0x54, 0xf9, 0x3e, 0x5c,
	0x19, 0x21, 0xb9, 0x94, 0x2e, 0xfb, 0x70, 0xe3, 0x01, 0xe5, 0xd2, 0x72, 0x07, 0x61, 0xd0, 0x0a,
	0x29, 0x63, 0xaf, 0x57, 0x22, 0xbf, 0x4a, 0x41, 0x79, 0x94, 0xe3, 0x9b, 0xa8, 0xf0, 0xef, 0x40,
	0xc9, 0x09, 0x9a, 0xbd, 0x0e, 0xf5, 0xb9, 0xad, 0x1e, 0x7e, 0xd4, 0x37, 0xfb, 0x6c, 0x04, 0xdd,
	0x94, 0x0f, 0x40, 0x1f, 0x40, 0x56, 0x70, 0x8d, 0x22, 0xf9, 0xae, 0xb2, 0xe9, 0x24, 0x91, 0x56,
	0x1b, 0x82, 0x16, 0xab, 0x23, 0x22, 0x9f, 0x45, 0xb8, 0xca, 0x7e, 0x4a, 0xd5, 0xdb, 0x6d, 0x0e,
	0x83, 0xcb, 0x8e, 0x34, 0x04, 0x2d, 0x83, 0xe9, 0x11, 0xc6, 0x35, 0x89, 0x2d, 0x66, 0x46, 0x3d,
	0xf1, 0x97, 0x04, 0x5c, 0xd1, 0x1d, 0xba, 0x1d, 0x2a, 0x66, 0x27, 0xb6, 0xae, 0x1e, 0x7d, 0xd4,
	0x00, 0x39, 0xcd, 0xd6, 0x0f, 0x08, 0x6f, 0x5b, 0x47, 0x90, 0x95, 0x77, 0xa2, 0x02, 0xcc, 0x1c,
	0xd4, 0xea, 0xd5, 0x9d, 0xfa, 0x03, 0x73, 0x4a, 0x6c, 0xf0, 0x51, 0xbd, 0x2e, 0x36, 0x06, 0x9a,
	0x85, 0xfc, 0xe6, 0xfe, 0xde, 0xc1, 0x6e, 0xed, 0xb0, 0x56, 0x35, 0x53, 0x08, 0x60, 0x7a, 0x6b,
	0x63, 0x67, 0xb7, 0x56, 0x35, 0xd3, 0xa8, 0x08, 0xb9, 0xfa, 0xfe, 0xe1, 0xd6, 0xfe, 0x51, 0xbd,
	0x6a, 0x66, 0x50, 0x1e, 0xb2, 0x35, 0x8c, 0xf7, 0xb1, 0x99, 0xb5, 0xfe, 0x66, 0xc0, 0x82, 0x50,
	0x52, 0x3e, 0x9d, 0x34, 0x78, 0x10, 0x92, 0x16, 0x15, 0xf7, 0xfd, 0x9f, 0x7a, 0xba, 0x1c, 0x9a,
	0x83, 0x67, 0x34, 0xb4, 0x8f, 0x83, 0x9e, 0xef, 0xe8, 0x79, 0x11, 0x24, 0xe8, 0xbe, 0x80, 0x08,
	0x82, 0x5e, 0xb7, 0x1b, 0x13, 0xa8, 0xa7, 0x37, 0x90, 0x20, 0x49, 0x60, 0x71, 0xb8, 0x35, 0x5e,
	0x81, 0x37, 0x11, 0x3c, 0x09, 0x77, 0xa4, 0x07, 0xdc, 0xf1, 0x5d, 0xb0, 0xf6, 0x48, 0x78, 0x7a,
	0x40, 0x42, 0xee, 0x8a, 0xe6, 0xa1, 0x5c, 0xa8, 0x46, 0x6f, 0x1a, 0x0f, 0xa2, 0x89, 0xe3, 0xc6,
	0xc0, 0xf1, 0x63, 0x78, 0xfb, 0xdc, 0xe3, 0x6f, 0x62, 0x46, 0x78, 0x04, 0x8b, 0xe2, 0x0e, 0x69,
	0xf6, 0xf1, 0xe2, 0xbd, 0x5a, 0xaa, 0xfe, 0x04, 0xde, 0x9a, 0xc8, 0xf7, 0x0d, 0xc8, 0xbd, 0xf2,
	0x7b, 0x03, 0xf2, 0xf1, 0x4b, 0x94, 0x88, 0xf0, 0xc6, 0xd1, 0xe6, 0x66, 0xad, 0xd1, 0x30, 0xa7,
	0xd0, 0x15, 0x98, 0x3d, 0xaa, 0x3f, 0xac, 0xef, 0x3f, 0xae, 0xdb, 0x2a, 0x80, 0x0d, 0x74, 0x0d,
	0xae, 0xec, 0xd4, 0x1f, 0x6d, 0xec, 0xee, 0x54, 0xed, 0x0d, 0xfc, 0xe0, 0x68, 0xaf, 0x56, 0x3f,
	0x6c, 0x98, 0x29, 0x34, 0x0f, 0x73, 0x8d, 0xed, 0x0d, 0x5c, 0xb5, 0xeb, 0xfb, 0x87, 0xb6, 0x8a,
	0xfb, 0x82, 0x00, 0xee, 0xd4, 0xab, 0xb5, 0x8f, 0x12, 0xc0, 0x22, 0xba, 0x0a, 0xe6, 0xe3, 0x7d,
	0xfc, 0xb0, 0x86, 0x13, 0xd0, 0x59, 0x74, 0x03, 0xe6, 0xfb, 0xe7, 0x1b, 0x9b, 0xdb, 0xb5, 0xea,
	0x91, 0xc8, 0xa4, 0xd2, 0xca, 0xb7, 0xa0, 0x90, 0xf8, 0x20, 0x16, 0xa9, 0x54, 0xa5, 0x1e, 0x27,
	0xe6, 0x14, 0xca, 0x41, 0xe6, 0x3e, 0x61, 0xd4, 0x34, 0xc4, 0x6a, 0xab, 0xe7, 0x79, 0x66, 0x6a,
	0x65, 0x5d, 0xb7, 0x61, 0x49, 0x5b, 0x80, 0x19, 0x2d, 0xbd, 0x39, 0x25, 0x92, 0x75, 0xeb, 0x68,
	0x77, 0xd7, 0x3e, 0xac, 0x7d, 0x74, 0x68, 0x1a, 0x22, 0x59, 0x37, 0x8f, 0x1a, 0x87, 0xfb, 0x7b,
	0x66, 0x6a, 0x65, 0x2b, 0xea, 0x13, 0xf2, 0x14, 0x82, 0x52, 0xa4, 0xf3, 0xc1, 0x06, 0x6e, 0xd4,
	0xb0, 0x39, 0x25, 0x60, 0xd5, 0xda, 0xd6, 0xc6, 0xd1, 0xee, 0x61, 0x04, 0x33, 0x90, 0x09, 0xc5,
	0xfd, 0xc3, 0xed, 0x1a, 0x8e, 0x20, 0xa9, 0xb5, 0xbf, 0xe6, 0xa0, 0x20, 0xbe, 0x10, 0x1b, 0x34,
	0x7c, 0xea, 0x36, 0x29, 0xfa, 0x18, 0xe6, 0xc7, 0xfc, 0xea, 0x81, 0x46, 0x7e, 0x3c, 0x19, 0xfe,
	0x89, 0xa1, 0x72, 0xe7, 0x1c, 0x0a, 0xed, 0xf1, 0x8f, 0x61, 0x7e, 0xcc, 0x3b, 0x7f, 0xc4, 0x7b,
	0xf2, 0xcf, 0x17, 0x11, 0xef, 0xf3, 0x7e, 0x24, 0xb8, 0x0f, 0x85, 0xc4, 0xdc, 0x8f, 0xa2, 0x1f,
	0xae, 0x46, 0x3e, 0x40, 0x2a, 0x37, 0xc7, 0x60, 0x34, 0x8f, 0x0f, 0x21, 0x1f, 0x8f, 0xe0, 0x48,
	0xff, 0x1c, 0x32, 0x3c, 0xdd, 0x57, 0x6e, 0x8c, 0xc0, 0xf5, 0xe9, 0x1f, 0x82, 0x39, 0xdc, 0x09,
	0xd0, 0xed, 0x49, 0x1d, 0x42, 0xf1, 0x5a, 0x3c, 0xbf, 0x81, 0xa0, 0x87, 0x50, 0x1a, 0x7c, 0x9c,
	0x45, 0xfa, 0x79, 0x7e, 0xec, 0x4b, 0x75, 0xe5, 0xd6, 0x78, 0xa4, 0x66, 0xf6, 0x63, 0xb8, 0x3e,
	0xfa, 0xac, 0xa8, 0xea, 0x6b, 0x2c, 0xc6, 0xf8, 0xd7, 0xd0, 0xca, 0xd2, 0x64, 0x02, 0xcd, 0xfc,
	0xa7, 0x70, 0x6d, 0xec, 0x3b, 0x1d, 0xd2, 0x73, 0xc7, 0x79, 0xef, 0x88, 0x95, 0xb7, 0xcf, 0xa5,
	0xd1, 0x37, 0xfc, 0x08, 0xae, 0x8f, 0x3c, 0x5a, 0x88, 0xce, 0xcc, 0x90, 0xb6, 0xe2, 0xa4, 0xe7,
	0xa1, 0xca, 0x5b, 0x13, 0xf1, 0x9a, 0xf5, 0x27, 0x70, 0x75, 0x5c, 0x77, 0x40, 0x77, 0xfa, 0xee,
	0x99, 0xd0, 0xfa, 0x2a, 0xd6, 0x79, 0x24, 0x9a, 0x7d, 0x08, 0x0b, 0xe7, 0xd4, 0x71, 0xb4, 0xac,
	0x58, 0x5c, 0xdc, 0x29, 0x2a, 0xdf, 0x78, 0x09, 0x4a, 0x7d, 0xe7, 0x09, 0xdc, 0x98, 0x50, 0x7f,
	0xd1, 0xdd, 0x3e, 0x97, 0xc9, 0x65, 0xbf, 0xf2, 0xce, 0x05, 0x54, 0xea, 0x9e, 0xb5, 0x5f, 0x1b,
	0x30, 0xab, 0x52, 0x3e, 0x2a, 0x20, 0xef, 0x43, 0x2e, 0x7a, 0x22, 0x40, 0xe3, 0x7f, 0xe3, 0xac,
	0x5c, 0x1f, 0x06, 0x6b, 0xa1, 0x1f, 0x80, 0x39, 0xe2, 0xdc, 0x89, 0xbf, 0x40, 0xc7, 0x89, 0x3c,
	0xea, 0xd0, 0xfb, 0x4b, 0x5f, 0xfc, 0x29, 0x67, 0xfc, 0xe3, 0xcb, 0x45, 0xe3, 0xf3, 0x2f, 0x17,
	0x8d, 0xff, 0x7e, 0xb9, 0x68, 0xfc, 0xf2, 0xc5, 0xe2, 0xd4, 0xef, 0x5e, 0x2c, 0x4e, 0x7d, 0xfe,
	0x62, 0x71, 0xea, 0x8b, 0x17, 0x8b, 0x53, 0xc7, 0xd3, 0xf2, 0xef, 0x0c, 0xeb, 0xff, 0x0b, 0x00,
	0x00, 0xff, 0xff, 0x6b, 0x54, 0x56, 0xdd, 0x09, 0x21, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MetaServiceClient is the client API for MetaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MetaServiceClient interface {
	// Maintains heartbeat from worker nodes(such as writers, compactors) to meta
	// service.
	WorkerNodeHeartbeat(ctx context.Context, in *WorkerNodeHeartbeatRequest, opts ...grpc.CallOption) (*WorkerNodeHeartbeatResponse, error)
	// Maintains heartbeat from reader nodes to meta service.
	ReaderNodeHeartbeat(ctx context.Context, in *ReaderNodeHeartbeatRequest, opts ...grpc.CallOption) (*ReaderNodeHeartbeatResponse, error)
	// CreateIndex creates a new index
	CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error)
	// DropIndex removes an existing index
	DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error)
	// GetIndexProgress retrieves the current progress of an index build
	GetIndexProgress(ctx context.Context, in *GetIndexProgressRequest, opts ...grpc.CallOption) (*GetIndexProgressResponse, error)
	AppendFragMeta(ctx context.Context, in *AppendFragMetaRequest, opts ...grpc.CallOption) (*AppendFragMetaResponse, error)
	// Get shard local cache information
	GetShardLocalCacheInfo(ctx context.Context, in *GetShardLocalCacheRequest, opts ...grpc.CallOption) (*GetShardLocalCacheResponse, error)
	// Debug usage: get shard manifest from meta service writer
	DebugGetShardManifest(ctx context.Context, in *DebugGetShardManifestRequest, opts ...grpc.CallOption) (*DebugGetShardManifestResponse, error)
	FinishCompactFragments(ctx context.Context, in *FinishCompactFragRequest, opts ...grpc.CallOption) (*FinishCompactFragResponse, error)
	// Returns the cloud storage path where TiDB should upload a baseline shard
	// for the specified [table_info, index_info, key_range].
	GetImportStoragePath(ctx context.Context, in *GetImportStoragePathRequest, opts ...grpc.CallOption) (*GetImportStoragePathResponse, error)
	// Called by Import DXF to notify Meta Service after a partitions for
	// the given index are uploaded.
	MarkPartitionUploadFinished(ctx context.Context, in *MarkPartitionUploadFinishedRequest, opts ...grpc.CallOption) (*MarkPartitionUploadFinishedResponse, error)
	// Called to notify Meta Service that the whole table/index upload is
	// finished.
	MarkTableUploadFinished(ctx context.Context, in *MarkTableUploadFinishedRequest, opts ...grpc.CallOption) (*MarkTableUploadFinishedResponse, error)
}

type metaServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetaServiceClient(cc *grpc.ClientConn) MetaServiceClient {
	return &metaServiceClient{cc}
}

func (c *metaServiceClient) WorkerNodeHeartbeat(ctx context.Context, in *WorkerNodeHeartbeatRequest, opts ...grpc.CallOption) (*WorkerNodeHeartbeatResponse, error) {
	out := new(WorkerNodeHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/WorkerNodeHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) ReaderNodeHeartbeat(ctx context.Context, in *ReaderNodeHeartbeatRequest, opts ...grpc.CallOption) (*ReaderNodeHeartbeatResponse, error) {
	out := new(ReaderNodeHeartbeatResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/ReaderNodeHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error) {
	out := new(CreateIndexResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/CreateIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error) {
	out := new(DropIndexResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/DropIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetIndexProgress(ctx context.Context, in *GetIndexProgressRequest, opts ...grpc.CallOption) (*GetIndexProgressResponse, error) {
	out := new(GetIndexProgressResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/GetIndexProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) AppendFragMeta(ctx context.Context, in *AppendFragMetaRequest, opts ...grpc.CallOption) (*AppendFragMetaResponse, error) {
	out := new(AppendFragMetaResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/AppendFragMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetShardLocalCacheInfo(ctx context.Context, in *GetShardLocalCacheRequest, opts ...grpc.CallOption) (*GetShardLocalCacheResponse, error) {
	out := new(GetShardLocalCacheResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/GetShardLocalCacheInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) DebugGetShardManifest(ctx context.Context, in *DebugGetShardManifestRequest, opts ...grpc.CallOption) (*DebugGetShardManifestResponse, error) {
	out := new(DebugGetShardManifestResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/DebugGetShardManifest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) FinishCompactFragments(ctx context.Context, in *FinishCompactFragRequest, opts ...grpc.CallOption) (*FinishCompactFragResponse, error) {
	out := new(FinishCompactFragResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/FinishCompactFragments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) GetImportStoragePath(ctx context.Context, in *GetImportStoragePathRequest, opts ...grpc.CallOption) (*GetImportStoragePathResponse, error) {
	out := new(GetImportStoragePathResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/GetImportStoragePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) MarkPartitionUploadFinished(ctx context.Context, in *MarkPartitionUploadFinishedRequest, opts ...grpc.CallOption) (*MarkPartitionUploadFinishedResponse, error) {
	out := new(MarkPartitionUploadFinishedResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/MarkPartitionUploadFinished", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaServiceClient) MarkTableUploadFinished(ctx context.Context, in *MarkTableUploadFinishedRequest, opts ...grpc.CallOption) (*MarkTableUploadFinishedResponse, error) {
	out := new(MarkTableUploadFinishedResponse)
	err := c.cc.Invoke(ctx, "/tici.MetaService/MarkTableUploadFinished", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetaServiceServer is the server API for MetaService service.
type MetaServiceServer interface {
	// Maintains heartbeat from worker nodes(such as writers, compactors) to meta
	// service.
	WorkerNodeHeartbeat(context.Context, *WorkerNodeHeartbeatRequest) (*WorkerNodeHeartbeatResponse, error)
	// Maintains heartbeat from reader nodes to meta service.
	ReaderNodeHeartbeat(context.Context, *ReaderNodeHeartbeatRequest) (*ReaderNodeHeartbeatResponse, error)
	// CreateIndex creates a new index
	CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error)
	// DropIndex removes an existing index
	DropIndex(context.Context, *DropIndexRequest) (*DropIndexResponse, error)
	// GetIndexProgress retrieves the current progress of an index build
	GetIndexProgress(context.Context, *GetIndexProgressRequest) (*GetIndexProgressResponse, error)
	AppendFragMeta(context.Context, *AppendFragMetaRequest) (*AppendFragMetaResponse, error)
	// Get shard local cache information
	GetShardLocalCacheInfo(context.Context, *GetShardLocalCacheRequest) (*GetShardLocalCacheResponse, error)
	// Debug usage: get shard manifest from meta service writer
	DebugGetShardManifest(context.Context, *DebugGetShardManifestRequest) (*DebugGetShardManifestResponse, error)
	FinishCompactFragments(context.Context, *FinishCompactFragRequest) (*FinishCompactFragResponse, error)
	// Returns the cloud storage path where TiDB should upload a baseline shard
	// for the specified [table_info, index_info, key_range].
	GetImportStoragePath(context.Context, *GetImportStoragePathRequest) (*GetImportStoragePathResponse, error)
	// Called by Import DXF to notify Meta Service after a partitions for
	// the given index are uploaded.
	MarkPartitionUploadFinished(context.Context, *MarkPartitionUploadFinishedRequest) (*MarkPartitionUploadFinishedResponse, error)
	// Called to notify Meta Service that the whole table/index upload is
	// finished.
	MarkTableUploadFinished(context.Context, *MarkTableUploadFinishedRequest) (*MarkTableUploadFinishedResponse, error)
}

// UnimplementedMetaServiceServer can be embedded to have forward compatible implementations.
type UnimplementedMetaServiceServer struct {
}

func (*UnimplementedMetaServiceServer) WorkerNodeHeartbeat(ctx context.Context, req *WorkerNodeHeartbeatRequest) (*WorkerNodeHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkerNodeHeartbeat not implemented")
}
func (*UnimplementedMetaServiceServer) ReaderNodeHeartbeat(ctx context.Context, req *ReaderNodeHeartbeatRequest) (*ReaderNodeHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReaderNodeHeartbeat not implemented")
}
func (*UnimplementedMetaServiceServer) CreateIndex(ctx context.Context, req *CreateIndexRequest) (*CreateIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIndex not implemented")
}
func (*UnimplementedMetaServiceServer) DropIndex(ctx context.Context, req *DropIndexRequest) (*DropIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropIndex not implemented")
}
func (*UnimplementedMetaServiceServer) GetIndexProgress(ctx context.Context, req *GetIndexProgressRequest) (*GetIndexProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndexProgress not implemented")
}
func (*UnimplementedMetaServiceServer) AppendFragMeta(ctx context.Context, req *AppendFragMetaRequest) (*AppendFragMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendFragMeta not implemented")
}
func (*UnimplementedMetaServiceServer) GetShardLocalCacheInfo(ctx context.Context, req *GetShardLocalCacheRequest) (*GetShardLocalCacheResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShardLocalCacheInfo not implemented")
}
func (*UnimplementedMetaServiceServer) DebugGetShardManifest(ctx context.Context, req *DebugGetShardManifestRequest) (*DebugGetShardManifestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DebugGetShardManifest not implemented")
}
func (*UnimplementedMetaServiceServer) FinishCompactFragments(ctx context.Context, req *FinishCompactFragRequest) (*FinishCompactFragResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishCompactFragments not implemented")
}
func (*UnimplementedMetaServiceServer) GetImportStoragePath(ctx context.Context, req *GetImportStoragePathRequest) (*GetImportStoragePathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImportStoragePath not implemented")
}
func (*UnimplementedMetaServiceServer) MarkPartitionUploadFinished(ctx context.Context, req *MarkPartitionUploadFinishedRequest) (*MarkPartitionUploadFinishedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkPartitionUploadFinished not implemented")
}
func (*UnimplementedMetaServiceServer) MarkTableUploadFinished(ctx context.Context, req *MarkTableUploadFinishedRequest) (*MarkTableUploadFinishedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkTableUploadFinished not implemented")
}

func RegisterMetaServiceServer(s *grpc.Server, srv MetaServiceServer) {
	s.RegisterService(&_MetaService_serviceDesc, srv)
}

func _MetaService_WorkerNodeHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerNodeHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).WorkerNodeHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/WorkerNodeHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).WorkerNodeHeartbeat(ctx, req.(*WorkerNodeHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_ReaderNodeHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReaderNodeHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).ReaderNodeHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/ReaderNodeHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).ReaderNodeHeartbeat(ctx, req.(*ReaderNodeHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_CreateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).CreateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/CreateIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).CreateIndex(ctx, req.(*CreateIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_DropIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).DropIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/DropIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).DropIndex(ctx, req.(*DropIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_GetIndexProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).GetIndexProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/GetIndexProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).GetIndexProgress(ctx, req.(*GetIndexProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_AppendFragMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendFragMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).AppendFragMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/AppendFragMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).AppendFragMeta(ctx, req.(*AppendFragMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_GetShardLocalCacheInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetShardLocalCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).GetShardLocalCacheInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/GetShardLocalCacheInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).GetShardLocalCacheInfo(ctx, req.(*GetShardLocalCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_DebugGetShardManifest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugGetShardManifestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).DebugGetShardManifest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/DebugGetShardManifest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).DebugGetShardManifest(ctx, req.(*DebugGetShardManifestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_FinishCompactFragments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishCompactFragRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).FinishCompactFragments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/FinishCompactFragments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).FinishCompactFragments(ctx, req.(*FinishCompactFragRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_GetImportStoragePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImportStoragePathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).GetImportStoragePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/GetImportStoragePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).GetImportStoragePath(ctx, req.(*GetImportStoragePathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_MarkPartitionUploadFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkPartitionUploadFinishedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).MarkPartitionUploadFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/MarkPartitionUploadFinished",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).MarkPartitionUploadFinished(ctx, req.(*MarkPartitionUploadFinishedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaService_MarkTableUploadFinished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkTableUploadFinishedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaServiceServer).MarkTableUploadFinished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.MetaService/MarkTableUploadFinished",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaServiceServer).MarkTableUploadFinished(ctx, req.(*MarkTableUploadFinishedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetaService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tici.MetaService",
	HandlerType: (*MetaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WorkerNodeHeartbeat",
			Handler:    _MetaService_WorkerNodeHeartbeat_Handler,
		},
		{
			MethodName: "ReaderNodeHeartbeat",
			Handler:    _MetaService_ReaderNodeHeartbeat_Handler,
		},
		{
			MethodName: "CreateIndex",
			Handler:    _MetaService_CreateIndex_Handler,
		},
		{
			MethodName: "DropIndex",
			Handler:    _MetaService_DropIndex_Handler,
		},
		{
			MethodName: "GetIndexProgress",
			Handler:    _MetaService_GetIndexProgress_Handler,
		},
		{
			MethodName: "AppendFragMeta",
			Handler:    _MetaService_AppendFragMeta_Handler,
		},
		{
			MethodName: "GetShardLocalCacheInfo",
			Handler:    _MetaService_GetShardLocalCacheInfo_Handler,
		},
		{
			MethodName: "DebugGetShardManifest",
			Handler:    _MetaService_DebugGetShardManifest_Handler,
		},
		{
			MethodName: "FinishCompactFragments",
			Handler:    _MetaService_FinishCompactFragments_Handler,
		},
		{
			MethodName: "GetImportStoragePath",
			Handler:    _MetaService_GetImportStoragePath_Handler,
		},
		{
			MethodName: "MarkPartitionUploadFinished",
			Handler:    _MetaService_MarkPartitionUploadFinished_Handler,
		},
		{
			MethodName: "MarkTableUploadFinished",
			Handler:    _MetaService_MarkTableUploadFinished_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tici.proto",
}

// WorkerServiceClient is the client API for WorkerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkerServiceClient interface {
	// Add shard for an index
	AddShard(ctx context.Context, in *AddShardRequest, opts ...grpc.CallOption) (*AddShardResponse, error)
	// Compact a shard
	CompactFragments(ctx context.Context, in *CompactFragRequest, opts ...grpc.CallOption) (*CompactFragResponse, error)
}

type workerServiceClient struct {
	cc *grpc.ClientConn
}

func NewWorkerServiceClient(cc *grpc.ClientConn) WorkerServiceClient {
	return &workerServiceClient{cc}
}

func (c *workerServiceClient) AddShard(ctx context.Context, in *AddShardRequest, opts ...grpc.CallOption) (*AddShardResponse, error) {
	out := new(AddShardResponse)
	err := c.cc.Invoke(ctx, "/tici.WorkerService/AddShard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerServiceClient) CompactFragments(ctx context.Context, in *CompactFragRequest, opts ...grpc.CallOption) (*CompactFragResponse, error) {
	out := new(CompactFragResponse)
	err := c.cc.Invoke(ctx, "/tici.WorkerService/CompactFragments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServiceServer is the server API for WorkerService service.
type WorkerServiceServer interface {
	// Add shard for an index
	AddShard(context.Context, *AddShardRequest) (*AddShardResponse, error)
	// Compact a shard
	CompactFragments(context.Context, *CompactFragRequest) (*CompactFragResponse, error)
}

// UnimplementedWorkerServiceServer can be embedded to have forward compatible implementations.
type UnimplementedWorkerServiceServer struct {
}

func (*UnimplementedWorkerServiceServer) AddShard(ctx context.Context, req *AddShardRequest) (*AddShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddShard not implemented")
}
func (*UnimplementedWorkerServiceServer) CompactFragments(ctx context.Context, req *CompactFragRequest) (*CompactFragResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompactFragments not implemented")
}

func RegisterWorkerServiceServer(s *grpc.Server, srv WorkerServiceServer) {
	s.RegisterService(&_WorkerService_serviceDesc, srv)
}

func _WorkerService_AddShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).AddShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.WorkerService/AddShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).AddShard(ctx, req.(*AddShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerService_CompactFragments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompactFragRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).CompactFragments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tici.WorkerService/CompactFragments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).CompactFragments(ctx, req.(*CompactFragRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WorkerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tici.WorkerService",
	HandlerType: (*WorkerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddShard",
			Handler:    _WorkerService_AddShard_Handler,
		},
		{
			MethodName: "CompactFragments",
			Handler:    _WorkerService_CompactFragments_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tici.proto",
}

func (m *WorkerNodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoryUsage != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.MemoryUsage))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuUsage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUsage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ReaderNodeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReaderNodeStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReaderNodeStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheHitRate != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CacheHitRate))))
		i--
		dAtA[i] = 0x21
	}
	if m.RequestsInCycle != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.RequestsInCycle))
		i--
		dAtA[i] = 0x18
	}
	if m.MemoryUsage != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.MemoryUsage))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuUsage != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUsage))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeShardStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeShardStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeShardStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x38
	}
	if m.Epoch != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x30
	}
	if m.ShardId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x28
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x20
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeCompactionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeCompactionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeCompactionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Req != nil {
		{
			size, err := m.Req.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeHeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Compactions) > 0 {
		for iNdEx := len(m.Compactions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Compactions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerNodeHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerNodeHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerNodeHeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToRemoveShards) > 0 {
		dAtA4 := make([]byte, len(m.ToRemoveShards)*10)
		var j3 int
		for _, num := range m.ToRemoveShards {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTici(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ToAddShards) > 0 {
		for iNdEx := len(m.ToAddShards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToAddShards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReaderNodeHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReaderNodeHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReaderNodeHeartbeatRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CachedShardIds) > 0 {
		dAtA6 := make([]byte, len(m.CachedShardIds)*10)
		var j5 int
		for _, num := range m.CachedShardIds {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTici(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TiflashServerAddr) > 0 {
		i -= len(m.TiflashServerAddr)
		copy(dAtA[i:], m.TiflashServerAddr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.TiflashServerAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReaderNodeHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReaderNodeHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReaderNodeHeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FragProperty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FragProperty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FragProperty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxHandle) > 0 {
		i -= len(m.MaxHandle)
		copy(dAtA[i:], m.MaxHandle)
		i = encodeVarintTici(dAtA, i, uint64(len(m.MaxHandle)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MidHandle) > 0 {
		i -= len(m.MidHandle)
		copy(dAtA[i:], m.MidHandle)
		i = encodeVarintTici(dAtA, i, uint64(len(m.MidHandle)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MinHandle) > 0 {
		i -= len(m.MinHandle)
		copy(dAtA[i:], m.MinHandle)
		i = encodeVarintTici(dAtA, i, uint64(len(m.MinHandle)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Size_ != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FragMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FragMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FragMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Property != nil {
		{
			size, err := m.Property.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Segs) > 0 {
		for iNdEx := len(m.Segs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Segs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.HasDeletedSet {
		i--
		if m.HasDeletedSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.FragPath) > 0 {
		i -= len(m.FragPath)
		copy(dAtA[i:], m.FragPath)
		i = encodeVarintTici(dAtA, i, uint64(len(m.FragPath)))
		i--
		dAtA[i] = 0x12
	}
	if m.FormatVersion != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.FormatVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FragMeta_IndexSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FragMeta_IndexSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FragMeta_IndexSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelSuffix) > 0 {
		i -= len(m.DelSuffix)
		copy(dAtA[i:], m.DelSuffix)
		i = encodeVarintTici(dAtA, i, uint64(len(m.DelSuffix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SegId) > 0 {
		i -= len(m.SegId)
		copy(dAtA[i:], m.SegId)
		i = encodeVarintTici(dAtA, i, uint64(len(m.SegId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardWatermark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardWatermark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardWatermark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Watermark != nil {
		{
			size := m.Watermark.Size()
			i -= size
			if _, err := m.Watermark.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShardWatermark_CdcFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardWatermark_CdcFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CdcFile)
	copy(dAtA[i:], m.CdcFile)
	i = encodeVarintTici(dAtA, i, uint64(len(m.CdcFile)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *ShardWatermark_ImportFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardWatermark_ImportFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ImportFile)
	copy(dAtA[i:], m.ImportFile)
	i = encodeVarintTici(dAtA, i, uint64(len(m.ImportFile)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *AppendFragMetaRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendFragMetaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendFragMetaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Watermark != nil {
		{
			size, err := m.Watermark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.FragMetas) > 0 {
		for iNdEx := len(m.FragMetas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FragMetas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.WorkerNodeAddr) > 0 {
		i -= len(m.WorkerNodeAddr)
		copy(dAtA[i:], m.WorkerNodeAddr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.WorkerNodeAddr)))
		i--
		dAtA[i] = 0x22
	}
	if m.ShardId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x18
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendFragMetaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendFragMetaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendFragMetaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardLocalCacheInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardLocalCacheInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardLocalCacheInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalCacheAddrs) > 0 {
		for iNdEx := len(m.LocalCacheAddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LocalCacheAddrs[iNdEx])
			copy(dAtA[i:], m.LocalCacheAddrs[iNdEx])
			i = encodeVarintTici(dAtA, i, uint64(len(m.LocalCacheAddrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetShardLocalCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardLocalCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardLocalCacheRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if len(m.KeyRanges) > 0 {
		for iNdEx := len(m.KeyRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KeyRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetShardLocalCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetShardLocalCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetShardLocalCacheResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ShardLocalCacheInfos) > 0 {
		for iNdEx := len(m.ShardLocalCacheInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ShardLocalCacheInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DebugGetShardManifestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugGetShardManifestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugGetShardManifestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyRange != nil {
		{
			size, err := m.KeyRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DebugGetShardManifestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DebugGetShardManifestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DebugGetShardManifestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FragMetas) > 0 {
		for iNdEx := len(m.FragMetas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FragMetas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CompactFragRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactFragRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactFragRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Worker) > 0 {
		i -= len(m.Worker)
		copy(dAtA[i:], m.Worker)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Worker)))
		i--
		dAtA[i] = 0x52
	}
	if m.CompactType != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.CompactType))
		i--
		dAtA[i] = 0x48
	}
	if m.UploadLocation != nil {
		{
			size, err := m.UploadLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.InputFrags) > 0 {
		for iNdEx := len(m.InputFrags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputFrags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.LeaderTerm) > 0 {
		i -= len(m.LeaderTerm)
		copy(dAtA[i:], m.LeaderTerm)
		i = encodeVarintTici(dAtA, i, uint64(len(m.LeaderTerm)))
		i--
		dAtA[i] = 0x32
	}
	if m.Timestamp != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x28
	}
	if m.Seq != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x20
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x18
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x10
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompactFragResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactFragResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactFragResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FinishCompactFragRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishCompactFragRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishCompactFragRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OutputFrags) > 0 {
		for iNdEx := len(m.OutputFrags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OutputFrags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.InputFrags) > 0 {
		for iNdEx := len(m.InputFrags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputFrags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.LeaderTerm) > 0 {
		i -= len(m.LeaderTerm)
		copy(dAtA[i:], m.LeaderTerm)
		i = encodeVarintTici(dAtA, i, uint64(len(m.LeaderTerm)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Timestamp != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x30
	}
	if m.Seq != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x28
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x20
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x18
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinishCompactFragResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishCompactFragResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishCompactFragResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardManifestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardManifestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardManifestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintTici(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.ShardId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ShardId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S3Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S3Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S3Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Prefix) > 0 {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bucket) > 0 {
		i -= len(m.Bucket)
		copy(dAtA[i:], m.Bucket)
		i = encodeVarintTici(dAtA, i, uint64(len(m.Bucket)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddShardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UploadLocation != nil {
		{
			size, err := m.UploadLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CdcLocation != nil {
		{
			size, err := m.CdcLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Watermark != nil {
		{
			size, err := m.Watermark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TableInfo != nil {
		{
			size, err := m.TableInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexInfo != nil {
		{
			size, err := m.IndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddShardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddShardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddShardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableInfo != nil {
		{
			size, err := m.TableInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IndexInfo != nil {
		{
			size, err := m.IndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndexId) > 0 {
		i -= len(m.IndexId)
		copy(dAtA[i:], m.IndexId)
		i = encodeVarintTici(dAtA, i, uint64(len(m.IndexId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndexRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DropIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropIndexResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsClustered {
		i--
		if m.IsClustered {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Version != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintTici(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintTici(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x12
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsArray {
		i--
		if m.IsArray {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IsPrimaryKey {
		i--
		if m.IsPrimaryKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.DefaultVal) > 0 {
		i -= len(m.DefaultVal)
		copy(dAtA[i:], m.DefaultVal)
		i = encodeVarintTici(dAtA, i, uint64(len(m.DefaultVal)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Elems) > 0 {
		for iNdEx := len(m.Elems) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Elems[iNdEx])
			copy(dAtA[i:], m.Elems[iNdEx])
			i = encodeVarintTici(dAtA, i, uint64(len(m.Elems[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Flag != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x38
	}
	if m.Decimal != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Decimal))
		i--
		dAtA[i] = 0x30
	}
	if m.ColumnLength != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ColumnLength))
		i--
		dAtA[i] = 0x28
	}
	if m.Collation != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Collation))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ColumnName) > 0 {
		i -= len(m.ColumnName)
		copy(dAtA[i:], m.ColumnName)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ColumnName)))
		i--
		dAtA[i] = 0x12
	}
	if m.ColumnId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ColumnId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OtherParams) > 0 {
		for k := range m.OtherParams {
			v := m.OtherParams[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTici(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTici(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTici(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ParserInfo != nil {
		{
			size, err := m.ParserInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.IsUnique {
		i--
		if m.IsUnique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTici(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IndexType != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintTici(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ParserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParserInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParserInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParserParams) > 0 {
		for k := range m.ParserParams {
			v := m.ParserParams[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTici(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTici(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTici(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ParserType != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.ParserType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetIndexProgressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexProgressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexProgressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetIndexProgressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexProgressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexProgressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.S3Path) > 0 {
		i -= len(m.S3Path)
		copy(dAtA[i:], m.S3Path)
		i = encodeVarintTici(dAtA, i, uint64(len(m.S3Path)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LastUploadTime) > 0 {
		i -= len(m.LastUploadTime)
		copy(dAtA[i:], m.LastUploadTime)
		i = encodeVarintTici(dAtA, i, uint64(len(m.LastUploadTime)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsUploaded {
		i--
		if m.IsUploaded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.DocumentCount != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.DocumentCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetImportStoragePathRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImportStoragePathRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImportStoragePathRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpperBound) > 0 {
		i -= len(m.UpperBound)
		copy(dAtA[i:], m.UpperBound)
		i = encodeVarintTici(dAtA, i, uint64(len(m.UpperBound)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LowerBound) > 0 {
		i -= len(m.LowerBound)
		copy(dAtA[i:], m.LowerBound)
		i = encodeVarintTici(dAtA, i, uint64(len(m.LowerBound)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TableInfo != nil {
		{
			size, err := m.TableInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IndexInfo != nil {
		{
			size, err := m.IndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTici(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetImportStoragePathResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImportStoragePathResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImportStoragePathResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.S3Path) > 0 {
		i -= len(m.S3Path)
		copy(dAtA[i:], m.S3Path)
		i = encodeVarintTici(dAtA, i, uint64(len(m.S3Path)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarkPartitionUploadFinishedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkPartitionUploadFinishedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkPartitionUploadFinishedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.S3Path) > 0 {
		i -= len(m.S3Path)
		copy(dAtA[i:], m.S3Path)
		i = encodeVarintTici(dAtA, i, uint64(len(m.S3Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkPartitionUploadFinishedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkPartitionUploadFinishedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkPartitionUploadFinishedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarkTableUploadFinishedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkTableUploadFinishedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkTableUploadFinishedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.IndexId))
		i--
		dAtA[i] = 0x10
	}
	if m.TableId != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarkTableUploadFinishedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkTableUploadFinishedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkTableUploadFinishedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTici(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTici(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTici(dAtA []byte, offset int, v uint64) int {
	offset -= sovTici(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WorkerNodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuUsage != 0 {
		n += 9
	}
	if m.MemoryUsage != 0 {
		n += 1 + sovTici(uint64(m.MemoryUsage))
	}
	return n
}

func (m *ReaderNodeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuUsage != 0 {
		n += 9
	}
	if m.MemoryUsage != 0 {
		n += 1 + sovTici(uint64(m.MemoryUsage))
	}
	if m.RequestsInCycle != 0 {
		n += 1 + sovTici(uint64(m.RequestsInCycle))
	}
	if m.CacheHitRate != 0 {
		n += 9
	}
	return n
}

func (m *WorkerNodeShardStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.ShardId != 0 {
		n += 1 + sovTici(uint64(m.ShardId))
	}
	if m.Epoch != 0 {
		n += 1 + sovTici(uint64(m.Epoch))
	}
	if m.Seq != 0 {
		n += 1 + sovTici(uint64(m.Seq))
	}
	return n
}

func (m *WorkerNodeCompactionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *WorkerNodeHeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if len(m.Compactions) > 0 {
		for _, e := range m.Compactions {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *WorkerNodeHeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	if len(m.ToAddShards) > 0 {
		for _, e := range m.ToAddShards {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if len(m.ToRemoveShards) > 0 {
		l = 0
		for _, e := range m.ToRemoveShards {
			l += sovTici(uint64(e))
		}
		n += 1 + sovTici(uint64(l)) + l
	}
	return n
}

func (m *ReaderNodeHeartbeatRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.TiflashServerAddr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.CachedShardIds) > 0 {
		l = 0
		for _, e := range m.CachedShardIds {
			l += sovTici(uint64(e))
		}
		n += 1 + sovTici(uint64(l)) + l
	}
	return n
}

func (m *ReaderNodeHeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *FragProperty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovTici(uint64(m.Size_))
	}
	if m.Count != 0 {
		n += 1 + sovTici(uint64(m.Count))
	}
	l = len(m.MinHandle)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.MidHandle)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.MaxHandle)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *FragMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FormatVersion != 0 {
		n += 1 + sovTici(uint64(m.FormatVersion))
	}
	l = len(m.FragPath)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.HasDeletedSet {
		n += 2
	}
	if len(m.Segs) > 0 {
		for _, e := range m.Segs {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.Property != nil {
		l = m.Property.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *FragMeta_IndexSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SegId)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.DelSuffix)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *ShardWatermark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Watermark != nil {
		n += m.Watermark.Size()
	}
	return n
}

func (m *ShardWatermark_CdcFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CdcFile)
	n += 1 + l + sovTici(uint64(l))
	return n
}
func (m *ShardWatermark_ImportFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImportFile)
	n += 1 + l + sovTici(uint64(l))
	return n
}
func (m *AppendFragMetaRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.ShardId != 0 {
		n += 1 + sovTici(uint64(m.ShardId))
	}
	l = len(m.WorkerNodeAddr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.FragMetas) > 0 {
		for _, e := range m.FragMetas {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.Watermark != nil {
		l = m.Watermark.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *AppendFragMetaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	return n
}

func (m *KeyRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *ShardLocalCacheInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.LocalCacheAddrs) > 0 {
		for _, s := range m.LocalCacheAddrs {
			l = len(s)
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *GetShardLocalCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if len(m.KeyRanges) > 0 {
		for _, e := range m.KeyRanges {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.Limit != 0 {
		n += 1 + sovTici(uint64(m.Limit))
	}
	return n
}

func (m *GetShardLocalCacheResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	if len(m.ShardLocalCacheInfos) > 0 {
		for _, e := range m.ShardLocalCacheInfos {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *DebugGetShardManifestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *DebugGetShardManifestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FragMetas) > 0 {
		for _, e := range m.FragMetas {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *CompactFragRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.Seq != 0 {
		n += 1 + sovTici(uint64(m.Seq))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTici(uint64(m.Timestamp))
	}
	l = len(m.LeaderTerm)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.InputFrags) > 0 {
		for _, e := range m.InputFrags {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.UploadLocation != nil {
		l = m.UploadLocation.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.CompactType != 0 {
		n += 1 + sovTici(uint64(m.CompactType))
	}
	l = len(m.Worker)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *CompactFragResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	return n
}

func (m *FinishCompactFragRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	if m.Seq != 0 {
		n += 1 + sovTici(uint64(m.Seq))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTici(uint64(m.Timestamp))
	}
	l = len(m.LeaderTerm)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.InputFrags) > 0 {
		for _, e := range m.InputFrags {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if len(m.OutputFrags) > 0 {
		for _, e := range m.OutputFrags {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	return n
}

func (m *FinishCompactFragResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	return n
}

func (m *ShardManifestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardId != 0 {
		n += 1 + sovTici(uint64(m.ShardId))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovTici(uint64(m.Epoch))
	}
	return n
}

func (m *S3Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bucket)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *AddShardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.IndexInfo != nil {
		l = m.IndexInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableInfo != nil {
		l = m.TableInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Watermark != nil {
		l = m.Watermark.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.CdcLocation != nil {
		l = m.CdcLocation.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.UploadLocation != nil {
		l = m.UploadLocation.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *AddShardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	return n
}

func (m *CreateIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexInfo != nil {
		l = m.IndexInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableInfo != nil {
		l = m.TableInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *CreateIndexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.IndexId)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *DropIndexRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	return n
}

func (m *DropIndexResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *TableInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.DatabaseName)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTici(uint64(m.Version))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.IsClustered {
		n += 2
	}
	return n
}

func (m *ColumnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ColumnId != 0 {
		n += 1 + sovTici(uint64(m.ColumnId))
	}
	l = len(m.ColumnName)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTici(uint64(m.Type))
	}
	if m.Collation != 0 {
		n += 1 + sovTici(uint64(m.Collation))
	}
	if m.ColumnLength != 0 {
		n += 1 + sovTici(uint64(m.ColumnLength))
	}
	if m.Decimal != 0 {
		n += 1 + sovTici(uint64(m.Decimal))
	}
	if m.Flag != 0 {
		n += 1 + sovTici(uint64(m.Flag))
	}
	if len(m.Elems) > 0 {
		for _, s := range m.Elems {
			l = len(s)
			n += 1 + l + sovTici(uint64(l))
		}
	}
	l = len(m.DefaultVal)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.IsPrimaryKey {
		n += 2
	}
	if m.IsArray {
		n += 2
	}
	return n
}

func (m *IndexInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.IndexType != 0 {
		n += 1 + sovTici(uint64(m.IndexType))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovTici(uint64(l))
		}
	}
	if m.IsUnique {
		n += 2
	}
	if m.ParserInfo != nil {
		l = m.ParserInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if len(m.OtherParams) > 0 {
		for k, v := range m.OtherParams {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTici(uint64(len(k))) + 1 + len(v) + sovTici(uint64(len(v)))
			n += mapEntrySize + 1 + sovTici(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ParserInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParserType != 0 {
		n += 1 + sovTici(uint64(m.ParserType))
	}
	if len(m.ParserParams) > 0 {
		for k, v := range m.ParserParams {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTici(uint64(len(k))) + 1 + len(v) + sovTici(uint64(len(v)))
			n += mapEntrySize + 1 + sovTici(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetIndexProgressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	return n
}

func (m *GetIndexProgressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	if m.DocumentCount != 0 {
		n += 1 + sovTici(uint64(m.DocumentCount))
	}
	if m.State != 0 {
		n += 1 + sovTici(uint64(m.State))
	}
	if m.IsUploaded {
		n += 2
	}
	l = len(m.LastUploadTime)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.S3Path)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *GetImportStoragePathRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexInfo != nil {
		l = m.IndexInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	if m.TableInfo != nil {
		l = m.TableInfo.Size()
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.LowerBound)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.UpperBound)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *GetImportStoragePathResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	l = len(m.S3Path)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *MarkPartitionUploadFinishedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.S3Path)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *MarkPartitionUploadFinishedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func (m *MarkTableUploadFinishedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovTici(uint64(m.TableId))
	}
	if m.IndexId != 0 {
		n += 1 + sovTici(uint64(m.IndexId))
	}
	return n
}

func (m *MarkTableUploadFinishedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTici(uint64(m.Status))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTici(uint64(l))
	}
	return n
}

func sovTici(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTici(x uint64) (n int) {
	return sovTici(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WorkerNodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUsage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsage", wireType)
			}
			m.MemoryUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReaderNodeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReaderNodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReaderNodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsage", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUsage = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsage", wireType)
			}
			m.MemoryUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestsInCycle", wireType)
			}
			m.RequestsInCycle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestsInCycle |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheHitRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CacheHitRate = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeShardStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeShardStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeShardStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeCompactionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeCompactionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeCompactionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &CompactFragRequest{}
			}
			if err := m.Req.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &WorkerNodeStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, &WorkerNodeShardStatus{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compactions = append(m.Compactions, &WorkerNodeCompactionStatus{})
			if err := m.Compactions[len(m.Compactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerNodeHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerNodeHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerNodeHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddShards = append(m.ToAddShards, &AddShardRequest{})
			if err := m.ToAddShards[len(m.ToAddShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ToRemoveShards = append(m.ToRemoveShards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTici
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTici
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ToRemoveShards) == 0 {
					m.ToRemoveShards = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ToRemoveShards = append(m.ToRemoveShards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ToRemoveShards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReaderNodeHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReaderNodeHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReaderNodeHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ReaderNodeStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TiflashServerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TiflashServerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CachedShardIds = append(m.CachedShardIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTici
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTici
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CachedShardIds) == 0 {
					m.CachedShardIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CachedShardIds = append(m.CachedShardIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CachedShardIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReaderNodeHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReaderNodeHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReaderNodeHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FragProperty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FragProperty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FragProperty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinHandle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinHandle = append(m.MinHandle[:0], dAtA[iNdEx:postIndex]...)
			if m.MinHandle == nil {
				m.MinHandle = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MidHandle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MidHandle = append(m.MidHandle[:0], dAtA[iNdEx:postIndex]...)
			if m.MidHandle == nil {
				m.MidHandle = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHandle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxHandle = append(m.MaxHandle[:0], dAtA[iNdEx:postIndex]...)
			if m.MaxHandle == nil {
				m.MaxHandle = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FragMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FragMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FragMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormatVersion", wireType)
			}
			m.FormatVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FormatVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasDeletedSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasDeletedSet = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segs = append(m.Segs, &FragMeta_IndexSegment{})
			if err := m.Segs[len(m.Segs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Property == nil {
				m.Property = &FragProperty{}
			}
			if err := m.Property.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FragMeta_IndexSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SegId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardWatermark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardWatermark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardWatermark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdcFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Watermark = &ShardWatermark_CdcFile{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Watermark = &ShardWatermark_ImportFile{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendFragMetaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendFragMetaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendFragMetaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerNodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerNodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragMetas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragMetas = append(m.FragMetas, &FragMeta{})
			if err := m.FragMetas[len(m.FragMetas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Watermark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Watermark == nil {
				m.Watermark = &ShardWatermark{}
			}
			if err := m.Watermark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendFragMetaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendFragMetaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendFragMetaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardLocalCacheInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardLocalCacheInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardLocalCacheInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &ShardManifestHeader{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalCacheAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalCacheAddrs = append(m.LocalCacheAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardLocalCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardLocalCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardLocalCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRanges = append(m.KeyRanges, &KeyRange{})
			if err := m.KeyRanges[len(m.KeyRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetShardLocalCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetShardLocalCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetShardLocalCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardLocalCacheInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardLocalCacheInfos = append(m.ShardLocalCacheInfos, &ShardLocalCacheInfo{})
			if err := m.ShardLocalCacheInfos[len(m.ShardLocalCacheInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugGetShardManifestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugGetShardManifestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugGetShardManifestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DebugGetShardManifestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DebugGetShardManifestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DebugGetShardManifestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragMetas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FragMetas = append(m.FragMetas, &FragMeta{})
			if err := m.FragMetas[len(m.FragMetas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactFragRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactFragRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactFragRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &ShardManifestHeader{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderTerm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaderTerm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputFrags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputFrags = append(m.InputFrags, &FragMeta{})
			if err := m.InputFrags[len(m.InputFrags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadLocation == nil {
				m.UploadLocation = &S3Location{}
			}
			if err := m.UploadLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactType", wireType)
			}
			m.CompactType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactType |= CompactType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Worker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactFragResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactFragResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactFragResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishCompactFragRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishCompactFragRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishCompactFragRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &ShardManifestHeader{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderTerm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaderTerm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputFrags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputFrags = append(m.InputFrags, &FragMeta{})
			if err := m.InputFrags[len(m.InputFrags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputFrags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputFrags = append(m.OutputFrags, &FragMeta{})
			if err := m.OutputFrags[len(m.OutputFrags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishCompactFragResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishCompactFragResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishCompactFragResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardManifestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardManifestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardManifestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardId", wireType)
			}
			m.ShardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S3Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S3Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S3Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bucket = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &ShardManifestHeader{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexInfo == nil {
				m.IndexInfo = &IndexInfo{}
			}
			if err := m.IndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableInfo == nil {
				m.TableInfo = &TableInfo{}
			}
			if err := m.TableInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Watermark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Watermark == nil {
				m.Watermark = &ShardWatermark{}
			}
			if err := m.Watermark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CdcLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CdcLocation == nil {
				m.CdcLocation = &S3Location{}
			}
			if err := m.CdcLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadLocation == nil {
				m.UploadLocation = &S3Location{}
			}
			if err := m.UploadLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddShardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddShardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddShardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexInfo == nil {
				m.IndexInfo = &IndexInfo{}
			}
			if err := m.IndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableInfo == nil {
				m.TableInfo = &TableInfo{}
			}
			if err := m.TableInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClustered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClustered = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnId", wireType)
			}
			m.ColumnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			m.Collation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Collation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnLength", wireType)
			}
			m.ColumnLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			m.Decimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elems = append(m.Elems, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultVal", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultVal = append(m.DefaultVal[:0], dAtA[iNdEx:postIndex]...)
			if m.DefaultVal == nil {
				m.DefaultVal = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimaryKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimaryKey = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArray", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsArray = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexType", wireType)
			}
			m.IndexType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexType |= IndexType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &ColumnInfo{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUnique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUnique = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParserInfo == nil {
				m.ParserInfo = &ParserInfo{}
			}
			if err := m.ParserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtherParams == nil {
				m.OtherParams = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTici
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTici
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTici
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTici
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTici(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTici
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OtherParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserType", wireType)
			}
			m.ParserType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParserType |= ParserType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParserParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParserParams == nil {
				m.ParserParams = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTici
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTici
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTici
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTici
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTici
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTici
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTici(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTici
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ParserParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexProgressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexProgressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexProgressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexProgressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexProgressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexProgressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentCount", wireType)
			}
			m.DocumentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocumentCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= GetIndexProgressResponse_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUploaded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUploaded = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUploadTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastUploadTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImportStoragePathRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImportStoragePathRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImportStoragePathRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IndexInfo == nil {
				m.IndexInfo = &IndexInfo{}
			}
			if err := m.IndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableInfo == nil {
				m.TableInfo = &TableInfo{}
			}
			if err := m.TableInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerBound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowerBound = append(m.LowerBound[:0], dAtA[iNdEx:postIndex]...)
			if m.LowerBound == nil {
				m.LowerBound = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperBound", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpperBound = append(m.UpperBound[:0], dAtA[iNdEx:postIndex]...)
			if m.UpperBound == nil {
				m.UpperBound = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImportStoragePathResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImportStoragePathResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImportStoragePathResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkPartitionUploadFinishedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkPartitionUploadFinishedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkPartitionUploadFinishedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S3Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkPartitionUploadFinishedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkPartitionUploadFinishedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkPartitionUploadFinishedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkTableUploadFinishedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkTableUploadFinishedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkTableUploadFinishedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexId", wireType)
			}
			m.IndexId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkTableUploadFinishedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTici
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkTableUploadFinishedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkTableUploadFinishedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTici
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTici
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTici
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTici(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTici
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTici(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTici
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTici
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTici
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTici
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTici
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTici
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTici        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTici          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTici = fmt.Errorf("proto: unexpected end of group")
)
