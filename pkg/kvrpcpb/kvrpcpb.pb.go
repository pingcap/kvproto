// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kvrpcpb.proto

/*
Package kvrpcpb is a generated protocol buffer package.

It is generated from these files:

	kvrpcpb.proto

It has these top-level messages:

	GetRequest
	GetResponse
	ScanRequest
	ScanResponse
	PrewriteRequest
	PrewriteResponse
	PessimisticLockRequest
	PessimisticLockKeyResult
	PessimisticLockResponse
	PessimisticRollbackRequest
	PessimisticRollbackResponse
	TxnHeartBeatRequest
	TxnHeartBeatResponse
	CheckTxnStatusRequest
	CheckTxnStatusResponse
	CheckSecondaryLocksRequest
	CheckSecondaryLocksResponse
	CommitRequest
	CommitResponse
	ImportRequest
	ImportResponse
	CleanupRequest
	CleanupResponse
	BatchGetRequest
	BatchGetResponse
	BatchRollbackRequest
	BatchRollbackResponse
	ScanLockRequest
	ScanLockResponse
	ResolveLockRequest
	ResolveLockResponse
	GCRequest
	GCResponse
	DeleteRangeRequest
	DeleteRangeResponse
	PrepareFlashbackToVersionRequest
	PrepareFlashbackToVersionResponse
	FlashbackToVersionRequest
	FlashbackToVersionResponse
	RawGetRequest
	RawGetResponse
	RawBatchGetRequest
	RawBatchGetResponse
	RawPutRequest
	RawPutResponse
	RawBatchPutRequest
	RawBatchPutResponse
	RawDeleteRequest
	RawDeleteResponse
	RawBatchDeleteRequest
	RawBatchDeleteResponse
	RawScanRequest
	RawScanResponse
	RawDeleteRangeRequest
	RawDeleteRangeResponse
	RawBatchScanRequest
	RawBatchScanResponse
	UnsafeDestroyRangeRequest
	UnsafeDestroyRangeResponse
	RegisterLockObserverRequest
	RegisterLockObserverResponse
	CheckLockObserverRequest
	CheckLockObserverResponse
	RemoveLockObserverRequest
	RemoveLockObserverResponse
	PhysicalScanLockRequest
	PhysicalScanLockResponse
	SplitRegionRequest
	SplitRegionResponse
	ReadIndexRequest
	ReadIndexResponse
	MvccGetByKeyRequest
	MvccGetByKeyResponse
	MvccGetByStartTsRequest
	MvccGetByStartTsResponse
	Context
	ResourceControlContext
	SourceStmt
	LockInfo
	KeyError
	WriteConflict
	AlreadyExist
	Deadlock
	CommitTsExpired
	TxnNotFound
	CommitTsTooLarge
	AssertionFailed
	PrimaryMismatch
	TimeDetail
	TimeDetailV2
	ScanInfo
	ScanDetail
	ScanDetailV2
	ExecDetails
	ExecDetailsV2
	WriteDetail
	KvPair
	Mutation
	MvccWrite
	MvccValue
	MvccLock
	MvccInfo
	TxnInfo
	KeyRange
	LeaderInfo
	ReadState
	CheckLeaderRequest
	CheckLeaderResponse
	StoreSafeTSRequest
	StoreSafeTSResponse
	RawGetKeyTTLRequest
	RawGetKeyTTLResponse
	RawCASRequest
	RawCASResponse
	GetLockWaitInfoRequest
	GetLockWaitInfoResponse
	GetLockWaitHistoryRequest
	GetLockWaitHistoryResponse
	RawCoprocessorRequest
	RawCoprocessorResponse
	RawChecksumRequest
	RawChecksumResponse
	CompactError
	CompactErrorInvalidStartKey
	CompactErrorPhysicalTableNotExist
	CompactErrorCompactInProgress
	CompactErrorTooManyPendingTasks
	CompactRequest
	CompactResponse
	TiFlashSystemTableRequest
	TiFlashSystemTableResponse
	TxnEntry
	ScanTxnEntriesRequest
	ScanTxnEntriesResponse
*/
package kvrpcpb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"
	metapb "github.com/pingcap/kvproto/pkg/metapb"

	errorpb "github.com/pingcap/kvproto/pkg/errorpb"

	_ "github.com/gogo/protobuf/gogoproto"

	deadlock "github.com/pingcap/kvproto/pkg/deadlock"

	tracepb "github.com/pingcap/kvproto/pkg/tracepb"

	resource_manager "github.com/pingcap/kvproto/pkg/resource_manager"

	github_com_pingcap_kvproto_pkg_sharedbytes "github.com/pingcap/kvproto/pkg/sharedbytes"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Used to specify the behavior when a pessimistic lock request is woken up after waiting for another
// lock.
type PessimisticLockWakeUpMode int32

const (
	// When woken up, returns WriteConflict error to the client and the client should retry if necessary.
	// In this mode, results of `return_values` or `check_existence` will be set to `values` and `not_founds`
	// fields of the PessimisticLockResponse, which is compatible with old versions.
	PessimisticLockWakeUpMode_WakeUpModeNormal PessimisticLockWakeUpMode = 0
	// When woken up, continue trying to lock the key. This implicitly enables the `allow_lock_with_conflict`
	// behavior, which means, allow acquiring the lock even if there is WriteConflict on the key.
	// In this mode, `return_values` or `check_existence` fields of PessimisticLockResponse won't be used, and
	// all results are carried in the `results` field.
	PessimisticLockWakeUpMode_WakeUpModeForceLock PessimisticLockWakeUpMode = 1
)

var PessimisticLockWakeUpMode_name = map[int32]string{
	0: "WakeUpModeNormal",
	1: "WakeUpModeForceLock",
}
var PessimisticLockWakeUpMode_value = map[string]int32{
	"WakeUpModeNormal":    0,
	"WakeUpModeForceLock": 1,
}

func (x PessimisticLockWakeUpMode) String() string {
	return proto.EnumName(PessimisticLockWakeUpMode_name, int32(x))
}
func (PessimisticLockWakeUpMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{0}
}

type PessimisticLockKeyResultType int32

const (
	PessimisticLockKeyResultType_LockResultNormal             PessimisticLockKeyResultType = 0
	PessimisticLockKeyResultType_LockResultLockedWithConflict PessimisticLockKeyResultType = 1
	PessimisticLockKeyResultType_LockResultFailed             PessimisticLockKeyResultType = 2
)

var PessimisticLockKeyResultType_name = map[int32]string{
	0: "LockResultNormal",
	1: "LockResultLockedWithConflict",
	2: "LockResultFailed",
}
var PessimisticLockKeyResultType_value = map[string]int32{
	"LockResultNormal":             0,
	"LockResultLockedWithConflict": 1,
	"LockResultFailed":             2,
}

func (x PessimisticLockKeyResultType) String() string {
	return proto.EnumName(PessimisticLockKeyResultType_name, int32(x))
}
func (PessimisticLockKeyResultType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{1}
}

// The API version the server and the client is using.
// See more details in https://github.com/tikv/rfcs/blob/master/text/0069-api-v2.md.
type APIVersion int32

const (
	// `V1` is mainly for TiDB & TxnKV, and is not safe to use RawKV along with the others.
	// V1 server only accepts V1 requests. V1 raw requests with TTL will be rejected.
	APIVersion_V1 APIVersion = 0
	//
	// `V1TTL` is only available to RawKV, and 8 bytes representing the unix timestamp in
	// seconds for expiring time will be append to the value of all RawKV entries. For example:
	// ------------------------------------------------------------
	// | User value     | Expire Ts                               |
	// ------------------------------------------------------------
	// | 0x12 0x34 0x56 | 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff |
	// ------------------------------------------------------------
	// V1TTL server only accepts V1 raw requests.
	// V1 client should not use `V1TTL` in request. V1 client should always send `V1`.
	APIVersion_V1TTL APIVersion = 1
	//
	// `V2` use new encoding for RawKV & TxnKV to support more features.
	//
	// Key Encoding:
	//  TiDB: start with `m` or `t`, the same as `V1`.
	//  TxnKV: prefix with `x`, encoded as `MCE( x{keyspace id} + {user key} ) + timestamp`.
	//  RawKV: prefix with `r`, encoded as `MCE( r{keyspace id} + {user key} ) + timestamp`.
	//  Where the `{keyspace id}` is fixed-length of 3 bytes in network byte order.
	//  Besides, RawKV entires must be in `default` CF.
	//
	// Value Encoding:
	//  TiDB & TxnKV: the same as `V1`.
	//  RawKV: `{user value} + {optional fields} + {meta flag}`. The last byte in the
	//  raw value must be meta flags. For example:
	//  --------------------------------------
	//  | User value     | Meta flags        |
	//  --------------------------------------
	//  | 0x12 0x34 0x56 | 0x00 (0b00000000) |
	//  --------------------------------------
	//  Bit 0 of meta flags is for TTL. If set, the value contains 8 bytes expiring time as
	//  unix timestamp in seconds at the very left to the meta flags.
	//  --------------------------------------------------------------------------------
	//  | User value     | Expiring time                           | Meta flags        |
	//  --------------------------------------------------------------------------------
	//  | 0x12 0x34 0x56 | 0x00 0x00 0x00 0x00 0x00 0x00 0xff 0xff | 0x01 (0b00000001) |
	//  --------------------------------------------------------------------------------
	//  Bit 1 is for deletion. If set, the entry is logical deleted.
	//  ---------------------
	//  | Meta flags        |
	//  ---------------------
	//  | 0x02 (0b00000010) |
	//  ---------------------
	//
	// V2 server accpets V2 requests and V1 transactional requests that statrts with TiDB key
	// prefix (`m` and `t`).
	APIVersion_V2 APIVersion = 2
)

var APIVersion_name = map[int32]string{
	0: "V1",
	1: "V1TTL",
	2: "V2",
}
var APIVersion_value = map[string]int32{
	"V1":    0,
	"V1TTL": 1,
	"V2":    2,
}

func (x APIVersion) String() string {
	return proto.EnumName(APIVersion_name, int32(x))
}
func (APIVersion) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{2} }

type CommandPri int32

const (
	CommandPri_Normal CommandPri = 0
	CommandPri_Low    CommandPri = 1
	CommandPri_High   CommandPri = 2
)

var CommandPri_name = map[int32]string{
	0: "Normal",
	1: "Low",
	2: "High",
}
var CommandPri_value = map[string]int32{
	"Normal": 0,
	"Low":    1,
	"High":   2,
}

func (x CommandPri) String() string {
	return proto.EnumName(CommandPri_name, int32(x))
}
func (CommandPri) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{3} }

type IsolationLevel int32

const (
	IsolationLevel_SI        IsolationLevel = 0
	IsolationLevel_RC        IsolationLevel = 1
	IsolationLevel_RCCheckTS IsolationLevel = 2
)

var IsolationLevel_name = map[int32]string{
	0: "SI",
	1: "RC",
	2: "RCCheckTS",
}
var IsolationLevel_value = map[string]int32{
	"SI":        0,
	"RC":        1,
	"RCCheckTS": 2,
}

func (x IsolationLevel) String() string {
	return proto.EnumName(IsolationLevel_name, int32(x))
}
func (IsolationLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{4} }

// Operation allowed info during each TiKV storage threshold.
type DiskFullOpt int32

const (
	DiskFullOpt_NotAllowedOnFull     DiskFullOpt = 0
	DiskFullOpt_AllowedOnAlmostFull  DiskFullOpt = 1
	DiskFullOpt_AllowedOnAlreadyFull DiskFullOpt = 2
)

var DiskFullOpt_name = map[int32]string{
	0: "NotAllowedOnFull",
	1: "AllowedOnAlmostFull",
	2: "AllowedOnAlreadyFull",
}
var DiskFullOpt_value = map[string]int32{
	"NotAllowedOnFull":     0,
	"AllowedOnAlmostFull":  1,
	"AllowedOnAlreadyFull": 2,
}

func (x DiskFullOpt) String() string {
	return proto.EnumName(DiskFullOpt_name, int32(x))
}
func (DiskFullOpt) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{5} }

type Op int32

const (
	Op_Put      Op = 0
	Op_Del      Op = 1
	Op_Lock     Op = 2
	Op_Rollback Op = 3
	// insert operation has a constraint that key should not exist before.
	Op_Insert          Op = 4
	Op_PessimisticLock Op = 5
	Op_CheckNotExists  Op = 6
)

var Op_name = map[int32]string{
	0: "Put",
	1: "Del",
	2: "Lock",
	3: "Rollback",
	4: "Insert",
	5: "PessimisticLock",
	6: "CheckNotExists",
}
var Op_value = map[string]int32{
	"Put":             0,
	"Del":             1,
	"Lock":            2,
	"Rollback":        3,
	"Insert":          4,
	"PessimisticLock": 5,
	"CheckNotExists":  6,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}
func (Op) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{6} }

type Assertion int32

const (
	Assertion_None     Assertion = 0
	Assertion_Exist    Assertion = 1
	Assertion_NotExist Assertion = 2
)

var Assertion_name = map[int32]string{
	0: "None",
	1: "Exist",
	2: "NotExist",
}
var Assertion_value = map[string]int32{
	"None":     0,
	"Exist":    1,
	"NotExist": 2,
}

func (x Assertion) String() string {
	return proto.EnumName(Assertion_name, int32(x))
}
func (Assertion) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{7} }

type AssertionLevel int32

const (
	// No assertion.
	AssertionLevel_Off AssertionLevel = 0
	// Assertion is enabled, but not enforced when it might affect performance.
	AssertionLevel_Fast AssertionLevel = 1
	// Assertion is enabled and enforced.
	AssertionLevel_Strict AssertionLevel = 2
)

var AssertionLevel_name = map[int32]string{
	0: "Off",
	1: "Fast",
	2: "Strict",
}
var AssertionLevel_value = map[string]int32{
	"Off":    0,
	"Fast":   1,
	"Strict": 2,
}

func (x AssertionLevel) String() string {
	return proto.EnumName(AssertionLevel_name, int32(x))
}
func (AssertionLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{8} }

type Action int32

const (
	Action_NoAction                     Action = 0
	Action_TTLExpireRollback            Action = 1
	Action_LockNotExistRollback         Action = 2
	Action_MinCommitTSPushed            Action = 3
	Action_TTLExpirePessimisticRollback Action = 4
	Action_LockNotExistDoNothing        Action = 5
)

var Action_name = map[int32]string{
	0: "NoAction",
	1: "TTLExpireRollback",
	2: "LockNotExistRollback",
	3: "MinCommitTSPushed",
	4: "TTLExpirePessimisticRollback",
	5: "LockNotExistDoNothing",
}
var Action_value = map[string]int32{
	"NoAction":                     0,
	"TTLExpireRollback":            1,
	"LockNotExistRollback":         2,
	"MinCommitTSPushed":            3,
	"TTLExpirePessimisticRollback": 4,
	"LockNotExistDoNothing":        5,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}
func (Action) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{9} }

type ExtraOp int32

const (
	ExtraOp_Noop ExtraOp = 0
	// ReadOldValue represents to output the previous value for delete/update operations.
	ExtraOp_ReadOldValue ExtraOp = 1
)

var ExtraOp_name = map[int32]string{
	0: "Noop",
	1: "ReadOldValue",
}
var ExtraOp_value = map[string]int32{
	"Noop":         0,
	"ReadOldValue": 1,
}

func (x ExtraOp) String() string {
	return proto.EnumName(ExtraOp_name, int32(x))
}
func (ExtraOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{10} }

type ChecksumAlgorithm int32

const (
	ChecksumAlgorithm_Crc64_Xor ChecksumAlgorithm = 0
)

var ChecksumAlgorithm_name = map[int32]string{
	0: "Crc64_Xor",
}
var ChecksumAlgorithm_value = map[string]int32{
	"Crc64_Xor": 0,
}

func (x ChecksumAlgorithm) String() string {
	return proto.EnumName(ChecksumAlgorithm_name, int32(x))
}
func (ChecksumAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{11} }

// What kind of checks need to be performed for keys in a pessimistic transaction.
type PrewriteRequest_PessimisticAction int32

const (
	// The key needn't be locked and no extra write conflict checks are needed.
	PrewriteRequest_SKIP_PESSIMISTIC_CHECK PrewriteRequest_PessimisticAction = 0
	// The key should have been locked at the time of prewrite.
	PrewriteRequest_DO_PESSIMISTIC_CHECK PrewriteRequest_PessimisticAction = 1
	// The key doesn't need a pessimistic lock. But we need to do data constraint checks.
	PrewriteRequest_DO_CONSTRAINT_CHECK PrewriteRequest_PessimisticAction = 2
)

var PrewriteRequest_PessimisticAction_name = map[int32]string{
	0: "SKIP_PESSIMISTIC_CHECK",
	1: "DO_PESSIMISTIC_CHECK",
	2: "DO_CONSTRAINT_CHECK",
}
var PrewriteRequest_PessimisticAction_value = map[string]int32{
	"SKIP_PESSIMISTIC_CHECK": 0,
	"DO_PESSIMISTIC_CHECK":   1,
	"DO_CONSTRAINT_CHECK":    2,
}

func (x PrewriteRequest_PessimisticAction) String() string {
	return proto.EnumName(PrewriteRequest_PessimisticAction_name, int32(x))
}
func (PrewriteRequest_PessimisticAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{4, 0}
}

type WriteConflict_Reason int32

const (
	WriteConflict_Unknown             WriteConflict_Reason = 0
	WriteConflict_Optimistic          WriteConflict_Reason = 1
	WriteConflict_PessimisticRetry    WriteConflict_Reason = 2
	WriteConflict_SelfRolledBack      WriteConflict_Reason = 3
	WriteConflict_RcCheckTs           WriteConflict_Reason = 4
	WriteConflict_LazyUniquenessCheck WriteConflict_Reason = 5
)

var WriteConflict_Reason_name = map[int32]string{
	0: "Unknown",
	1: "Optimistic",
	2: "PessimisticRetry",
	3: "SelfRolledBack",
	4: "RcCheckTs",
	5: "LazyUniquenessCheck",
}
var WriteConflict_Reason_value = map[string]int32{
	"Unknown":             0,
	"Optimistic":          1,
	"PessimisticRetry":    2,
	"SelfRolledBack":      3,
	"RcCheckTs":           4,
	"LazyUniquenessCheck": 5,
}

func (x WriteConflict_Reason) String() string {
	return proto.EnumName(WriteConflict_Reason_name, int32(x))
}
func (WriteConflict_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{80, 0}
}

// A transactional get command. Lookup a value for `key` in the transaction with
// starting timestamp = `version`.
type GetRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Key     []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Version uint64   `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{0} }

func (m *GetRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *GetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *GetRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type GetResponse struct {
	// A region error indicates that the request was sent to the wrong TiKV node
	// (or other, similar errors).
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	// A value could not be retrieved due to the state of the database for the requested key.
	Error *KeyError `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// A successful result.
	Value []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// True if the key does not exist in the database.
	NotFound bool `protobuf:"varint,4,opt,name=not_found,json=notFound,proto3" json:"not_found,omitempty"`
	// Time and scan details when processing the request.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,6,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *GetResponse) Reset()                    { *m = GetResponse{} }
func (m *GetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()               {}
func (*GetResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{1} }

func (m *GetResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *GetResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GetResponse) GetNotFound() bool {
	if m != nil {
		return m.NotFound
	}
	return false
}

func (m *GetResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// Scan fetches values for a range of keys; it is part of the transaction with
// starting timestamp = `version`.
type ScanRequest struct {
	Context  *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartKey []byte   `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// The maximum number of results to return.
	Limit   uint32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Version uint64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// Return only the keys found by scanning, not their values.
	KeyOnly bool `protobuf:"varint,5,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	Reverse bool `protobuf:"varint,6,opt,name=reverse,proto3" json:"reverse,omitempty"`
	// For compatibility, when scanning forward, the range to scan is [start_key, end_key), where start_key < end_key;
	// and when scanning backward, it scans [end_key, start_key) in descending order, where end_key < start_key.
	EndKey []byte `protobuf:"bytes,7,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// If sample_step > 0, skips 'sample_step - 1' number of keys after each returned key.
	// locks are not checked.
	SampleStep uint32 `protobuf:"varint,8,opt,name=sample_step,json=sampleStep,proto3" json:"sample_step,omitempty"`
}

func (m *ScanRequest) Reset()                    { *m = ScanRequest{} }
func (m *ScanRequest) String() string            { return proto.CompactTextString(m) }
func (*ScanRequest) ProtoMessage()               {}
func (*ScanRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{2} }

func (m *ScanRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ScanRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *ScanRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ScanRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ScanRequest) GetKeyOnly() bool {
	if m != nil {
		return m.KeyOnly
	}
	return false
}

func (m *ScanRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

func (m *ScanRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *ScanRequest) GetSampleStep() uint32 {
	if m != nil {
		return m.SampleStep
	}
	return 0
}

type ScanResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	// Each KvPair may contain a key error.
	Pairs []*KvPair `protobuf:"bytes,2,rep,name=pairs" json:"pairs,omitempty"`
	// This KeyError exists when some key is locked but we cannot check locks of all keys.
	// In this case, `pairs` should be empty and the client should redo scanning all the keys
	// after resolving the lock.
	Error *KeyError `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *ScanResponse) Reset()                    { *m = ScanResponse{} }
func (m *ScanResponse) String() string            { return proto.CompactTextString(m) }
func (*ScanResponse) ProtoMessage()               {}
func (*ScanResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{3} }

func (m *ScanResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *ScanResponse) GetPairs() []*KvPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func (m *ScanResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

// A prewrite is the first phase of writing to TiKV. It contains all data to be written in a transaction.
// TiKV will write the data in a preliminary state. Data cannot be read until it has been committed.
// The client should only commit a transaction once all prewrites succeed.
type PrewriteRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// The data to be written to the database.
	Mutations []*Mutation `protobuf:"bytes,2,rep,name=mutations" json:"mutations,omitempty"`
	// The client picks one key to be primary (unrelated to the primary key concept in SQL). This
	// key's lock is the source of truth for the state of a transaction. All other locks due to a
	// transaction will point to the primary lock.
	PrimaryLock []byte `protobuf:"bytes,3,opt,name=primary_lock,json=primaryLock,proto3" json:"primary_lock,omitempty"`
	// Identifies the transaction being written.
	StartVersion uint64 `protobuf:"varint,4,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	LockTtl      uint64 `protobuf:"varint,5,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	// TiKV can skip some checks, used for speeding up data migration.
	SkipConstraintCheck bool `protobuf:"varint,6,opt,name=skip_constraint_check,json=skipConstraintCheck,proto3" json:"skip_constraint_check,omitempty"`
	// For pessimistic transaction, some mutations don't need to be locked, for example, non-unique index key.
	// Keys with deferred constraint checks are not locked.
	PessimisticActions []PrewriteRequest_PessimisticAction `protobuf:"varint,7,rep,packed,name=pessimistic_actions,json=pessimisticActions,enum=kvrpcpb.PrewriteRequest_PessimisticAction" json:"pessimistic_actions,omitempty"`
	// How many keys this transaction involves in this region.
	TxnSize uint64 `protobuf:"varint,8,opt,name=txn_size,json=txnSize,proto3" json:"txn_size,omitempty"`
	// For pessimistic transactions only; used to check if a conflict lock is already committed.
	ForUpdateTs uint64 `protobuf:"varint,9,opt,name=for_update_ts,json=forUpdateTs,proto3" json:"for_update_ts,omitempty"`
	// If min_commit_ts > 0, this is a large transaction request, the final commit_ts
	// will be inferred from `min_commit_ts`.
	MinCommitTs uint64 `protobuf:"varint,10,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	// When async commit is enabled, `secondaries` should be set as the key list of all secondary
	// locks if the request prewrites the primary lock.
	UseAsyncCommit bool     `protobuf:"varint,11,opt,name=use_async_commit,json=useAsyncCommit,proto3" json:"use_async_commit,omitempty"`
	Secondaries    [][]byte `protobuf:"bytes,12,rep,name=secondaries" json:"secondaries,omitempty"`
	// When the transaction involves only one region, it's possible to commit the transaction
	// directly with 1PC protocol.
	TryOnePc bool `protobuf:"varint,13,opt,name=try_one_pc,json=tryOnePc,proto3" json:"try_one_pc,omitempty"`
	// The max commit ts is reserved for limiting the commit ts of 1PC or async commit, which can be used to avoid
	// inconsistency with schema change.
	MaxCommitTs uint64 `protobuf:"varint,14,opt,name=max_commit_ts,json=maxCommitTs,proto3" json:"max_commit_ts,omitempty"`
	// The level of assertion to use on this prewrte request.
	AssertionLevel AssertionLevel `protobuf:"varint,15,opt,name=assertion_level,json=assertionLevel,proto3,enum=kvrpcpb.AssertionLevel" json:"assertion_level,omitempty"`
	// for_update_ts constriants that should be checked when prewriting a pessimistic transaction.
	// See https://github.com/tikv/tikv/issues/14311
	ForUpdateTsConstraints []*PrewriteRequest_ForUpdateTSConstraint `protobuf:"bytes,16,rep,name=for_update_ts_constraints,json=forUpdateTsConstraints" json:"for_update_ts_constraints,omitempty"`
}

func (m *PrewriteRequest) Reset()                    { *m = PrewriteRequest{} }
func (m *PrewriteRequest) String() string            { return proto.CompactTextString(m) }
func (*PrewriteRequest) ProtoMessage()               {}
func (*PrewriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{4} }

func (m *PrewriteRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *PrewriteRequest) GetMutations() []*Mutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *PrewriteRequest) GetPrimaryLock() []byte {
	if m != nil {
		return m.PrimaryLock
	}
	return nil
}

func (m *PrewriteRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *PrewriteRequest) GetLockTtl() uint64 {
	if m != nil {
		return m.LockTtl
	}
	return 0
}

func (m *PrewriteRequest) GetSkipConstraintCheck() bool {
	if m != nil {
		return m.SkipConstraintCheck
	}
	return false
}

func (m *PrewriteRequest) GetPessimisticActions() []PrewriteRequest_PessimisticAction {
	if m != nil {
		return m.PessimisticActions
	}
	return nil
}

func (m *PrewriteRequest) GetTxnSize() uint64 {
	if m != nil {
		return m.TxnSize
	}
	return 0
}

func (m *PrewriteRequest) GetForUpdateTs() uint64 {
	if m != nil {
		return m.ForUpdateTs
	}
	return 0
}

func (m *PrewriteRequest) GetMinCommitTs() uint64 {
	if m != nil {
		return m.MinCommitTs
	}
	return 0
}

func (m *PrewriteRequest) GetUseAsyncCommit() bool {
	if m != nil {
		return m.UseAsyncCommit
	}
	return false
}

func (m *PrewriteRequest) GetSecondaries() [][]byte {
	if m != nil {
		return m.Secondaries
	}
	return nil
}

func (m *PrewriteRequest) GetTryOnePc() bool {
	if m != nil {
		return m.TryOnePc
	}
	return false
}

func (m *PrewriteRequest) GetMaxCommitTs() uint64 {
	if m != nil {
		return m.MaxCommitTs
	}
	return 0
}

func (m *PrewriteRequest) GetAssertionLevel() AssertionLevel {
	if m != nil {
		return m.AssertionLevel
	}
	return AssertionLevel_Off
}

func (m *PrewriteRequest) GetForUpdateTsConstraints() []*PrewriteRequest_ForUpdateTSConstraint {
	if m != nil {
		return m.ForUpdateTsConstraints
	}
	return nil
}

// for_update_ts constriants that should be checked when prewriting a pessimistic transaction.
type PrewriteRequest_ForUpdateTSConstraint struct {
	// The index of key in the prewrite request that should be checked.
	Index uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// The expected for_update_ts of the pessimistic lock of the key.
	ExpectedForUpdateTs uint64 `protobuf:"varint,2,opt,name=expected_for_update_ts,json=expectedForUpdateTs,proto3" json:"expected_for_update_ts,omitempty"`
}

func (m *PrewriteRequest_ForUpdateTSConstraint) Reset()         { *m = PrewriteRequest_ForUpdateTSConstraint{} }
func (m *PrewriteRequest_ForUpdateTSConstraint) String() string { return proto.CompactTextString(m) }
func (*PrewriteRequest_ForUpdateTSConstraint) ProtoMessage()    {}
func (*PrewriteRequest_ForUpdateTSConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{4, 0}
}

func (m *PrewriteRequest_ForUpdateTSConstraint) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PrewriteRequest_ForUpdateTSConstraint) GetExpectedForUpdateTs() uint64 {
	if m != nil {
		return m.ExpectedForUpdateTs
	}
	return 0
}

type PrewriteResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Errors      []*KeyError    `protobuf:"bytes,2,rep,name=errors" json:"errors,omitempty"`
	// 0 if the min_commit_ts is not ready or any other reason that async
	// commit cannot proceed. The client can then fallback to normal way to
	// continue committing the transaction if prewrite are all finished.
	MinCommitTs uint64 `protobuf:"varint,3,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	// When the transaction is successfully committed with 1PC protocol, this field will be set to
	// the commit ts of the transaction. Otherwise, if TiKV failed to commit it with 1PC or the
	// transaction is not 1PC, the value will be 0.
	OnePcCommitTs uint64 `protobuf:"varint,4,opt,name=one_pc_commit_ts,json=onePcCommitTs,proto3" json:"one_pc_commit_ts,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,5,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *PrewriteResponse) Reset()                    { *m = PrewriteResponse{} }
func (m *PrewriteResponse) String() string            { return proto.CompactTextString(m) }
func (*PrewriteResponse) ProtoMessage()               {}
func (*PrewriteResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{5} }

func (m *PrewriteResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *PrewriteResponse) GetErrors() []*KeyError {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *PrewriteResponse) GetMinCommitTs() uint64 {
	if m != nil {
		return m.MinCommitTs
	}
	return 0
}

func (m *PrewriteResponse) GetOnePcCommitTs() uint64 {
	if m != nil {
		return m.OnePcCommitTs
	}
	return 0
}

func (m *PrewriteResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// Lock a set of keys to prepare to write to them.
type PessimisticLockRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// In this case every `Op` of the mutations must be `PessimisticLock`.
	Mutations    []*Mutation `protobuf:"bytes,2,rep,name=mutations" json:"mutations,omitempty"`
	PrimaryLock  []byte      `protobuf:"bytes,3,opt,name=primary_lock,json=primaryLock,proto3" json:"primary_lock,omitempty"`
	StartVersion uint64      `protobuf:"varint,4,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	LockTtl      uint64      `protobuf:"varint,5,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	// Each locking command in a pessimistic transaction has its own timestamp. If locking fails, then
	// the corresponding SQL statement can be retried with a later timestamp, TiDB does not need to
	// retry the whole transaction. The name comes from the `SELECT ... FOR UPDATE` SQL statement which
	// is a locking read. Each `SELECT ... FOR UPDATE` in a transaction will be assigned its own
	// timestamp.
	ForUpdateTs uint64 `protobuf:"varint,6,opt,name=for_update_ts,json=forUpdateTs,proto3" json:"for_update_ts,omitempty"`
	// If the request is the first lock request, we don't need to detect deadlock.
	IsFirstLock bool `protobuf:"varint,7,opt,name=is_first_lock,json=isFirstLock,proto3" json:"is_first_lock,omitempty"`
	// Time to wait for lock released in milliseconds when encountering locks.
	// 0 means using default timeout in TiKV. Negative means no wait.
	WaitTimeout int64 `protobuf:"varint,8,opt,name=wait_timeout,json=waitTimeout,proto3" json:"wait_timeout,omitempty"`
	// If it is true, TiKV will acquire the pessimistic lock regardless of write conflict
	// and return the latest value. It's only supported for single mutation.
	Force bool `protobuf:"varint,9,opt,name=force,proto3" json:"force,omitempty"`
	// If it is true, TiKV will return values of the keys if no error, so TiDB can cache the values for
	// later read in the same transaction.
	// When 'force' is set to true, this field is ignored.
	ReturnValues bool `protobuf:"varint,10,opt,name=return_values,json=returnValues,proto3" json:"return_values,omitempty"`
	// If min_commit_ts > 0, this is large transaction proto, the final commit_ts
	// would be infered from min_commit_ts.
	MinCommitTs uint64 `protobuf:"varint,11,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	// If set to true, it means TiKV need to check if the key exists, and return the result in
	// the `not_founds` feild in the response. This works no matter if `return_values` is set. If
	// `return_values` is set, it simply makes no difference; otherwise, the `value` field of the
	// repsonse will be empty while the `not_founds` field still indicates the keys' existence.
	CheckExistence bool `protobuf:"varint,12,opt,name=check_existence,json=checkExistence,proto3" json:"check_existence,omitempty"`
	// TiKV lock the record only when it exists
	LockOnlyIfExists bool `protobuf:"varint,13,opt,name=lock_only_if_exists,json=lockOnlyIfExists,proto3" json:"lock_only_if_exists,omitempty"`
	// Specifies the behavior when the request is woken up after wating for lock of another transaction.
	WakeUpMode PessimisticLockWakeUpMode `protobuf:"varint,14,opt,name=wake_up_mode,json=wakeUpMode,proto3,enum=kvrpcpb.PessimisticLockWakeUpMode" json:"wake_up_mode,omitempty"`
}

func (m *PessimisticLockRequest) Reset()                    { *m = PessimisticLockRequest{} }
func (m *PessimisticLockRequest) String() string            { return proto.CompactTextString(m) }
func (*PessimisticLockRequest) ProtoMessage()               {}
func (*PessimisticLockRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{6} }

func (m *PessimisticLockRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *PessimisticLockRequest) GetMutations() []*Mutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *PessimisticLockRequest) GetPrimaryLock() []byte {
	if m != nil {
		return m.PrimaryLock
	}
	return nil
}

func (m *PessimisticLockRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *PessimisticLockRequest) GetLockTtl() uint64 {
	if m != nil {
		return m.LockTtl
	}
	return 0
}

func (m *PessimisticLockRequest) GetForUpdateTs() uint64 {
	if m != nil {
		return m.ForUpdateTs
	}
	return 0
}

func (m *PessimisticLockRequest) GetIsFirstLock() bool {
	if m != nil {
		return m.IsFirstLock
	}
	return false
}

func (m *PessimisticLockRequest) GetWaitTimeout() int64 {
	if m != nil {
		return m.WaitTimeout
	}
	return 0
}

func (m *PessimisticLockRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *PessimisticLockRequest) GetReturnValues() bool {
	if m != nil {
		return m.ReturnValues
	}
	return false
}

func (m *PessimisticLockRequest) GetMinCommitTs() uint64 {
	if m != nil {
		return m.MinCommitTs
	}
	return 0
}

func (m *PessimisticLockRequest) GetCheckExistence() bool {
	if m != nil {
		return m.CheckExistence
	}
	return false
}

func (m *PessimisticLockRequest) GetLockOnlyIfExists() bool {
	if m != nil {
		return m.LockOnlyIfExists
	}
	return false
}

func (m *PessimisticLockRequest) GetWakeUpMode() PessimisticLockWakeUpMode {
	if m != nil {
		return m.WakeUpMode
	}
	return PessimisticLockWakeUpMode_WakeUpModeNormal
}

type PessimisticLockKeyResult struct {
	Type      PessimisticLockKeyResultType `protobuf:"varint,1,opt,name=type,proto3,enum=kvrpcpb.PessimisticLockKeyResultType" json:"type,omitempty"`
	Value     []byte                       `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Existence bool                         `protobuf:"varint,3,opt,name=existence,proto3" json:"existence,omitempty"`
	// We allow a key be locked when there is write conflict (latest commit_ts > for_update_ts).
	// In this case, the key is semantically locked by a newer for_update_ts.
	// For each requested key, the field is non-zero if the key is locked with write conflict, and it
	// equals to the commit_ts of the latest version of the specified key. The for_update_ts field
	// of the lock that's actually written to TiKV will also be this value. At the same time,
	// `value` and `existence` will be returned regardless to how `return_values` and
	// `check_existence` are set.
	LockedWithConflictTs uint64 `protobuf:"varint,4,opt,name=locked_with_conflict_ts,json=lockedWithConflictTs,proto3" json:"locked_with_conflict_ts,omitempty"`
	// Hint the client that resolving lock is not needed for this lock. For `PessimisticLock`
	// requests only.
	SkipResolvingLock bool `protobuf:"varint,11,opt,name=skip_resolving_lock,json=skipResolvingLock,proto3" json:"skip_resolving_lock,omitempty"`
}

func (m *PessimisticLockKeyResult) Reset()                    { *m = PessimisticLockKeyResult{} }
func (m *PessimisticLockKeyResult) String() string            { return proto.CompactTextString(m) }
func (*PessimisticLockKeyResult) ProtoMessage()               {}
func (*PessimisticLockKeyResult) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{7} }

func (m *PessimisticLockKeyResult) GetType() PessimisticLockKeyResultType {
	if m != nil {
		return m.Type
	}
	return PessimisticLockKeyResultType_LockResultNormal
}

func (m *PessimisticLockKeyResult) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *PessimisticLockKeyResult) GetExistence() bool {
	if m != nil {
		return m.Existence
	}
	return false
}

func (m *PessimisticLockKeyResult) GetLockedWithConflictTs() uint64 {
	if m != nil {
		return m.LockedWithConflictTs
	}
	return 0
}

func (m *PessimisticLockKeyResult) GetSkipResolvingLock() bool {
	if m != nil {
		return m.SkipResolvingLock
	}
	return false
}

type PessimisticLockResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Errors      []*KeyError    `protobuf:"bytes,2,rep,name=errors" json:"errors,omitempty"`
	// It carries the latest value and its commit ts if force in PessimisticLockRequest is true.
	CommitTs uint64 `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	Value    []byte `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	// The values is set if 'return_values' is true in the request and no error.
	// If 'force' is true, this field is not used.
	// Only used when `wake_up_mode` is `WakeUpModeNormal`.
	Values [][]byte `protobuf:"bytes,5,rep,name=values" json:"values,omitempty"`
	// Indicates whether the values at the same index is correspond to an existing key.
	// In legacy TiKV, this field is not used even 'force' is false. In that case, an empty value indicates
	// two possible situations: (1) the key does not exist. (2) the key exists but the value is empty.
	// Only used when `wake_up_mode` is `WakeUpModeNormal`.
	NotFounds []bool `protobuf:"varint,6,rep,packed,name=not_founds,json=notFounds" json:"not_founds,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,7,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
	// Results of the request. Only used when `wake_up_mode` is `WakeUpModeForceLock`.
	Results []*PessimisticLockKeyResult `protobuf:"bytes,8,rep,name=results" json:"results,omitempty"`
}

func (m *PessimisticLockResponse) Reset()                    { *m = PessimisticLockResponse{} }
func (m *PessimisticLockResponse) String() string            { return proto.CompactTextString(m) }
func (*PessimisticLockResponse) ProtoMessage()               {}
func (*PessimisticLockResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{8} }

func (m *PessimisticLockResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *PessimisticLockResponse) GetErrors() []*KeyError {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *PessimisticLockResponse) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *PessimisticLockResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *PessimisticLockResponse) GetValues() [][]byte {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *PessimisticLockResponse) GetNotFounds() []bool {
	if m != nil {
		return m.NotFounds
	}
	return nil
}

func (m *PessimisticLockResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

func (m *PessimisticLockResponse) GetResults() []*PessimisticLockKeyResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// Unlock keys locked using `PessimisticLockRequest`.
type PessimisticRollbackRequest struct {
	Context      *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartVersion uint64   `protobuf:"varint,2,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	ForUpdateTs  uint64   `protobuf:"varint,3,opt,name=for_update_ts,json=forUpdateTs,proto3" json:"for_update_ts,omitempty"`
	Keys         [][]byte `protobuf:"bytes,4,rep,name=keys" json:"keys,omitempty"`
}

func (m *PessimisticRollbackRequest) Reset()         { *m = PessimisticRollbackRequest{} }
func (m *PessimisticRollbackRequest) String() string { return proto.CompactTextString(m) }
func (*PessimisticRollbackRequest) ProtoMessage()    {}
func (*PessimisticRollbackRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{9}
}

func (m *PessimisticRollbackRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *PessimisticRollbackRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *PessimisticRollbackRequest) GetForUpdateTs() uint64 {
	if m != nil {
		return m.ForUpdateTs
	}
	return 0
}

func (m *PessimisticRollbackRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

type PessimisticRollbackResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Errors      []*KeyError    `protobuf:"bytes,2,rep,name=errors" json:"errors,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,3,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *PessimisticRollbackResponse) Reset()         { *m = PessimisticRollbackResponse{} }
func (m *PessimisticRollbackResponse) String() string { return proto.CompactTextString(m) }
func (*PessimisticRollbackResponse) ProtoMessage()    {}
func (*PessimisticRollbackResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{10}
}

func (m *PessimisticRollbackResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *PessimisticRollbackResponse) GetErrors() []*KeyError {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *PessimisticRollbackResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// Used to update the lock_ttl of a psessimistic and/or large transaction to prevent it from been killed.
type TxnHeartBeatRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// The key of the lock to update.
	PrimaryLock []byte `protobuf:"bytes,2,opt,name=primary_lock,json=primaryLock,proto3" json:"primary_lock,omitempty"`
	// Start timestamp of the large transaction.
	StartVersion uint64 `protobuf:"varint,3,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// The new TTL the sender would like.
	AdviseLockTtl uint64 `protobuf:"varint,4,opt,name=advise_lock_ttl,json=adviseLockTtl,proto3" json:"advise_lock_ttl,omitempty"`
}

func (m *TxnHeartBeatRequest) Reset()                    { *m = TxnHeartBeatRequest{} }
func (m *TxnHeartBeatRequest) String() string            { return proto.CompactTextString(m) }
func (*TxnHeartBeatRequest) ProtoMessage()               {}
func (*TxnHeartBeatRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{11} }

func (m *TxnHeartBeatRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *TxnHeartBeatRequest) GetPrimaryLock() []byte {
	if m != nil {
		return m.PrimaryLock
	}
	return nil
}

func (m *TxnHeartBeatRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *TxnHeartBeatRequest) GetAdviseLockTtl() uint64 {
	if m != nil {
		return m.AdviseLockTtl
	}
	return 0
}

type TxnHeartBeatResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       *KeyError      `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// The TTL actually set on the requested lock.
	LockTtl uint64 `protobuf:"varint,3,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,4,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *TxnHeartBeatResponse) Reset()                    { *m = TxnHeartBeatResponse{} }
func (m *TxnHeartBeatResponse) String() string            { return proto.CompactTextString(m) }
func (*TxnHeartBeatResponse) ProtoMessage()               {}
func (*TxnHeartBeatResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{12} }

func (m *TxnHeartBeatResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *TxnHeartBeatResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *TxnHeartBeatResponse) GetLockTtl() uint64 {
	if m != nil {
		return m.LockTtl
	}
	return 0
}

func (m *TxnHeartBeatResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// CheckTxnStatusRequest checks the status of a transaction.
// If the transaction is rollbacked/committed, return that result.
// If the TTL of the transaction is exhausted, abort that transaction and inform the caller.
// Otherwise, returns the TTL information for the transaction.
// CheckTxnStatusRequest may also push forward the minCommitTS of a large transaction.
type CheckTxnStatusRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// Primary key and lock ts together to locate the primary lock of a transaction.
	PrimaryKey []byte `protobuf:"bytes,2,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	// Starting timestamp of the transaction being checked.
	LockTs uint64 `protobuf:"varint,3,opt,name=lock_ts,json=lockTs,proto3" json:"lock_ts,omitempty"`
	// The start timestamp of the transaction which this request is part of.
	CallerStartTs uint64 `protobuf:"varint,4,opt,name=caller_start_ts,json=callerStartTs,proto3" json:"caller_start_ts,omitempty"`
	// The client must specify the current time to TiKV using this timestamp. It is used to check TTL
	// timeouts. It may be inaccurate.
	CurrentTs uint64 `protobuf:"varint,5,opt,name=current_ts,json=currentTs,proto3" json:"current_ts,omitempty"`
	// If true, then TiKV will leave a rollback tombstone in the write CF for `primary_key`, even if
	// that key is not locked.
	RollbackIfNotExist bool `protobuf:"varint,6,opt,name=rollback_if_not_exist,json=rollbackIfNotExist,proto3" json:"rollback_if_not_exist,omitempty"`
	// This field is set to true only if the transaction is known to fall back from async commit.
	// Then, CheckTxnStatus treats the transaction as non-async-commit even if the use_async_commit
	// field in the primary lock is true.
	ForceSyncCommit bool `protobuf:"varint,7,opt,name=force_sync_commit,json=forceSyncCommit,proto3" json:"force_sync_commit,omitempty"`
	// If the check request is used to resolve or decide the transaction status for a input pessimistic
	// lock, the transaction status could not be decided if the primary lock is pessimistic too and
	// it's still uncertain.
	ResolvingPessimisticLock bool `protobuf:"varint,8,opt,name=resolving_pessimistic_lock,json=resolvingPessimisticLock,proto3" json:"resolving_pessimistic_lock,omitempty"`
	// Whether it's needed to check if the lock on the key (if any) is the primary lock.
	// This is for handling some corner cases when a pessimistic transaction changes its primary
	// (see https://github.com/pingcap/tidb/issues/42937 for details). This field is necessary
	// because the old versions of clients cannot handle some results returned from TiKV correctly.
	// For new versions, this field should always be set to true.
	VerifyIsPrimary bool `protobuf:"varint,9,opt,name=verify_is_primary,json=verifyIsPrimary,proto3" json:"verify_is_primary,omitempty"`
}

func (m *CheckTxnStatusRequest) Reset()                    { *m = CheckTxnStatusRequest{} }
func (m *CheckTxnStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckTxnStatusRequest) ProtoMessage()               {}
func (*CheckTxnStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{13} }

func (m *CheckTxnStatusRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *CheckTxnStatusRequest) GetPrimaryKey() []byte {
	if m != nil {
		return m.PrimaryKey
	}
	return nil
}

func (m *CheckTxnStatusRequest) GetLockTs() uint64 {
	if m != nil {
		return m.LockTs
	}
	return 0
}

func (m *CheckTxnStatusRequest) GetCallerStartTs() uint64 {
	if m != nil {
		return m.CallerStartTs
	}
	return 0
}

func (m *CheckTxnStatusRequest) GetCurrentTs() uint64 {
	if m != nil {
		return m.CurrentTs
	}
	return 0
}

func (m *CheckTxnStatusRequest) GetRollbackIfNotExist() bool {
	if m != nil {
		return m.RollbackIfNotExist
	}
	return false
}

func (m *CheckTxnStatusRequest) GetForceSyncCommit() bool {
	if m != nil {
		return m.ForceSyncCommit
	}
	return false
}

func (m *CheckTxnStatusRequest) GetResolvingPessimisticLock() bool {
	if m != nil {
		return m.ResolvingPessimisticLock
	}
	return false
}

func (m *CheckTxnStatusRequest) GetVerifyIsPrimary() bool {
	if m != nil {
		return m.VerifyIsPrimary
	}
	return false
}

type CheckTxnStatusResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       *KeyError      `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// Three kinds of transaction status:
	//   locked: lock_ttl > 0
	//   committed: commit_version > 0
	//   rollbacked: lock_ttl = 0 && commit_version = 0
	LockTtl       uint64 `protobuf:"varint,3,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	CommitVersion uint64 `protobuf:"varint,4,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
	// The action performed by TiKV (and why if the action is to rollback).
	Action   Action    `protobuf:"varint,5,opt,name=action,proto3,enum=kvrpcpb.Action" json:"action,omitempty"`
	LockInfo *LockInfo `protobuf:"bytes,6,opt,name=lock_info,json=lockInfo" json:"lock_info,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,7,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *CheckTxnStatusResponse) Reset()                    { *m = CheckTxnStatusResponse{} }
func (m *CheckTxnStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*CheckTxnStatusResponse) ProtoMessage()               {}
func (*CheckTxnStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{14} }

func (m *CheckTxnStatusResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *CheckTxnStatusResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CheckTxnStatusResponse) GetLockTtl() uint64 {
	if m != nil {
		return m.LockTtl
	}
	return 0
}

func (m *CheckTxnStatusResponse) GetCommitVersion() uint64 {
	if m != nil {
		return m.CommitVersion
	}
	return 0
}

func (m *CheckTxnStatusResponse) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_NoAction
}

func (m *CheckTxnStatusResponse) GetLockInfo() *LockInfo {
	if m != nil {
		return m.LockInfo
	}
	return nil
}

func (m *CheckTxnStatusResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// Part of the async commit protocol, checks for locks on all supplied keys. If a lock is missing,
// does not have a successful status, or belongs to another transaction, TiKV will leave a rollback
// tombstone for that key.
type CheckSecondaryLocksRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Keys    [][]byte `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
	// Identifies the transaction we are investigating.
	StartVersion uint64 `protobuf:"varint,3,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
}

func (m *CheckSecondaryLocksRequest) Reset()         { *m = CheckSecondaryLocksRequest{} }
func (m *CheckSecondaryLocksRequest) String() string { return proto.CompactTextString(m) }
func (*CheckSecondaryLocksRequest) ProtoMessage()    {}
func (*CheckSecondaryLocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{15}
}

func (m *CheckSecondaryLocksRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *CheckSecondaryLocksRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *CheckSecondaryLocksRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

type CheckSecondaryLocksResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       *KeyError      `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// For each key in `keys` in `CheckSecondaryLocks`, there will be a lock in
	// this list if there is a lock present and belonging to the correct transaction,
	// nil otherwise.
	Locks []*LockInfo `protobuf:"bytes,3,rep,name=locks" json:"locks,omitempty"`
	// If any of the locks have been committed, this is the commit ts used. If no
	// locks have been committed, it will be zero.
	CommitTs uint64 `protobuf:"varint,4,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,5,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *CheckSecondaryLocksResponse) Reset()         { *m = CheckSecondaryLocksResponse{} }
func (m *CheckSecondaryLocksResponse) String() string { return proto.CompactTextString(m) }
func (*CheckSecondaryLocksResponse) ProtoMessage()    {}
func (*CheckSecondaryLocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{16}
}

func (m *CheckSecondaryLocksResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *CheckSecondaryLocksResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CheckSecondaryLocksResponse) GetLocks() []*LockInfo {
	if m != nil {
		return m.Locks
	}
	return nil
}

func (m *CheckSecondaryLocksResponse) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *CheckSecondaryLocksResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// The second phase of writing to TiKV. If there are no errors or conflicts, then this request
// commits a transaction so that its data can be read by other transactions.
type CommitRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// Identifies the transaction.
	StartVersion uint64 `protobuf:"varint,2,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// All keys in the transaction (to be committed).
	Keys [][]byte `protobuf:"bytes,3,rep,name=keys" json:"keys,omitempty"`
	// Timestamp for the end of the transaction. Must be greater than `start_version`.
	CommitVersion uint64 `protobuf:"varint,4,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
}

func (m *CommitRequest) Reset()                    { *m = CommitRequest{} }
func (m *CommitRequest) String() string            { return proto.CompactTextString(m) }
func (*CommitRequest) ProtoMessage()               {}
func (*CommitRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{17} }

func (m *CommitRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *CommitRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *CommitRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *CommitRequest) GetCommitVersion() uint64 {
	if m != nil {
		return m.CommitVersion
	}
	return 0
}

type CommitResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       *KeyError      `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// If the commit ts is derived from min_commit_ts, this field should be set.
	CommitVersion uint64 `protobuf:"varint,3,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,4,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *CommitResponse) Reset()                    { *m = CommitResponse{} }
func (m *CommitResponse) String() string            { return proto.CompactTextString(m) }
func (*CommitResponse) ProtoMessage()               {}
func (*CommitResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{18} }

func (m *CommitResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *CommitResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CommitResponse) GetCommitVersion() uint64 {
	if m != nil {
		return m.CommitVersion
	}
	return 0
}

func (m *CommitResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// Not yet implemented.
type ImportRequest struct {
	Mutations     []*Mutation `protobuf:"bytes,1,rep,name=mutations" json:"mutations,omitempty"`
	CommitVersion uint64      `protobuf:"varint,2,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
}

func (m *ImportRequest) Reset()                    { *m = ImportRequest{} }
func (m *ImportRequest) String() string            { return proto.CompactTextString(m) }
func (*ImportRequest) ProtoMessage()               {}
func (*ImportRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{19} }

func (m *ImportRequest) GetMutations() []*Mutation {
	if m != nil {
		return m.Mutations
	}
	return nil
}

func (m *ImportRequest) GetCommitVersion() uint64 {
	if m != nil {
		return m.CommitVersion
	}
	return 0
}

type ImportResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ImportResponse) Reset()                    { *m = ImportResponse{} }
func (m *ImportResponse) String() string            { return proto.CompactTextString(m) }
func (*ImportResponse) ProtoMessage()               {}
func (*ImportResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{20} }

func (m *ImportResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *ImportResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Cleanup a key by possibly unlocking it.
// From 4.0 onwards, this message is no longer used.
type CleanupRequest struct {
	Context      *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Key          []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	StartVersion uint64   `protobuf:"varint,3,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// The current timestamp, used in combination with a lock's TTL to determine
	// if the lock has expired. If `current_ts == 0`, then the key will be unlocked
	// irrespective of its TTL.
	CurrentTs uint64 `protobuf:"varint,4,opt,name=current_ts,json=currentTs,proto3" json:"current_ts,omitempty"`
}

func (m *CleanupRequest) Reset()                    { *m = CleanupRequest{} }
func (m *CleanupRequest) String() string            { return proto.CompactTextString(m) }
func (*CleanupRequest) ProtoMessage()               {}
func (*CleanupRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{21} }

func (m *CleanupRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *CleanupRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *CleanupRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *CleanupRequest) GetCurrentTs() uint64 {
	if m != nil {
		return m.CurrentTs
	}
	return 0
}

type CleanupResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       *KeyError      `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// Set if the key is already committed.
	CommitVersion uint64 `protobuf:"varint,3,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
}

func (m *CleanupResponse) Reset()                    { *m = CleanupResponse{} }
func (m *CleanupResponse) String() string            { return proto.CompactTextString(m) }
func (*CleanupResponse) ProtoMessage()               {}
func (*CleanupResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{22} }

func (m *CleanupResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *CleanupResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CleanupResponse) GetCommitVersion() uint64 {
	if m != nil {
		return m.CommitVersion
	}
	return 0
}

// Similar to a `Get` request.
type BatchGetRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Keys    [][]byte `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
	Version uint64   `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *BatchGetRequest) Reset()                    { *m = BatchGetRequest{} }
func (m *BatchGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BatchGetRequest) ProtoMessage()               {}
func (*BatchGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{23} }

func (m *BatchGetRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *BatchGetRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *BatchGetRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type BatchGetResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Pairs       []*KvPair      `protobuf:"bytes,2,rep,name=pairs" json:"pairs,omitempty"`
	// Time and scan details when processing the request.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,4,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
	// This KeyError exists when some key is locked but we cannot check locks of all keys.
	// In this case, `pairs` should be empty and the client should redo batch get all the keys
	// after resolving the lock.
	Error *KeyError `protobuf:"bytes,5,opt,name=error" json:"error,omitempty"`
}

func (m *BatchGetResponse) Reset()                    { *m = BatchGetResponse{} }
func (m *BatchGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BatchGetResponse) ProtoMessage()               {}
func (*BatchGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{24} }

func (m *BatchGetResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *BatchGetResponse) GetPairs() []*KvPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func (m *BatchGetResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

func (m *BatchGetResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

// Rollback a prewritten transaction. This will remove the preliminary data from the database,
// unlock locks, and leave a rollback tombstone.
type BatchRollbackRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// Identify the transaction to be rolled back.
	StartVersion uint64 `protobuf:"varint,2,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// The keys to rollback.
	Keys [][]byte `protobuf:"bytes,3,rep,name=keys" json:"keys,omitempty"`
}

func (m *BatchRollbackRequest) Reset()                    { *m = BatchRollbackRequest{} }
func (m *BatchRollbackRequest) String() string            { return proto.CompactTextString(m) }
func (*BatchRollbackRequest) ProtoMessage()               {}
func (*BatchRollbackRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{25} }

func (m *BatchRollbackRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *BatchRollbackRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *BatchRollbackRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

type BatchRollbackResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       *KeyError      `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,3,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *BatchRollbackResponse) Reset()                    { *m = BatchRollbackResponse{} }
func (m *BatchRollbackResponse) String() string            { return proto.CompactTextString(m) }
func (*BatchRollbackResponse) ProtoMessage()               {}
func (*BatchRollbackResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{26} }

func (m *BatchRollbackResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *BatchRollbackResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *BatchRollbackResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// Scan the database for locks. Used at the start of the GC process to find all
// old locks.
type ScanLockRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// Returns all locks with a start timestamp before `max_version`.
	MaxVersion uint64 `protobuf:"varint,2,opt,name=max_version,json=maxVersion,proto3" json:"max_version,omitempty"`
	// Start scanning from this key.
	StartKey []byte `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// The maximum number of locks to return.
	Limit uint32 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	// The exclusive upperbound for scanning.
	EndKey []byte `protobuf:"bytes,5,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *ScanLockRequest) Reset()                    { *m = ScanLockRequest{} }
func (m *ScanLockRequest) String() string            { return proto.CompactTextString(m) }
func (*ScanLockRequest) ProtoMessage()               {}
func (*ScanLockRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{27} }

func (m *ScanLockRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ScanLockRequest) GetMaxVersion() uint64 {
	if m != nil {
		return m.MaxVersion
	}
	return 0
}

func (m *ScanLockRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *ScanLockRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ScanLockRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

type ScanLockResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       *KeyError      `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// Info on all locks found by the scan.
	Locks []*LockInfo `protobuf:"bytes,3,rep,name=locks" json:"locks,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,4,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *ScanLockResponse) Reset()                    { *m = ScanLockResponse{} }
func (m *ScanLockResponse) String() string            { return proto.CompactTextString(m) }
func (*ScanLockResponse) ProtoMessage()               {}
func (*ScanLockResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{28} }

func (m *ScanLockResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *ScanLockResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ScanLockResponse) GetLocks() []*LockInfo {
	if m != nil {
		return m.Locks
	}
	return nil
}

func (m *ScanLockResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// For all keys locked by the transaction identified by `start_version`, either
// commit or rollback the transaction and unlock the key.
type ResolveLockRequest struct {
	Context      *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartVersion uint64   `protobuf:"varint,2,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// `commit_version == 0` means the transaction was rolled back.
	// `commit_version > 0` means the transaction was committed at the given timestamp.
	CommitVersion uint64     `protobuf:"varint,3,opt,name=commit_version,json=commitVersion,proto3" json:"commit_version,omitempty"`
	TxnInfos      []*TxnInfo `protobuf:"bytes,4,rep,name=txn_infos,json=txnInfos" json:"txn_infos,omitempty"`
	// Only resolve specified keys.
	Keys [][]byte `protobuf:"bytes,5,rep,name=keys" json:"keys,omitempty"`
}

func (m *ResolveLockRequest) Reset()                    { *m = ResolveLockRequest{} }
func (m *ResolveLockRequest) String() string            { return proto.CompactTextString(m) }
func (*ResolveLockRequest) ProtoMessage()               {}
func (*ResolveLockRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{29} }

func (m *ResolveLockRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ResolveLockRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *ResolveLockRequest) GetCommitVersion() uint64 {
	if m != nil {
		return m.CommitVersion
	}
	return 0
}

func (m *ResolveLockRequest) GetTxnInfos() []*TxnInfo {
	if m != nil {
		return m.TxnInfos
	}
	return nil
}

func (m *ResolveLockRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

type ResolveLockResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       *KeyError      `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// Execution details about the request processing.
	ExecDetailsV2 *ExecDetailsV2 `protobuf:"bytes,3,opt,name=exec_details_v2,json=execDetailsV2" json:"exec_details_v2,omitempty"`
}

func (m *ResolveLockResponse) Reset()                    { *m = ResolveLockResponse{} }
func (m *ResolveLockResponse) String() string            { return proto.CompactTextString(m) }
func (*ResolveLockResponse) ProtoMessage()               {}
func (*ResolveLockResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{30} }

func (m *ResolveLockResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *ResolveLockResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *ResolveLockResponse) GetExecDetailsV2() *ExecDetailsV2 {
	if m != nil {
		return m.ExecDetailsV2
	}
	return nil
}

// Request TiKV to garbage collect all non-current data older than `safe_point`.
type GCRequest struct {
	Context   *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	SafePoint uint64   `protobuf:"varint,2,opt,name=safe_point,json=safePoint,proto3" json:"safe_point,omitempty"`
}

func (m *GCRequest) Reset()                    { *m = GCRequest{} }
func (m *GCRequest) String() string            { return proto.CompactTextString(m) }
func (*GCRequest) ProtoMessage()               {}
func (*GCRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{31} }

func (m *GCRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *GCRequest) GetSafePoint() uint64 {
	if m != nil {
		return m.SafePoint
	}
	return 0
}

type GCResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       *KeyError      `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *GCResponse) Reset()                    { *m = GCResponse{} }
func (m *GCResponse) String() string            { return proto.CompactTextString(m) }
func (*GCResponse) ProtoMessage()               {}
func (*GCResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{32} }

func (m *GCResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *GCResponse) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

// Delete a range of data from TiKV.
type DeleteRangeRequest struct {
	Context  *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartKey []byte   `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte   `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// If true, the data will not be immediately deleted, but the operation will
	// still be replicated via Raft. This is used to notify TiKV that the data
	// will be deleted using `unsafe_destroy_range` soon.
	NotifyOnly bool `protobuf:"varint,4,opt,name=notify_only,json=notifyOnly,proto3" json:"notify_only,omitempty"`
}

func (m *DeleteRangeRequest) Reset()                    { *m = DeleteRangeRequest{} }
func (m *DeleteRangeRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRangeRequest) ProtoMessage()               {}
func (*DeleteRangeRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{33} }

func (m *DeleteRangeRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DeleteRangeRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *DeleteRangeRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *DeleteRangeRequest) GetNotifyOnly() bool {
	if m != nil {
		return m.NotifyOnly
	}
	return false
}

type DeleteRangeResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *DeleteRangeResponse) Reset()                    { *m = DeleteRangeResponse{} }
func (m *DeleteRangeResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteRangeResponse) ProtoMessage()               {}
func (*DeleteRangeResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{34} }

func (m *DeleteRangeResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *DeleteRangeResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Preparing the flashback for a region/key range will "lock" the region
// so that there is no any read, write or schedule operation could be proposed before
// the actual flashback operation.
type PrepareFlashbackToVersionRequest struct {
	Context  *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartKey []byte   `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte   `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// The `start_ts` which we will use to write a lock to prevent
	// the `resolved_ts` from advancing during the whole process.
	StartTs uint64 `protobuf:"varint,4,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	// The TS version which the data will flashback to later.
	Version uint64 `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *PrepareFlashbackToVersionRequest) Reset()         { *m = PrepareFlashbackToVersionRequest{} }
func (m *PrepareFlashbackToVersionRequest) String() string { return proto.CompactTextString(m) }
func (*PrepareFlashbackToVersionRequest) ProtoMessage()    {}
func (*PrepareFlashbackToVersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{35}
}

func (m *PrepareFlashbackToVersionRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *PrepareFlashbackToVersionRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *PrepareFlashbackToVersionRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *PrepareFlashbackToVersionRequest) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *PrepareFlashbackToVersionRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type PrepareFlashbackToVersionResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *PrepareFlashbackToVersionResponse) Reset()         { *m = PrepareFlashbackToVersionResponse{} }
func (m *PrepareFlashbackToVersionResponse) String() string { return proto.CompactTextString(m) }
func (*PrepareFlashbackToVersionResponse) ProtoMessage()    {}
func (*PrepareFlashbackToVersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{36}
}

func (m *PrepareFlashbackToVersionResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *PrepareFlashbackToVersionResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Flashback the region to a specific point with the given `version`, please
// make sure the region is "locked" by `PrepareFlashbackToVersionRequest` first,
// otherwise this request will fail.
type FlashbackToVersionRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// The TS version which the data should flashback to.
	Version  uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	StartKey []byte `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,4,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// The `start_ts` and `commit_ts` which the newly written MVCC version will use.
	// Please make sure the `start_ts` is the same one in `PrepareFlashbackToVersionRequest`.
	StartTs  uint64 `protobuf:"varint,5,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs uint64 `protobuf:"varint,6,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
}

func (m *FlashbackToVersionRequest) Reset()         { *m = FlashbackToVersionRequest{} }
func (m *FlashbackToVersionRequest) String() string { return proto.CompactTextString(m) }
func (*FlashbackToVersionRequest) ProtoMessage()    {}
func (*FlashbackToVersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{37}
}

func (m *FlashbackToVersionRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *FlashbackToVersionRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *FlashbackToVersionRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *FlashbackToVersionRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *FlashbackToVersionRequest) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *FlashbackToVersionRequest) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type FlashbackToVersionResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *FlashbackToVersionResponse) Reset()         { *m = FlashbackToVersionResponse{} }
func (m *FlashbackToVersionResponse) String() string { return proto.CompactTextString(m) }
func (*FlashbackToVersionResponse) ProtoMessage()    {}
func (*FlashbackToVersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{38}
}

func (m *FlashbackToVersionResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *FlashbackToVersionResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type RawGetRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Key     []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Cf      string   `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
}

func (m *RawGetRequest) Reset()                    { *m = RawGetRequest{} }
func (m *RawGetRequest) String() string            { return proto.CompactTextString(m) }
func (*RawGetRequest) ProtoMessage()               {}
func (*RawGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{39} }

func (m *RawGetRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawGetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RawGetRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

type RawGetResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Value       []byte         `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	NotFound    bool           `protobuf:"varint,4,opt,name=not_found,json=notFound,proto3" json:"not_found,omitempty"`
}

func (m *RawGetResponse) Reset()                    { *m = RawGetResponse{} }
func (m *RawGetResponse) String() string            { return proto.CompactTextString(m) }
func (*RawGetResponse) ProtoMessage()               {}
func (*RawGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{40} }

func (m *RawGetResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawGetResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RawGetResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RawGetResponse) GetNotFound() bool {
	if m != nil {
		return m.NotFound
	}
	return false
}

type RawBatchGetRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Keys    [][]byte `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
	Cf      string   `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
}

func (m *RawBatchGetRequest) Reset()                    { *m = RawBatchGetRequest{} }
func (m *RawBatchGetRequest) String() string            { return proto.CompactTextString(m) }
func (*RawBatchGetRequest) ProtoMessage()               {}
func (*RawBatchGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{41} }

func (m *RawBatchGetRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawBatchGetRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *RawBatchGetRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

type RawBatchGetResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Pairs       []*KvPair      `protobuf:"bytes,2,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *RawBatchGetResponse) Reset()                    { *m = RawBatchGetResponse{} }
func (m *RawBatchGetResponse) String() string            { return proto.CompactTextString(m) }
func (*RawBatchGetResponse) ProtoMessage()               {}
func (*RawBatchGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{42} }

func (m *RawBatchGetResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawBatchGetResponse) GetPairs() []*KvPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type RawPutRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Key     []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value   []byte   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Cf      string   `protobuf:"bytes,4,opt,name=cf,proto3" json:"cf,omitempty"`
	Ttl     uint64   `protobuf:"varint,5,opt,name=ttl,proto3" json:"ttl,omitempty"`
	ForCas  bool     `protobuf:"varint,6,opt,name=for_cas,json=forCas,proto3" json:"for_cas,omitempty"`
}

func (m *RawPutRequest) Reset()                    { *m = RawPutRequest{} }
func (m *RawPutRequest) String() string            { return proto.CompactTextString(m) }
func (*RawPutRequest) ProtoMessage()               {}
func (*RawPutRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{43} }

func (m *RawPutRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawPutRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RawPutRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RawPutRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *RawPutRequest) GetTtl() uint64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *RawPutRequest) GetForCas() bool {
	if m != nil {
		return m.ForCas
	}
	return false
}

type RawPutResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RawPutResponse) Reset()                    { *m = RawPutResponse{} }
func (m *RawPutResponse) String() string            { return proto.CompactTextString(m) }
func (*RawPutResponse) ProtoMessage()               {}
func (*RawPutResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{44} }

func (m *RawPutResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawPutResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type RawBatchPutRequest struct {
	Context *Context  `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Pairs   []*KvPair `protobuf:"bytes,2,rep,name=pairs" json:"pairs,omitempty"`
	Cf      string    `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	Ttl     uint64    `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
	ForCas  bool      `protobuf:"varint,5,opt,name=for_cas,json=forCas,proto3" json:"for_cas,omitempty"`
	// The time-to-live for each keys in seconds, and if the length of `ttls`
	// is exactly one, the ttl will be applied to all keys. Otherwise, the length
	// mismatch between `ttls` and `pairs` will return an error.
	Ttls []uint64 `protobuf:"varint,6,rep,packed,name=ttls" json:"ttls,omitempty"`
}

func (m *RawBatchPutRequest) Reset()                    { *m = RawBatchPutRequest{} }
func (m *RawBatchPutRequest) String() string            { return proto.CompactTextString(m) }
func (*RawBatchPutRequest) ProtoMessage()               {}
func (*RawBatchPutRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{45} }

func (m *RawBatchPutRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawBatchPutRequest) GetPairs() []*KvPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func (m *RawBatchPutRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *RawBatchPutRequest) GetTtl() uint64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *RawBatchPutRequest) GetForCas() bool {
	if m != nil {
		return m.ForCas
	}
	return false
}

func (m *RawBatchPutRequest) GetTtls() []uint64 {
	if m != nil {
		return m.Ttls
	}
	return nil
}

type RawBatchPutResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RawBatchPutResponse) Reset()                    { *m = RawBatchPutResponse{} }
func (m *RawBatchPutResponse) String() string            { return proto.CompactTextString(m) }
func (*RawBatchPutResponse) ProtoMessage()               {}
func (*RawBatchPutResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{46} }

func (m *RawBatchPutResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawBatchPutResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type RawDeleteRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Key     []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Cf      string   `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	ForCas  bool     `protobuf:"varint,4,opt,name=for_cas,json=forCas,proto3" json:"for_cas,omitempty"`
}

func (m *RawDeleteRequest) Reset()                    { *m = RawDeleteRequest{} }
func (m *RawDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*RawDeleteRequest) ProtoMessage()               {}
func (*RawDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{47} }

func (m *RawDeleteRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawDeleteRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RawDeleteRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *RawDeleteRequest) GetForCas() bool {
	if m != nil {
		return m.ForCas
	}
	return false
}

type RawDeleteResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RawDeleteResponse) Reset()                    { *m = RawDeleteResponse{} }
func (m *RawDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*RawDeleteResponse) ProtoMessage()               {}
func (*RawDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{48} }

func (m *RawDeleteResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawDeleteResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type RawBatchDeleteRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Keys    [][]byte `protobuf:"bytes,2,rep,name=keys" json:"keys,omitempty"`
	Cf      string   `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
	ForCas  bool     `protobuf:"varint,4,opt,name=for_cas,json=forCas,proto3" json:"for_cas,omitempty"`
}

func (m *RawBatchDeleteRequest) Reset()                    { *m = RawBatchDeleteRequest{} }
func (m *RawBatchDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*RawBatchDeleteRequest) ProtoMessage()               {}
func (*RawBatchDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{49} }

func (m *RawBatchDeleteRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawBatchDeleteRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *RawBatchDeleteRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *RawBatchDeleteRequest) GetForCas() bool {
	if m != nil {
		return m.ForCas
	}
	return false
}

type RawBatchDeleteResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RawBatchDeleteResponse) Reset()                    { *m = RawBatchDeleteResponse{} }
func (m *RawBatchDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*RawBatchDeleteResponse) ProtoMessage()               {}
func (*RawBatchDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{50} }

func (m *RawBatchDeleteResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawBatchDeleteResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type RawScanRequest struct {
	Context  *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartKey []byte   `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	Limit    uint32   `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	KeyOnly  bool     `protobuf:"varint,4,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	Cf       string   `protobuf:"bytes,5,opt,name=cf,proto3" json:"cf,omitempty"`
	Reverse  bool     `protobuf:"varint,6,opt,name=reverse,proto3" json:"reverse,omitempty"`
	// For compatibility, when scanning forward, the range to scan is [start_key, end_key), where start_key < end_key;
	// and when scanning backward, it scans [end_key, start_key) in descending order, where end_key < start_key.
	EndKey []byte `protobuf:"bytes,7,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *RawScanRequest) Reset()                    { *m = RawScanRequest{} }
func (m *RawScanRequest) String() string            { return proto.CompactTextString(m) }
func (*RawScanRequest) ProtoMessage()               {}
func (*RawScanRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{51} }

func (m *RawScanRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawScanRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *RawScanRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RawScanRequest) GetKeyOnly() bool {
	if m != nil {
		return m.KeyOnly
	}
	return false
}

func (m *RawScanRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *RawScanRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

func (m *RawScanRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

type RawScanResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Kvs         []*KvPair      `protobuf:"bytes,2,rep,name=kvs" json:"kvs,omitempty"`
}

func (m *RawScanResponse) Reset()                    { *m = RawScanResponse{} }
func (m *RawScanResponse) String() string            { return proto.CompactTextString(m) }
func (*RawScanResponse) ProtoMessage()               {}
func (*RawScanResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{52} }

func (m *RawScanResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawScanResponse) GetKvs() []*KvPair {
	if m != nil {
		return m.Kvs
	}
	return nil
}

type RawDeleteRangeRequest struct {
	Context  *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartKey []byte   `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte   `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Cf       string   `protobuf:"bytes,4,opt,name=cf,proto3" json:"cf,omitempty"`
}

func (m *RawDeleteRangeRequest) Reset()                    { *m = RawDeleteRangeRequest{} }
func (m *RawDeleteRangeRequest) String() string            { return proto.CompactTextString(m) }
func (*RawDeleteRangeRequest) ProtoMessage()               {}
func (*RawDeleteRangeRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{53} }

func (m *RawDeleteRangeRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawDeleteRangeRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *RawDeleteRangeRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *RawDeleteRangeRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

type RawDeleteRangeResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RawDeleteRangeResponse) Reset()                    { *m = RawDeleteRangeResponse{} }
func (m *RawDeleteRangeResponse) String() string            { return proto.CompactTextString(m) }
func (*RawDeleteRangeResponse) ProtoMessage()               {}
func (*RawDeleteRangeResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{54} }

func (m *RawDeleteRangeResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawDeleteRangeResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type RawBatchScanRequest struct {
	Context   *Context    `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Ranges    []*KeyRange `protobuf:"bytes,2,rep,name=ranges" json:"ranges,omitempty"`
	EachLimit uint32      `protobuf:"varint,3,opt,name=each_limit,json=eachLimit,proto3" json:"each_limit,omitempty"`
	KeyOnly   bool        `protobuf:"varint,4,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	Cf        string      `protobuf:"bytes,5,opt,name=cf,proto3" json:"cf,omitempty"`
	Reverse   bool        `protobuf:"varint,6,opt,name=reverse,proto3" json:"reverse,omitempty"`
}

func (m *RawBatchScanRequest) Reset()                    { *m = RawBatchScanRequest{} }
func (m *RawBatchScanRequest) String() string            { return proto.CompactTextString(m) }
func (*RawBatchScanRequest) ProtoMessage()               {}
func (*RawBatchScanRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{55} }

func (m *RawBatchScanRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawBatchScanRequest) GetRanges() []*KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *RawBatchScanRequest) GetEachLimit() uint32 {
	if m != nil {
		return m.EachLimit
	}
	return 0
}

func (m *RawBatchScanRequest) GetKeyOnly() bool {
	if m != nil {
		return m.KeyOnly
	}
	return false
}

func (m *RawBatchScanRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *RawBatchScanRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

type RawBatchScanResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Kvs         []*KvPair      `protobuf:"bytes,2,rep,name=kvs" json:"kvs,omitempty"`
}

func (m *RawBatchScanResponse) Reset()                    { *m = RawBatchScanResponse{} }
func (m *RawBatchScanResponse) String() string            { return proto.CompactTextString(m) }
func (*RawBatchScanResponse) ProtoMessage()               {}
func (*RawBatchScanResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{56} }

func (m *RawBatchScanResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawBatchScanResponse) GetKvs() []*KvPair {
	if m != nil {
		return m.Kvs
	}
	return nil
}

type UnsafeDestroyRangeRequest struct {
	Context  *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartKey []byte   `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte   `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *UnsafeDestroyRangeRequest) Reset()         { *m = UnsafeDestroyRangeRequest{} }
func (m *UnsafeDestroyRangeRequest) String() string { return proto.CompactTextString(m) }
func (*UnsafeDestroyRangeRequest) ProtoMessage()    {}
func (*UnsafeDestroyRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{57}
}

func (m *UnsafeDestroyRangeRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *UnsafeDestroyRangeRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *UnsafeDestroyRangeRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

type UnsafeDestroyRangeResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *UnsafeDestroyRangeResponse) Reset()         { *m = UnsafeDestroyRangeResponse{} }
func (m *UnsafeDestroyRangeResponse) String() string { return proto.CompactTextString(m) }
func (*UnsafeDestroyRangeResponse) ProtoMessage()    {}
func (*UnsafeDestroyRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{58}
}

func (m *UnsafeDestroyRangeResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *UnsafeDestroyRangeResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type RegisterLockObserverRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	MaxTs   uint64   `protobuf:"varint,2,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
}

func (m *RegisterLockObserverRequest) Reset()         { *m = RegisterLockObserverRequest{} }
func (m *RegisterLockObserverRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterLockObserverRequest) ProtoMessage()    {}
func (*RegisterLockObserverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{59}
}

func (m *RegisterLockObserverRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RegisterLockObserverRequest) GetMaxTs() uint64 {
	if m != nil {
		return m.MaxTs
	}
	return 0
}

type RegisterLockObserverResponse struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RegisterLockObserverResponse) Reset()         { *m = RegisterLockObserverResponse{} }
func (m *RegisterLockObserverResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterLockObserverResponse) ProtoMessage()    {}
func (*RegisterLockObserverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{60}
}

func (m *RegisterLockObserverResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type CheckLockObserverRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	MaxTs   uint64   `protobuf:"varint,2,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
}

func (m *CheckLockObserverRequest) Reset()         { *m = CheckLockObserverRequest{} }
func (m *CheckLockObserverRequest) String() string { return proto.CompactTextString(m) }
func (*CheckLockObserverRequest) ProtoMessage()    {}
func (*CheckLockObserverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{61}
}

func (m *CheckLockObserverRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *CheckLockObserverRequest) GetMaxTs() uint64 {
	if m != nil {
		return m.MaxTs
	}
	return 0
}

type CheckLockObserverResponse struct {
	Error   string      `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	IsClean bool        `protobuf:"varint,2,opt,name=is_clean,json=isClean,proto3" json:"is_clean,omitempty"`
	Locks   []*LockInfo `protobuf:"bytes,3,rep,name=locks" json:"locks,omitempty"`
}

func (m *CheckLockObserverResponse) Reset()         { *m = CheckLockObserverResponse{} }
func (m *CheckLockObserverResponse) String() string { return proto.CompactTextString(m) }
func (*CheckLockObserverResponse) ProtoMessage()    {}
func (*CheckLockObserverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{62}
}

func (m *CheckLockObserverResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *CheckLockObserverResponse) GetIsClean() bool {
	if m != nil {
		return m.IsClean
	}
	return false
}

func (m *CheckLockObserverResponse) GetLocks() []*LockInfo {
	if m != nil {
		return m.Locks
	}
	return nil
}

type RemoveLockObserverRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	MaxTs   uint64   `protobuf:"varint,2,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
}

func (m *RemoveLockObserverRequest) Reset()         { *m = RemoveLockObserverRequest{} }
func (m *RemoveLockObserverRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveLockObserverRequest) ProtoMessage()    {}
func (*RemoveLockObserverRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{63}
}

func (m *RemoveLockObserverRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RemoveLockObserverRequest) GetMaxTs() uint64 {
	if m != nil {
		return m.MaxTs
	}
	return 0
}

type RemoveLockObserverResponse struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RemoveLockObserverResponse) Reset()         { *m = RemoveLockObserverResponse{} }
func (m *RemoveLockObserverResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveLockObserverResponse) ProtoMessage()    {}
func (*RemoveLockObserverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{64}
}

func (m *RemoveLockObserverResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type PhysicalScanLockRequest struct {
	Context  *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	MaxTs    uint64   `protobuf:"varint,2,opt,name=max_ts,json=maxTs,proto3" json:"max_ts,omitempty"`
	StartKey []byte   `protobuf:"bytes,3,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	Limit    uint32   `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *PhysicalScanLockRequest) Reset()                    { *m = PhysicalScanLockRequest{} }
func (m *PhysicalScanLockRequest) String() string            { return proto.CompactTextString(m) }
func (*PhysicalScanLockRequest) ProtoMessage()               {}
func (*PhysicalScanLockRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{65} }

func (m *PhysicalScanLockRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *PhysicalScanLockRequest) GetMaxTs() uint64 {
	if m != nil {
		return m.MaxTs
	}
	return 0
}

func (m *PhysicalScanLockRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *PhysicalScanLockRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type PhysicalScanLockResponse struct {
	Error string      `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Locks []*LockInfo `protobuf:"bytes,2,rep,name=locks" json:"locks,omitempty"`
}

func (m *PhysicalScanLockResponse) Reset()         { *m = PhysicalScanLockResponse{} }
func (m *PhysicalScanLockResponse) String() string { return proto.CompactTextString(m) }
func (*PhysicalScanLockResponse) ProtoMessage()    {}
func (*PhysicalScanLockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{66}
}

func (m *PhysicalScanLockResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *PhysicalScanLockResponse) GetLocks() []*LockInfo {
	if m != nil {
		return m.Locks
	}
	return nil
}

// Sent from PD to a TiKV node.
type SplitRegionRequest struct {
	Context   *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	SplitKey  []byte   `protobuf:"bytes,2,opt,name=split_key,json=splitKey,proto3" json:"split_key,omitempty"`
	SplitKeys [][]byte `protobuf:"bytes,3,rep,name=split_keys,json=splitKeys" json:"split_keys,omitempty"`
	// Once enabled, the split_key will not be encoded.
	IsRawKv bool `protobuf:"varint,4,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
}

func (m *SplitRegionRequest) Reset()                    { *m = SplitRegionRequest{} }
func (m *SplitRegionRequest) String() string            { return proto.CompactTextString(m) }
func (*SplitRegionRequest) ProtoMessage()               {}
func (*SplitRegionRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{67} }

func (m *SplitRegionRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *SplitRegionRequest) GetSplitKey() []byte {
	if m != nil {
		return m.SplitKey
	}
	return nil
}

func (m *SplitRegionRequest) GetSplitKeys() [][]byte {
	if m != nil {
		return m.SplitKeys
	}
	return nil
}

func (m *SplitRegionRequest) GetIsRawKv() bool {
	if m != nil {
		return m.IsRawKv
	}
	return false
}

type SplitRegionResponse struct {
	RegionError *errorpb.Error   `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Left        *metapb.Region   `protobuf:"bytes,2,opt,name=left" json:"left,omitempty"`
	Right       *metapb.Region   `protobuf:"bytes,3,opt,name=right" json:"right,omitempty"`
	Regions     []*metapb.Region `protobuf:"bytes,4,rep,name=regions" json:"regions,omitempty"`
}

func (m *SplitRegionResponse) Reset()                    { *m = SplitRegionResponse{} }
func (m *SplitRegionResponse) String() string            { return proto.CompactTextString(m) }
func (*SplitRegionResponse) ProtoMessage()               {}
func (*SplitRegionResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{68} }

func (m *SplitRegionResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *SplitRegionResponse) GetLeft() *metapb.Region {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *SplitRegionResponse) GetRight() *metapb.Region {
	if m != nil {
		return m.Right
	}
	return nil
}

func (m *SplitRegionResponse) GetRegions() []*metapb.Region {
	if m != nil {
		return m.Regions
	}
	return nil
}

// Sent from TiFlash to a TiKV node.
type ReadIndexRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// TiKV checks the given range if there is any unapplied lock
	// blocking the read request.
	StartTs uint64      `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Ranges  []*KeyRange `protobuf:"bytes,3,rep,name=ranges" json:"ranges,omitempty"`
}

func (m *ReadIndexRequest) Reset()                    { *m = ReadIndexRequest{} }
func (m *ReadIndexRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadIndexRequest) ProtoMessage()               {}
func (*ReadIndexRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{69} }

func (m *ReadIndexRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ReadIndexRequest) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *ReadIndexRequest) GetRanges() []*KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

type ReadIndexResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	ReadIndex   uint64         `protobuf:"varint,2,opt,name=read_index,json=readIndex,proto3" json:"read_index,omitempty"`
	// If `locked` is set, this read request is blocked by a lock.
	// The lock should be returned to the client.
	Locked *LockInfo `protobuf:"bytes,3,opt,name=locked" json:"locked,omitempty"`
}

func (m *ReadIndexResponse) Reset()                    { *m = ReadIndexResponse{} }
func (m *ReadIndexResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadIndexResponse) ProtoMessage()               {}
func (*ReadIndexResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{70} }

func (m *ReadIndexResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *ReadIndexResponse) GetReadIndex() uint64 {
	if m != nil {
		return m.ReadIndex
	}
	return 0
}

func (m *ReadIndexResponse) GetLocked() *LockInfo {
	if m != nil {
		return m.Locked
	}
	return nil
}

type MvccGetByKeyRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Key     []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *MvccGetByKeyRequest) Reset()                    { *m = MvccGetByKeyRequest{} }
func (m *MvccGetByKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*MvccGetByKeyRequest) ProtoMessage()               {}
func (*MvccGetByKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{71} }

func (m *MvccGetByKeyRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *MvccGetByKeyRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type MvccGetByKeyResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Info        *MvccInfo      `protobuf:"bytes,3,opt,name=info" json:"info,omitempty"`
}

func (m *MvccGetByKeyResponse) Reset()                    { *m = MvccGetByKeyResponse{} }
func (m *MvccGetByKeyResponse) String() string            { return proto.CompactTextString(m) }
func (*MvccGetByKeyResponse) ProtoMessage()               {}
func (*MvccGetByKeyResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{72} }

func (m *MvccGetByKeyResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *MvccGetByKeyResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *MvccGetByKeyResponse) GetInfo() *MvccInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type MvccGetByStartTsRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartTs uint64   `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
}

func (m *MvccGetByStartTsRequest) Reset()                    { *m = MvccGetByStartTsRequest{} }
func (m *MvccGetByStartTsRequest) String() string            { return proto.CompactTextString(m) }
func (*MvccGetByStartTsRequest) ProtoMessage()               {}
func (*MvccGetByStartTsRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{73} }

func (m *MvccGetByStartTsRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *MvccGetByStartTsRequest) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

type MvccGetByStartTsResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Key         []byte         `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Info        *MvccInfo      `protobuf:"bytes,4,opt,name=info" json:"info,omitempty"`
}

func (m *MvccGetByStartTsResponse) Reset()         { *m = MvccGetByStartTsResponse{} }
func (m *MvccGetByStartTsResponse) String() string { return proto.CompactTextString(m) }
func (*MvccGetByStartTsResponse) ProtoMessage()    {}
func (*MvccGetByStartTsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{74}
}

func (m *MvccGetByStartTsResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *MvccGetByStartTsResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *MvccGetByStartTsResponse) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *MvccGetByStartTsResponse) GetInfo() *MvccInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// Miscellaneous metadata attached to most requests.
type Context struct {
	RegionId       uint64              `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	RegionEpoch    *metapb.RegionEpoch `protobuf:"bytes,2,opt,name=region_epoch,json=regionEpoch" json:"region_epoch,omitempty"`
	Peer           *metapb.Peer        `protobuf:"bytes,3,opt,name=peer" json:"peer,omitempty"`
	Term           uint64              `protobuf:"varint,5,opt,name=term,proto3" json:"term,omitempty"`
	Priority       CommandPri          `protobuf:"varint,6,opt,name=priority,proto3,enum=kvrpcpb.CommandPri" json:"priority,omitempty"`
	IsolationLevel IsolationLevel      `protobuf:"varint,7,opt,name=isolation_level,json=isolationLevel,proto3,enum=kvrpcpb.IsolationLevel" json:"isolation_level,omitempty"`
	NotFillCache   bool                `protobuf:"varint,8,opt,name=not_fill_cache,json=notFillCache,proto3" json:"not_fill_cache,omitempty"`
	SyncLog        bool                `protobuf:"varint,9,opt,name=sync_log,json=syncLog,proto3" json:"sync_log,omitempty"`
	// True means execution time statistics should be recorded and returned.
	RecordTimeStat bool `protobuf:"varint,10,opt,name=record_time_stat,json=recordTimeStat,proto3" json:"record_time_stat,omitempty"`
	// True means RocksDB scan statistics should be recorded and returned.
	RecordScanStat bool `protobuf:"varint,11,opt,name=record_scan_stat,json=recordScanStat,proto3" json:"record_scan_stat,omitempty"`
	ReplicaRead    bool `protobuf:"varint,12,opt,name=replica_read,json=replicaRead,proto3" json:"replica_read,omitempty"`
	// Read requests can ignore locks belonging to these transactions because either
	// these transactions are rolled back or theirs commit_ts > read request's start_ts.
	ResolvedLocks          []uint64 `protobuf:"varint,13,rep,packed,name=resolved_locks,json=resolvedLocks" json:"resolved_locks,omitempty"`
	MaxExecutionDurationMs uint64   `protobuf:"varint,14,opt,name=max_execution_duration_ms,json=maxExecutionDurationMs,proto3" json:"max_execution_duration_ms,omitempty"`
	// After a region applies to `applied_index`, we can get a
	// snapshot for the region even if the peer is a follower.
	AppliedIndex uint64 `protobuf:"varint,15,opt,name=applied_index,json=appliedIndex,proto3" json:"applied_index,omitempty"`
	// A hint for TiKV to schedule tasks more fairly. Query with same task ID
	// may share same priority and resource quota.
	TaskId uint64 `protobuf:"varint,16,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// Not required to read the most up-to-date data, replicas with `safe_ts` >= `start_ts`
	// can handle read request directly
	StaleRead bool `protobuf:"varint,17,opt,name=stale_read,json=staleRead,proto3" json:"stale_read,omitempty"`
	// Any additional serialized information about the request.
	ResourceGroupTag []byte `protobuf:"bytes,18,opt,name=resource_group_tag,json=resourceGroupTag,proto3" json:"resource_group_tag,omitempty"`
	// Used to tell TiKV whether operations are allowed or not on different disk usages.
	DiskFullOpt DiskFullOpt `protobuf:"varint,19,opt,name=disk_full_opt,json=diskFullOpt,proto3,enum=kvrpcpb.DiskFullOpt" json:"disk_full_opt,omitempty"`
	// Indicates the request is a retry request and the same request may have been sent before.
	IsRetryRequest bool `protobuf:"varint,20,opt,name=is_retry_request,json=isRetryRequest,proto3" json:"is_retry_request,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion APIVersion `protobuf:"varint,21,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// Read request should read through locks belonging to these transactions because these
	// transactions are committed and theirs commit_ts <= read request's start_ts.
	CommittedLocks []uint64 `protobuf:"varint,22,rep,packed,name=committed_locks,json=committedLocks" json:"committed_locks,omitempty"`
	// The informantion to trace a request sent to TiKV.
	TraceContext *tracepb.TraceContext `protobuf:"bytes,23,opt,name=trace_context,json=traceContext" json:"trace_context,omitempty"`
	// The source of the request, will be used as the tag of the metrics reporting.
	// This field can be set for any requests that require to report metrics with any extra labels.
	RequestSource string `protobuf:"bytes,24,opt,name=request_source,json=requestSource,proto3" json:"request_source,omitempty"`
	// The source of the current transaction.
	TxnSource uint64 `protobuf:"varint,25,opt,name=txn_source,json=txnSource,proto3" json:"txn_source,omitempty"`
	// If `busy_threshold_ms` is given, TiKV can reject the request and return a `ServerIsBusy`
	// error before processing if the estimated waiting duration exceeds the threshold.
	BusyThresholdMs uint32 `protobuf:"varint,27,opt,name=busy_threshold_ms,json=busyThresholdMs,proto3" json:"busy_threshold_ms,omitempty"`
	// Some information used for resource control.
	ResourceControlContext *ResourceControlContext `protobuf:"bytes,28,opt,name=resource_control_context,json=resourceControlContext" json:"resource_control_context,omitempty"`
	// The keyspace that the request is sent to.
	// NOTE: This field is only meaningful while the api_version is V2.
	KeyspaceId uint32 `protobuf:"varint,32,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
	// The buckets version that the request is sent to.
	// NOTE: This field is only meaningful while enable buckets.
	BucketsVersion uint64 `protobuf:"varint,33,opt,name=buckets_version,json=bucketsVersion,proto3" json:"buckets_version,omitempty"`
	// It tells us where the request comes from in TiDB. If it isn't from TiDB, leave it blank.
	// This is for tests only and thus can be safely changed/removed without affecting compatibility.
	SourceStmt *SourceStmt `protobuf:"bytes,34,opt,name=source_stmt,json=sourceStmt" json:"source_stmt,omitempty"`
}

func (m *Context) Reset()                    { *m = Context{} }
func (m *Context) String() string            { return proto.CompactTextString(m) }
func (*Context) ProtoMessage()               {}
func (*Context) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{75} }

func (m *Context) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *Context) GetRegionEpoch() *metapb.RegionEpoch {
	if m != nil {
		return m.RegionEpoch
	}
	return nil
}

func (m *Context) GetPeer() *metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Context) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Context) GetPriority() CommandPri {
	if m != nil {
		return m.Priority
	}
	return CommandPri_Normal
}

func (m *Context) GetIsolationLevel() IsolationLevel {
	if m != nil {
		return m.IsolationLevel
	}
	return IsolationLevel_SI
}

func (m *Context) GetNotFillCache() bool {
	if m != nil {
		return m.NotFillCache
	}
	return false
}

func (m *Context) GetSyncLog() bool {
	if m != nil {
		return m.SyncLog
	}
	return false
}

func (m *Context) GetRecordTimeStat() bool {
	if m != nil {
		return m.RecordTimeStat
	}
	return false
}

func (m *Context) GetRecordScanStat() bool {
	if m != nil {
		return m.RecordScanStat
	}
	return false
}

func (m *Context) GetReplicaRead() bool {
	if m != nil {
		return m.ReplicaRead
	}
	return false
}

func (m *Context) GetResolvedLocks() []uint64 {
	if m != nil {
		return m.ResolvedLocks
	}
	return nil
}

func (m *Context) GetMaxExecutionDurationMs() uint64 {
	if m != nil {
		return m.MaxExecutionDurationMs
	}
	return 0
}

func (m *Context) GetAppliedIndex() uint64 {
	if m != nil {
		return m.AppliedIndex
	}
	return 0
}

func (m *Context) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *Context) GetStaleRead() bool {
	if m != nil {
		return m.StaleRead
	}
	return false
}

func (m *Context) GetResourceGroupTag() []byte {
	if m != nil {
		return m.ResourceGroupTag
	}
	return nil
}

func (m *Context) GetDiskFullOpt() DiskFullOpt {
	if m != nil {
		return m.DiskFullOpt
	}
	return DiskFullOpt_NotAllowedOnFull
}

func (m *Context) GetIsRetryRequest() bool {
	if m != nil {
		return m.IsRetryRequest
	}
	return false
}

func (m *Context) GetApiVersion() APIVersion {
	if m != nil {
		return m.ApiVersion
	}
	return APIVersion_V1
}

func (m *Context) GetCommittedLocks() []uint64 {
	if m != nil {
		return m.CommittedLocks
	}
	return nil
}

func (m *Context) GetTraceContext() *tracepb.TraceContext {
	if m != nil {
		return m.TraceContext
	}
	return nil
}

func (m *Context) GetRequestSource() string {
	if m != nil {
		return m.RequestSource
	}
	return ""
}

func (m *Context) GetTxnSource() uint64 {
	if m != nil {
		return m.TxnSource
	}
	return 0
}

func (m *Context) GetBusyThresholdMs() uint32 {
	if m != nil {
		return m.BusyThresholdMs
	}
	return 0
}

func (m *Context) GetResourceControlContext() *ResourceControlContext {
	if m != nil {
		return m.ResourceControlContext
	}
	return nil
}

func (m *Context) GetKeyspaceId() uint32 {
	if m != nil {
		return m.KeyspaceId
	}
	return 0
}

func (m *Context) GetBucketsVersion() uint64 {
	if m != nil {
		return m.BucketsVersion
	}
	return 0
}

func (m *Context) GetSourceStmt() *SourceStmt {
	if m != nil {
		return m.SourceStmt
	}
	return nil
}

type ResourceControlContext struct {
	// It's used to identify which resource group the request belongs to.
	ResourceGroupName string `protobuf:"bytes,1,opt,name=resource_group_name,json=resourceGroupName,proto3" json:"resource_group_name,omitempty"`
	// The resource consumption of the resource group that have completed at all TiKVs between the previous request to this TiKV and current request.
	// It's used as penalty to make the local resource scheduling on one TiKV takes the gloabl resource consumption into consideration.
	Penalty *resource_manager.Consumption `protobuf:"bytes,2,opt,name=penalty" json:"penalty,omitempty"`
	// This priority would override the original priority of the resource group for the request.
	// Used to deprioritize the runaway queries.
	OverridePriority uint64 `protobuf:"varint,3,opt,name=override_priority,json=overridePriority,proto3" json:"override_priority,omitempty"`
}

func (m *ResourceControlContext) Reset()                    { *m = ResourceControlContext{} }
func (m *ResourceControlContext) String() string            { return proto.CompactTextString(m) }
func (*ResourceControlContext) ProtoMessage()               {}
func (*ResourceControlContext) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{76} }

func (m *ResourceControlContext) GetResourceGroupName() string {
	if m != nil {
		return m.ResourceGroupName
	}
	return ""
}

func (m *ResourceControlContext) GetPenalty() *resource_manager.Consumption {
	if m != nil {
		return m.Penalty
	}
	return nil
}

func (m *ResourceControlContext) GetOverridePriority() uint64 {
	if m != nil {
		return m.OverridePriority
	}
	return 0
}

type SourceStmt struct {
	StartTs      uint64 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	ConnectionId uint64 `protobuf:"varint,2,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	StmtId       uint64 `protobuf:"varint,3,opt,name=stmt_id,json=stmtId,proto3" json:"stmt_id,omitempty"`
	// session alias set by user
	SessionAlias string `protobuf:"bytes,4,opt,name=session_alias,json=sessionAlias,proto3" json:"session_alias,omitempty"`
}

func (m *SourceStmt) Reset()                    { *m = SourceStmt{} }
func (m *SourceStmt) String() string            { return proto.CompactTextString(m) }
func (*SourceStmt) ProtoMessage()               {}
func (*SourceStmt) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{77} }

func (m *SourceStmt) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *SourceStmt) GetConnectionId() uint64 {
	if m != nil {
		return m.ConnectionId
	}
	return 0
}

func (m *SourceStmt) GetStmtId() uint64 {
	if m != nil {
		return m.StmtId
	}
	return 0
}

func (m *SourceStmt) GetSessionAlias() string {
	if m != nil {
		return m.SessionAlias
	}
	return ""
}

type LockInfo struct {
	PrimaryLock []byte `protobuf:"bytes,1,opt,name=primary_lock,json=primaryLock,proto3" json:"primary_lock,omitempty"`
	LockVersion uint64 `protobuf:"varint,2,opt,name=lock_version,json=lockVersion,proto3" json:"lock_version,omitempty"`
	Key         []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	LockTtl     uint64 `protobuf:"varint,4,opt,name=lock_ttl,json=lockTtl,proto3" json:"lock_ttl,omitempty"`
	// How many keys this transaction involves in this region.
	TxnSize         uint64 `protobuf:"varint,5,opt,name=txn_size,json=txnSize,proto3" json:"txn_size,omitempty"`
	LockType        Op     `protobuf:"varint,6,opt,name=lock_type,json=lockType,proto3,enum=kvrpcpb.Op" json:"lock_type,omitempty"`
	LockForUpdateTs uint64 `protobuf:"varint,7,opt,name=lock_for_update_ts,json=lockForUpdateTs,proto3" json:"lock_for_update_ts,omitempty"`
	// Fields for transactions that are using Async Commit.
	UseAsyncCommit bool     `protobuf:"varint,8,opt,name=use_async_commit,json=useAsyncCommit,proto3" json:"use_async_commit,omitempty"`
	MinCommitTs    uint64   `protobuf:"varint,9,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	Secondaries    [][]byte `protobuf:"bytes,10,rep,name=secondaries" json:"secondaries,omitempty"`
	// The time elapsed since last update of lock wait info when waiting.
	// It's used in timeout errors. 0 means unknown or not applicable.
	// It can be used to help the client decide whether to try resolving the lock.
	DurationToLastUpdateMs uint64 `protobuf:"varint,11,opt,name=duration_to_last_update_ms,json=durationToLastUpdateMs,proto3" json:"duration_to_last_update_ms,omitempty"`
}

func (m *LockInfo) Reset()                    { *m = LockInfo{} }
func (m *LockInfo) String() string            { return proto.CompactTextString(m) }
func (*LockInfo) ProtoMessage()               {}
func (*LockInfo) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{78} }

func (m *LockInfo) GetPrimaryLock() []byte {
	if m != nil {
		return m.PrimaryLock
	}
	return nil
}

func (m *LockInfo) GetLockVersion() uint64 {
	if m != nil {
		return m.LockVersion
	}
	return 0
}

func (m *LockInfo) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *LockInfo) GetLockTtl() uint64 {
	if m != nil {
		return m.LockTtl
	}
	return 0
}

func (m *LockInfo) GetTxnSize() uint64 {
	if m != nil {
		return m.TxnSize
	}
	return 0
}

func (m *LockInfo) GetLockType() Op {
	if m != nil {
		return m.LockType
	}
	return Op_Put
}

func (m *LockInfo) GetLockForUpdateTs() uint64 {
	if m != nil {
		return m.LockForUpdateTs
	}
	return 0
}

func (m *LockInfo) GetUseAsyncCommit() bool {
	if m != nil {
		return m.UseAsyncCommit
	}
	return false
}

func (m *LockInfo) GetMinCommitTs() uint64 {
	if m != nil {
		return m.MinCommitTs
	}
	return 0
}

func (m *LockInfo) GetSecondaries() [][]byte {
	if m != nil {
		return m.Secondaries
	}
	return nil
}

func (m *LockInfo) GetDurationToLastUpdateMs() uint64 {
	if m != nil {
		return m.DurationToLastUpdateMs
	}
	return 0
}

type KeyError struct {
	Locked           *LockInfo         `protobuf:"bytes,1,opt,name=locked" json:"locked,omitempty"`
	Retryable        string            `protobuf:"bytes,2,opt,name=retryable,proto3" json:"retryable,omitempty"`
	Abort            string            `protobuf:"bytes,3,opt,name=abort,proto3" json:"abort,omitempty"`
	Conflict         *WriteConflict    `protobuf:"bytes,4,opt,name=conflict" json:"conflict,omitempty"`
	AlreadyExist     *AlreadyExist     `protobuf:"bytes,5,opt,name=already_exist,json=alreadyExist" json:"already_exist,omitempty"`
	Deadlock         *Deadlock         `protobuf:"bytes,6,opt,name=deadlock" json:"deadlock,omitempty"`
	CommitTsExpired  *CommitTsExpired  `protobuf:"bytes,7,opt,name=commit_ts_expired,json=commitTsExpired" json:"commit_ts_expired,omitempty"`
	TxnNotFound      *TxnNotFound      `protobuf:"bytes,8,opt,name=txn_not_found,json=txnNotFound" json:"txn_not_found,omitempty"`
	CommitTsTooLarge *CommitTsTooLarge `protobuf:"bytes,9,opt,name=commit_ts_too_large,json=commitTsTooLarge" json:"commit_ts_too_large,omitempty"`
	AssertionFailed  *AssertionFailed  `protobuf:"bytes,10,opt,name=assertion_failed,json=assertionFailed" json:"assertion_failed,omitempty"`
	PrimaryMismatch  *PrimaryMismatch  `protobuf:"bytes,11,opt,name=primary_mismatch,json=primaryMismatch" json:"primary_mismatch,omitempty"`
}

func (m *KeyError) Reset()                    { *m = KeyError{} }
func (m *KeyError) String() string            { return proto.CompactTextString(m) }
func (*KeyError) ProtoMessage()               {}
func (*KeyError) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{79} }

func (m *KeyError) GetLocked() *LockInfo {
	if m != nil {
		return m.Locked
	}
	return nil
}

func (m *KeyError) GetRetryable() string {
	if m != nil {
		return m.Retryable
	}
	return ""
}

func (m *KeyError) GetAbort() string {
	if m != nil {
		return m.Abort
	}
	return ""
}

func (m *KeyError) GetConflict() *WriteConflict {
	if m != nil {
		return m.Conflict
	}
	return nil
}

func (m *KeyError) GetAlreadyExist() *AlreadyExist {
	if m != nil {
		return m.AlreadyExist
	}
	return nil
}

func (m *KeyError) GetDeadlock() *Deadlock {
	if m != nil {
		return m.Deadlock
	}
	return nil
}

func (m *KeyError) GetCommitTsExpired() *CommitTsExpired {
	if m != nil {
		return m.CommitTsExpired
	}
	return nil
}

func (m *KeyError) GetTxnNotFound() *TxnNotFound {
	if m != nil {
		return m.TxnNotFound
	}
	return nil
}

func (m *KeyError) GetCommitTsTooLarge() *CommitTsTooLarge {
	if m != nil {
		return m.CommitTsTooLarge
	}
	return nil
}

func (m *KeyError) GetAssertionFailed() *AssertionFailed {
	if m != nil {
		return m.AssertionFailed
	}
	return nil
}

func (m *KeyError) GetPrimaryMismatch() *PrimaryMismatch {
	if m != nil {
		return m.PrimaryMismatch
	}
	return nil
}

type WriteConflict struct {
	StartTs          uint64               `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	ConflictTs       uint64               `protobuf:"varint,2,opt,name=conflict_ts,json=conflictTs,proto3" json:"conflict_ts,omitempty"`
	Key              []byte               `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Primary          []byte               `protobuf:"bytes,4,opt,name=primary,proto3" json:"primary,omitempty"`
	ConflictCommitTs uint64               `protobuf:"varint,5,opt,name=conflict_commit_ts,json=conflictCommitTs,proto3" json:"conflict_commit_ts,omitempty"`
	Reason           WriteConflict_Reason `protobuf:"varint,6,opt,name=reason,proto3,enum=kvrpcpb.WriteConflict_Reason" json:"reason,omitempty"`
}

func (m *WriteConflict) Reset()                    { *m = WriteConflict{} }
func (m *WriteConflict) String() string            { return proto.CompactTextString(m) }
func (*WriteConflict) ProtoMessage()               {}
func (*WriteConflict) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{80} }

func (m *WriteConflict) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *WriteConflict) GetConflictTs() uint64 {
	if m != nil {
		return m.ConflictTs
	}
	return 0
}

func (m *WriteConflict) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *WriteConflict) GetPrimary() []byte {
	if m != nil {
		return m.Primary
	}
	return nil
}

func (m *WriteConflict) GetConflictCommitTs() uint64 {
	if m != nil {
		return m.ConflictCommitTs
	}
	return 0
}

func (m *WriteConflict) GetReason() WriteConflict_Reason {
	if m != nil {
		return m.Reason
	}
	return WriteConflict_Unknown
}

type AlreadyExist struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *AlreadyExist) Reset()                    { *m = AlreadyExist{} }
func (m *AlreadyExist) String() string            { return proto.CompactTextString(m) }
func (*AlreadyExist) ProtoMessage()               {}
func (*AlreadyExist) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{81} }

func (m *AlreadyExist) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type Deadlock struct {
	LockTs          uint64                   `protobuf:"varint,1,opt,name=lock_ts,json=lockTs,proto3" json:"lock_ts,omitempty"`
	LockKey         []byte                   `protobuf:"bytes,2,opt,name=lock_key,json=lockKey,proto3" json:"lock_key,omitempty"`
	DeadlockKeyHash uint64                   `protobuf:"varint,3,opt,name=deadlock_key_hash,json=deadlockKeyHash,proto3" json:"deadlock_key_hash,omitempty"`
	WaitChain       []*deadlock.WaitForEntry `protobuf:"bytes,4,rep,name=wait_chain,json=waitChain" json:"wait_chain,omitempty"`
}

func (m *Deadlock) Reset()                    { *m = Deadlock{} }
func (m *Deadlock) String() string            { return proto.CompactTextString(m) }
func (*Deadlock) ProtoMessage()               {}
func (*Deadlock) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{82} }

func (m *Deadlock) GetLockTs() uint64 {
	if m != nil {
		return m.LockTs
	}
	return 0
}

func (m *Deadlock) GetLockKey() []byte {
	if m != nil {
		return m.LockKey
	}
	return nil
}

func (m *Deadlock) GetDeadlockKeyHash() uint64 {
	if m != nil {
		return m.DeadlockKeyHash
	}
	return 0
}

func (m *Deadlock) GetWaitChain() []*deadlock.WaitForEntry {
	if m != nil {
		return m.WaitChain
	}
	return nil
}

type CommitTsExpired struct {
	StartTs           uint64 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	AttemptedCommitTs uint64 `protobuf:"varint,2,opt,name=attempted_commit_ts,json=attemptedCommitTs,proto3" json:"attempted_commit_ts,omitempty"`
	Key               []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	MinCommitTs       uint64 `protobuf:"varint,4,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
}

func (m *CommitTsExpired) Reset()                    { *m = CommitTsExpired{} }
func (m *CommitTsExpired) String() string            { return proto.CompactTextString(m) }
func (*CommitTsExpired) ProtoMessage()               {}
func (*CommitTsExpired) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{83} }

func (m *CommitTsExpired) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *CommitTsExpired) GetAttemptedCommitTs() uint64 {
	if m != nil {
		return m.AttemptedCommitTs
	}
	return 0
}

func (m *CommitTsExpired) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *CommitTsExpired) GetMinCommitTs() uint64 {
	if m != nil {
		return m.MinCommitTs
	}
	return 0
}

type TxnNotFound struct {
	StartTs    uint64 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	PrimaryKey []byte `protobuf:"bytes,2,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
}

func (m *TxnNotFound) Reset()                    { *m = TxnNotFound{} }
func (m *TxnNotFound) String() string            { return proto.CompactTextString(m) }
func (*TxnNotFound) ProtoMessage()               {}
func (*TxnNotFound) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{84} }

func (m *TxnNotFound) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *TxnNotFound) GetPrimaryKey() []byte {
	if m != nil {
		return m.PrimaryKey
	}
	return nil
}

type CommitTsTooLarge struct {
	CommitTs uint64 `protobuf:"varint,1,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
}

func (m *CommitTsTooLarge) Reset()                    { *m = CommitTsTooLarge{} }
func (m *CommitTsTooLarge) String() string            { return proto.CompactTextString(m) }
func (*CommitTsTooLarge) ProtoMessage()               {}
func (*CommitTsTooLarge) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{85} }

func (m *CommitTsTooLarge) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type AssertionFailed struct {
	StartTs          uint64    `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Key              []byte    `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Assertion        Assertion `protobuf:"varint,3,opt,name=assertion,proto3,enum=kvrpcpb.Assertion" json:"assertion,omitempty"`
	ExistingStartTs  uint64    `protobuf:"varint,4,opt,name=existing_start_ts,json=existingStartTs,proto3" json:"existing_start_ts,omitempty"`
	ExistingCommitTs uint64    `protobuf:"varint,5,opt,name=existing_commit_ts,json=existingCommitTs,proto3" json:"existing_commit_ts,omitempty"`
}

func (m *AssertionFailed) Reset()                    { *m = AssertionFailed{} }
func (m *AssertionFailed) String() string            { return proto.CompactTextString(m) }
func (*AssertionFailed) ProtoMessage()               {}
func (*AssertionFailed) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{86} }

func (m *AssertionFailed) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *AssertionFailed) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AssertionFailed) GetAssertion() Assertion {
	if m != nil {
		return m.Assertion
	}
	return Assertion_None
}

func (m *AssertionFailed) GetExistingStartTs() uint64 {
	if m != nil {
		return m.ExistingStartTs
	}
	return 0
}

func (m *AssertionFailed) GetExistingCommitTs() uint64 {
	if m != nil {
		return m.ExistingCommitTs
	}
	return 0
}

type PrimaryMismatch struct {
	LockInfo *LockInfo `protobuf:"bytes,1,opt,name=lock_info,json=lockInfo" json:"lock_info,omitempty"`
}

func (m *PrimaryMismatch) Reset()                    { *m = PrimaryMismatch{} }
func (m *PrimaryMismatch) String() string            { return proto.CompactTextString(m) }
func (*PrimaryMismatch) ProtoMessage()               {}
func (*PrimaryMismatch) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{87} }

func (m *PrimaryMismatch) GetLockInfo() *LockInfo {
	if m != nil {
		return m.LockInfo
	}
	return nil
}

type TimeDetail struct {
	// Off-cpu wall time elapsed in TiKV side. Usually this includes queue waiting time and
	// other kind of waitings in series. (Wait time in the raftstore is not included.)
	WaitWallTimeMs uint64 `protobuf:"varint,1,opt,name=wait_wall_time_ms,json=waitWallTimeMs,proto3" json:"wait_wall_time_ms,omitempty"`
	// Off-cpu and on-cpu wall time elapsed to actually process the request payload. It does not
	// include `wait_wall_time`.
	// This field is very close to the CPU time in most cases. Some wait time spend in RocksDB
	// cannot be excluded for now, like Mutex wait time, which is included in this field, so that
	// this field is called wall time instead of CPU time.
	ProcessWallTimeMs uint64 `protobuf:"varint,2,opt,name=process_wall_time_ms,json=processWallTimeMs,proto3" json:"process_wall_time_ms,omitempty"`
	// KV read wall Time means the time used in key/value scan and get.
	KvReadWallTimeMs uint64 `protobuf:"varint,3,opt,name=kv_read_wall_time_ms,json=kvReadWallTimeMs,proto3" json:"kv_read_wall_time_ms,omitempty"`
	// Total wall clock time spent on this RPC in TiKV .
	TotalRpcWallTimeNs uint64 `protobuf:"varint,4,opt,name=total_rpc_wall_time_ns,json=totalRpcWallTimeNs,proto3" json:"total_rpc_wall_time_ns,omitempty"`
}

func (m *TimeDetail) Reset()                    { *m = TimeDetail{} }
func (m *TimeDetail) String() string            { return proto.CompactTextString(m) }
func (*TimeDetail) ProtoMessage()               {}
func (*TimeDetail) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{88} }

func (m *TimeDetail) GetWaitWallTimeMs() uint64 {
	if m != nil {
		return m.WaitWallTimeMs
	}
	return 0
}

func (m *TimeDetail) GetProcessWallTimeMs() uint64 {
	if m != nil {
		return m.ProcessWallTimeMs
	}
	return 0
}

func (m *TimeDetail) GetKvReadWallTimeMs() uint64 {
	if m != nil {
		return m.KvReadWallTimeMs
	}
	return 0
}

func (m *TimeDetail) GetTotalRpcWallTimeNs() uint64 {
	if m != nil {
		return m.TotalRpcWallTimeNs
	}
	return 0
}

type TimeDetailV2 struct {
	// Off-cpu wall time elapsed in TiKV side. Usually this includes queue waiting time and
	// other kind of waitings in series. (Wait time in the raftstore is not included.)
	WaitWallTimeNs uint64 `protobuf:"varint,1,opt,name=wait_wall_time_ns,json=waitWallTimeNs,proto3" json:"wait_wall_time_ns,omitempty"`
	// Off-cpu and on-cpu wall time elapsed to actually process the request payload. It does not
	// include `wait_wall_time` and `suspend_wall_time`.
	// This field is very close to the CPU time in most cases. Some wait time spend in RocksDB
	// cannot be excluded for now, like Mutex wait time, which is included in this field, so that
	// this field is called wall time instead of CPU time.
	ProcessWallTimeNs uint64 `protobuf:"varint,2,opt,name=process_wall_time_ns,json=processWallTimeNs,proto3" json:"process_wall_time_ns,omitempty"`
	// Cpu wall time elapsed that task is waiting in queue.
	ProcessSuspendWallTimeNs uint64 `protobuf:"varint,3,opt,name=process_suspend_wall_time_ns,json=processSuspendWallTimeNs,proto3" json:"process_suspend_wall_time_ns,omitempty"`
	// KV read wall Time means the time used in key/value scan and get.
	KvReadWallTimeNs uint64 `protobuf:"varint,4,opt,name=kv_read_wall_time_ns,json=kvReadWallTimeNs,proto3" json:"kv_read_wall_time_ns,omitempty"`
	// Total wall clock time spent on this RPC in TiKV .
	TotalRpcWallTimeNs uint64 `protobuf:"varint,5,opt,name=total_rpc_wall_time_ns,json=totalRpcWallTimeNs,proto3" json:"total_rpc_wall_time_ns,omitempty"`
}

func (m *TimeDetailV2) Reset()                    { *m = TimeDetailV2{} }
func (m *TimeDetailV2) String() string            { return proto.CompactTextString(m) }
func (*TimeDetailV2) ProtoMessage()               {}
func (*TimeDetailV2) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{89} }

func (m *TimeDetailV2) GetWaitWallTimeNs() uint64 {
	if m != nil {
		return m.WaitWallTimeNs
	}
	return 0
}

func (m *TimeDetailV2) GetProcessWallTimeNs() uint64 {
	if m != nil {
		return m.ProcessWallTimeNs
	}
	return 0
}

func (m *TimeDetailV2) GetProcessSuspendWallTimeNs() uint64 {
	if m != nil {
		return m.ProcessSuspendWallTimeNs
	}
	return 0
}

func (m *TimeDetailV2) GetKvReadWallTimeNs() uint64 {
	if m != nil {
		return m.KvReadWallTimeNs
	}
	return 0
}

func (m *TimeDetailV2) GetTotalRpcWallTimeNs() uint64 {
	if m != nil {
		return m.TotalRpcWallTimeNs
	}
	return 0
}

type ScanInfo struct {
	Total     int64 `protobuf:"varint,1,opt,name=total,proto3" json:"total,omitempty"`
	Processed int64 `protobuf:"varint,2,opt,name=processed,proto3" json:"processed,omitempty"`
	ReadBytes int64 `protobuf:"varint,3,opt,name=read_bytes,json=readBytes,proto3" json:"read_bytes,omitempty"`
}

func (m *ScanInfo) Reset()                    { *m = ScanInfo{} }
func (m *ScanInfo) String() string            { return proto.CompactTextString(m) }
func (*ScanInfo) ProtoMessage()               {}
func (*ScanInfo) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{90} }

func (m *ScanInfo) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ScanInfo) GetProcessed() int64 {
	if m != nil {
		return m.Processed
	}
	return 0
}

func (m *ScanInfo) GetReadBytes() int64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

// Only reserved for compatibility.
type ScanDetail struct {
	Write *ScanInfo `protobuf:"bytes,1,opt,name=write" json:"write,omitempty"`
	Lock  *ScanInfo `protobuf:"bytes,2,opt,name=lock" json:"lock,omitempty"`
	Data  *ScanInfo `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
}

func (m *ScanDetail) Reset()                    { *m = ScanDetail{} }
func (m *ScanDetail) String() string            { return proto.CompactTextString(m) }
func (*ScanDetail) ProtoMessage()               {}
func (*ScanDetail) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{91} }

func (m *ScanDetail) GetWrite() *ScanInfo {
	if m != nil {
		return m.Write
	}
	return nil
}

func (m *ScanDetail) GetLock() *ScanInfo {
	if m != nil {
		return m.Lock
	}
	return nil
}

func (m *ScanDetail) GetData() *ScanInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type ScanDetailV2 struct {
	// Number of user keys scanned from the storage.
	// It does not include deleted version or RocksDB tombstone keys.
	// For Coprocessor requests, it includes keys that has been filtered out by
	// Selection.
	ProcessedVersions uint64 `protobuf:"varint,1,opt,name=processed_versions,json=processedVersions,proto3" json:"processed_versions,omitempty"`
	// Number of bytes of user key-value pairs scanned from the storage, i.e.
	// total size of data returned from MVCC layer.
	ProcessedVersionsSize uint64 `protobuf:"varint,8,opt,name=processed_versions_size,json=processedVersionsSize,proto3" json:"processed_versions_size,omitempty"`
	// Approximate number of MVCC keys meet during scanning. It includes
	// deleted versions, but does not include RocksDB tombstone keys.
	//
	// When this field is notably larger than `processed_versions`, it means
	// there are a lot of deleted MVCC keys.
	TotalVersions uint64 `protobuf:"varint,2,opt,name=total_versions,json=totalVersions,proto3" json:"total_versions,omitempty"`
	// Total number of deletes and single deletes skipped over during
	// iteration, i.e. how many RocksDB tombstones are skipped.
	RocksdbDeleteSkippedCount uint64 `protobuf:"varint,3,opt,name=rocksdb_delete_skipped_count,json=rocksdbDeleteSkippedCount,proto3" json:"rocksdb_delete_skipped_count,omitempty"`
	// Total number of internal keys skipped over during iteration.
	// See https://github.com/facebook/rocksdb/blob/9f1c84ca471d8b1ad7be9f3eebfc2c7e07dfd7a7/include/rocksdb/perf_context.h#L84 for details.
	RocksdbKeySkippedCount uint64 `protobuf:"varint,4,opt,name=rocksdb_key_skipped_count,json=rocksdbKeySkippedCount,proto3" json:"rocksdb_key_skipped_count,omitempty"`
	// Total number of RocksDB block cache hits.
	RocksdbBlockCacheHitCount uint64 `protobuf:"varint,5,opt,name=rocksdb_block_cache_hit_count,json=rocksdbBlockCacheHitCount,proto3" json:"rocksdb_block_cache_hit_count,omitempty"`
	// Total number of block reads (with IO).
	RocksdbBlockReadCount uint64 `protobuf:"varint,6,opt,name=rocksdb_block_read_count,json=rocksdbBlockReadCount,proto3" json:"rocksdb_block_read_count,omitempty"`
	// Total number of bytes from block reads.
	RocksdbBlockReadByte uint64 `protobuf:"varint,7,opt,name=rocksdb_block_read_byte,json=rocksdbBlockReadByte,proto3" json:"rocksdb_block_read_byte,omitempty"`
	// Total time used for block reads.
	RocksdbBlockReadNanos uint64 `protobuf:"varint,9,opt,name=rocksdb_block_read_nanos,json=rocksdbBlockReadNanos,proto3" json:"rocksdb_block_read_nanos,omitempty"`
	// Time used for getting a raftstore snapshot (including proposing read index, leader confirmation and getting the RocksDB snapshot).
	GetSnapshotNanos uint64 `protobuf:"varint,10,opt,name=get_snapshot_nanos,json=getSnapshotNanos,proto3" json:"get_snapshot_nanos,omitempty"`
	// Time used for proposing read index from read pool to store pool, equals 0 when performing lease read.
	ReadIndexProposeWaitNanos uint64 `protobuf:"varint,11,opt,name=read_index_propose_wait_nanos,json=readIndexProposeWaitNanos,proto3" json:"read_index_propose_wait_nanos,omitempty"`
	// Time used for leader confirmation, equals 0 when performing lease read.
	ReadIndexConfirmWaitNanos uint64 `protobuf:"varint,12,opt,name=read_index_confirm_wait_nanos,json=readIndexConfirmWaitNanos,proto3" json:"read_index_confirm_wait_nanos,omitempty"`
	// Time used for read pool scheduling.
	ReadPoolScheduleWaitNanos uint64 `protobuf:"varint,13,opt,name=read_pool_schedule_wait_nanos,json=readPoolScheduleWaitNanos,proto3" json:"read_pool_schedule_wait_nanos,omitempty"`
}

func (m *ScanDetailV2) Reset()                    { *m = ScanDetailV2{} }
func (m *ScanDetailV2) String() string            { return proto.CompactTextString(m) }
func (*ScanDetailV2) ProtoMessage()               {}
func (*ScanDetailV2) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{92} }

func (m *ScanDetailV2) GetProcessedVersions() uint64 {
	if m != nil {
		return m.ProcessedVersions
	}
	return 0
}

func (m *ScanDetailV2) GetProcessedVersionsSize() uint64 {
	if m != nil {
		return m.ProcessedVersionsSize
	}
	return 0
}

func (m *ScanDetailV2) GetTotalVersions() uint64 {
	if m != nil {
		return m.TotalVersions
	}
	return 0
}

func (m *ScanDetailV2) GetRocksdbDeleteSkippedCount() uint64 {
	if m != nil {
		return m.RocksdbDeleteSkippedCount
	}
	return 0
}

func (m *ScanDetailV2) GetRocksdbKeySkippedCount() uint64 {
	if m != nil {
		return m.RocksdbKeySkippedCount
	}
	return 0
}

func (m *ScanDetailV2) GetRocksdbBlockCacheHitCount() uint64 {
	if m != nil {
		return m.RocksdbBlockCacheHitCount
	}
	return 0
}

func (m *ScanDetailV2) GetRocksdbBlockReadCount() uint64 {
	if m != nil {
		return m.RocksdbBlockReadCount
	}
	return 0
}

func (m *ScanDetailV2) GetRocksdbBlockReadByte() uint64 {
	if m != nil {
		return m.RocksdbBlockReadByte
	}
	return 0
}

func (m *ScanDetailV2) GetRocksdbBlockReadNanos() uint64 {
	if m != nil {
		return m.RocksdbBlockReadNanos
	}
	return 0
}

func (m *ScanDetailV2) GetGetSnapshotNanos() uint64 {
	if m != nil {
		return m.GetSnapshotNanos
	}
	return 0
}

func (m *ScanDetailV2) GetReadIndexProposeWaitNanos() uint64 {
	if m != nil {
		return m.ReadIndexProposeWaitNanos
	}
	return 0
}

func (m *ScanDetailV2) GetReadIndexConfirmWaitNanos() uint64 {
	if m != nil {
		return m.ReadIndexConfirmWaitNanos
	}
	return 0
}

func (m *ScanDetailV2) GetReadPoolScheduleWaitNanos() uint64 {
	if m != nil {
		return m.ReadPoolScheduleWaitNanos
	}
	return 0
}

type ExecDetails struct {
	// Available when ctx.record_time_stat = true or meet slow query.
	TimeDetail *TimeDetail `protobuf:"bytes,1,opt,name=time_detail,json=timeDetail" json:"time_detail,omitempty"`
	// Available when ctx.record_scan_stat = true or meet slow query.
	ScanDetail *ScanDetail `protobuf:"bytes,2,opt,name=scan_detail,json=scanDetail" json:"scan_detail,omitempty"`
}

func (m *ExecDetails) Reset()                    { *m = ExecDetails{} }
func (m *ExecDetails) String() string            { return proto.CompactTextString(m) }
func (*ExecDetails) ProtoMessage()               {}
func (*ExecDetails) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{93} }

func (m *ExecDetails) GetTimeDetail() *TimeDetail {
	if m != nil {
		return m.TimeDetail
	}
	return nil
}

func (m *ExecDetails) GetScanDetail() *ScanDetail {
	if m != nil {
		return m.ScanDetail
	}
	return nil
}

type ExecDetailsV2 struct {
	// Available when ctx.record_time_stat = true or meet slow query.
	// deprecated. Should use `time_detail_v2` instead.
	TimeDetail *TimeDetail `protobuf:"bytes,1,opt,name=time_detail,json=timeDetail" json:"time_detail,omitempty"`
	// Available when ctx.record_scan_stat = true or meet slow query.
	ScanDetailV2 *ScanDetailV2 `protobuf:"bytes,2,opt,name=scan_detail_v2,json=scanDetailV2" json:"scan_detail_v2,omitempty"`
	// Raftstore writing durations of the request. Only available for some write requests.
	WriteDetail *WriteDetail `protobuf:"bytes,3,opt,name=write_detail,json=writeDetail" json:"write_detail,omitempty"`
	// Available when ctx.record_time_stat = true or meet slow query.
	TimeDetailV2 *TimeDetailV2 `protobuf:"bytes,4,opt,name=time_detail_v2,json=timeDetailV2" json:"time_detail_v2,omitempty"`
}

func (m *ExecDetailsV2) Reset()                    { *m = ExecDetailsV2{} }
func (m *ExecDetailsV2) String() string            { return proto.CompactTextString(m) }
func (*ExecDetailsV2) ProtoMessage()               {}
func (*ExecDetailsV2) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{94} }

func (m *ExecDetailsV2) GetTimeDetail() *TimeDetail {
	if m != nil {
		return m.TimeDetail
	}
	return nil
}

func (m *ExecDetailsV2) GetScanDetailV2() *ScanDetailV2 {
	if m != nil {
		return m.ScanDetailV2
	}
	return nil
}

func (m *ExecDetailsV2) GetWriteDetail() *WriteDetail {
	if m != nil {
		return m.WriteDetail
	}
	return nil
}

func (m *ExecDetailsV2) GetTimeDetailV2() *TimeDetailV2 {
	if m != nil {
		return m.TimeDetailV2
	}
	return nil
}

type WriteDetail struct {
	// Wait duration in the store loop.
	StoreBatchWaitNanos uint64 `protobuf:"varint,1,opt,name=store_batch_wait_nanos,json=storeBatchWaitNanos,proto3" json:"store_batch_wait_nanos,omitempty"`
	// Wait duration before sending proposal to peers.
	ProposeSendWaitNanos uint64 `protobuf:"varint,2,opt,name=propose_send_wait_nanos,json=proposeSendWaitNanos,proto3" json:"propose_send_wait_nanos,omitempty"`
	// Total time spent on persisting the log.
	PersistLogNanos uint64 `protobuf:"varint,3,opt,name=persist_log_nanos,json=persistLogNanos,proto3" json:"persist_log_nanos,omitempty"`
	// Wait time until the Raft log write leader begins to write.
	RaftDbWriteLeaderWaitNanos uint64 `protobuf:"varint,4,opt,name=raft_db_write_leader_wait_nanos,json=raftDbWriteLeaderWaitNanos,proto3" json:"raft_db_write_leader_wait_nanos,omitempty"`
	// Time spent on synchronizing the Raft log to the disk.
	RaftDbSyncLogNanos uint64 `protobuf:"varint,5,opt,name=raft_db_sync_log_nanos,json=raftDbSyncLogNanos,proto3" json:"raft_db_sync_log_nanos,omitempty"`
	// Time spent on writing the Raft log to the Raft memtable.
	RaftDbWriteMemtableNanos uint64 `protobuf:"varint,6,opt,name=raft_db_write_memtable_nanos,json=raftDbWriteMemtableNanos,proto3" json:"raft_db_write_memtable_nanos,omitempty"`
	// Time waiting for peers to confirm the proposal (counting from the instant when the leader sends the proposal message).
	CommitLogNanos uint64 `protobuf:"varint,7,opt,name=commit_log_nanos,json=commitLogNanos,proto3" json:"commit_log_nanos,omitempty"`
	// Wait duration in the apply loop.
	ApplyBatchWaitNanos uint64 `protobuf:"varint,8,opt,name=apply_batch_wait_nanos,json=applyBatchWaitNanos,proto3" json:"apply_batch_wait_nanos,omitempty"`
	// Total time spend to applying the log.
	ApplyLogNanos uint64 `protobuf:"varint,9,opt,name=apply_log_nanos,json=applyLogNanos,proto3" json:"apply_log_nanos,omitempty"`
	// Wait time until the KV RocksDB lock is acquired.
	ApplyMutexLockNanos uint64 `protobuf:"varint,10,opt,name=apply_mutex_lock_nanos,json=applyMutexLockNanos,proto3" json:"apply_mutex_lock_nanos,omitempty"`
	// Wait time until becoming the KV RocksDB write leader.
	ApplyWriteLeaderWaitNanos uint64 `protobuf:"varint,11,opt,name=apply_write_leader_wait_nanos,json=applyWriteLeaderWaitNanos,proto3" json:"apply_write_leader_wait_nanos,omitempty"`
	// Time spent on writing the KV DB WAL to the disk.
	ApplyWriteWalNanos uint64 `protobuf:"varint,12,opt,name=apply_write_wal_nanos,json=applyWriteWalNanos,proto3" json:"apply_write_wal_nanos,omitempty"`
	// Time spent on writing to the memtable of the KV RocksDB.
	ApplyWriteMemtableNanos uint64 `protobuf:"varint,13,opt,name=apply_write_memtable_nanos,json=applyWriteMemtableNanos,proto3" json:"apply_write_memtable_nanos,omitempty"`
	// Time spent on waiting in the latch.
	LatchWaitNanos uint64 `protobuf:"varint,14,opt,name=latch_wait_nanos,json=latchWaitNanos,proto3" json:"latch_wait_nanos,omitempty"`
	// Processing time in the transaction layer.
	ProcessNanos uint64 `protobuf:"varint,15,opt,name=process_nanos,json=processNanos,proto3" json:"process_nanos,omitempty"`
	// Wait time because of the scheduler flow control or quota limiter throttling.
	ThrottleNanos uint64 `protobuf:"varint,16,opt,name=throttle_nanos,json=throttleNanos,proto3" json:"throttle_nanos,omitempty"`
	// Wait time in the waiter manager for pessimistic locking.
	PessimisticLockWaitNanos uint64 `protobuf:"varint,17,opt,name=pessimistic_lock_wait_nanos,json=pessimisticLockWaitNanos,proto3" json:"pessimistic_lock_wait_nanos,omitempty"`
}

func (m *WriteDetail) Reset()                    { *m = WriteDetail{} }
func (m *WriteDetail) String() string            { return proto.CompactTextString(m) }
func (*WriteDetail) ProtoMessage()               {}
func (*WriteDetail) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{95} }

func (m *WriteDetail) GetStoreBatchWaitNanos() uint64 {
	if m != nil {
		return m.StoreBatchWaitNanos
	}
	return 0
}

func (m *WriteDetail) GetProposeSendWaitNanos() uint64 {
	if m != nil {
		return m.ProposeSendWaitNanos
	}
	return 0
}

func (m *WriteDetail) GetPersistLogNanos() uint64 {
	if m != nil {
		return m.PersistLogNanos
	}
	return 0
}

func (m *WriteDetail) GetRaftDbWriteLeaderWaitNanos() uint64 {
	if m != nil {
		return m.RaftDbWriteLeaderWaitNanos
	}
	return 0
}

func (m *WriteDetail) GetRaftDbSyncLogNanos() uint64 {
	if m != nil {
		return m.RaftDbSyncLogNanos
	}
	return 0
}

func (m *WriteDetail) GetRaftDbWriteMemtableNanos() uint64 {
	if m != nil {
		return m.RaftDbWriteMemtableNanos
	}
	return 0
}

func (m *WriteDetail) GetCommitLogNanos() uint64 {
	if m != nil {
		return m.CommitLogNanos
	}
	return 0
}

func (m *WriteDetail) GetApplyBatchWaitNanos() uint64 {
	if m != nil {
		return m.ApplyBatchWaitNanos
	}
	return 0
}

func (m *WriteDetail) GetApplyLogNanos() uint64 {
	if m != nil {
		return m.ApplyLogNanos
	}
	return 0
}

func (m *WriteDetail) GetApplyMutexLockNanos() uint64 {
	if m != nil {
		return m.ApplyMutexLockNanos
	}
	return 0
}

func (m *WriteDetail) GetApplyWriteLeaderWaitNanos() uint64 {
	if m != nil {
		return m.ApplyWriteLeaderWaitNanos
	}
	return 0
}

func (m *WriteDetail) GetApplyWriteWalNanos() uint64 {
	if m != nil {
		return m.ApplyWriteWalNanos
	}
	return 0
}

func (m *WriteDetail) GetApplyWriteMemtableNanos() uint64 {
	if m != nil {
		return m.ApplyWriteMemtableNanos
	}
	return 0
}

func (m *WriteDetail) GetLatchWaitNanos() uint64 {
	if m != nil {
		return m.LatchWaitNanos
	}
	return 0
}

func (m *WriteDetail) GetProcessNanos() uint64 {
	if m != nil {
		return m.ProcessNanos
	}
	return 0
}

func (m *WriteDetail) GetThrottleNanos() uint64 {
	if m != nil {
		return m.ThrottleNanos
	}
	return 0
}

func (m *WriteDetail) GetPessimisticLockWaitNanos() uint64 {
	if m != nil {
		return m.PessimisticLockWaitNanos
	}
	return 0
}

type KvPair struct {
	Error *KeyError `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Key   []byte    `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte    `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KvPair) Reset()                    { *m = KvPair{} }
func (m *KvPair) String() string            { return proto.CompactTextString(m) }
func (*KvPair) ProtoMessage()               {}
func (*KvPair) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{96} }

func (m *KvPair) GetError() *KeyError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *KvPair) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KvPair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type Mutation struct {
	Op        Op        `protobuf:"varint,1,opt,name=op,proto3,enum=kvrpcpb.Op" json:"op,omitempty"`
	Key       []byte    `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value     []byte    `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Assertion Assertion `protobuf:"varint,4,opt,name=assertion,proto3,enum=kvrpcpb.Assertion" json:"assertion,omitempty"`
}

func (m *Mutation) Reset()                    { *m = Mutation{} }
func (m *Mutation) String() string            { return proto.CompactTextString(m) }
func (*Mutation) ProtoMessage()               {}
func (*Mutation) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{97} }

func (m *Mutation) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_Put
}

func (m *Mutation) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Mutation) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Mutation) GetAssertion() Assertion {
	if m != nil {
		return m.Assertion
	}
	return Assertion_None
}

type MvccWrite struct {
	Type                  Op     `protobuf:"varint,1,opt,name=type,proto3,enum=kvrpcpb.Op" json:"type,omitempty"`
	StartTs               uint64 `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs              uint64 `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	ShortValue            []byte `protobuf:"bytes,4,opt,name=short_value,json=shortValue,proto3" json:"short_value,omitempty"`
	HasOverlappedRollback bool   `protobuf:"varint,5,opt,name=has_overlapped_rollback,json=hasOverlappedRollback,proto3" json:"has_overlapped_rollback,omitempty"`
	HasGcFence            bool   `protobuf:"varint,6,opt,name=has_gc_fence,json=hasGcFence,proto3" json:"has_gc_fence,omitempty"`
	GcFence               uint64 `protobuf:"varint,7,opt,name=gc_fence,json=gcFence,proto3" json:"gc_fence,omitempty"`
	LastChangeTs          uint64 `protobuf:"varint,8,opt,name=last_change_ts,json=lastChangeTs,proto3" json:"last_change_ts,omitempty"`
	VersionsToLastChange  uint64 `protobuf:"varint,9,opt,name=versions_to_last_change,json=versionsToLastChange,proto3" json:"versions_to_last_change,omitempty"`
}

func (m *MvccWrite) Reset()                    { *m = MvccWrite{} }
func (m *MvccWrite) String() string            { return proto.CompactTextString(m) }
func (*MvccWrite) ProtoMessage()               {}
func (*MvccWrite) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{98} }

func (m *MvccWrite) GetType() Op {
	if m != nil {
		return m.Type
	}
	return Op_Put
}

func (m *MvccWrite) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *MvccWrite) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *MvccWrite) GetShortValue() []byte {
	if m != nil {
		return m.ShortValue
	}
	return nil
}

func (m *MvccWrite) GetHasOverlappedRollback() bool {
	if m != nil {
		return m.HasOverlappedRollback
	}
	return false
}

func (m *MvccWrite) GetHasGcFence() bool {
	if m != nil {
		return m.HasGcFence
	}
	return false
}

func (m *MvccWrite) GetGcFence() uint64 {
	if m != nil {
		return m.GcFence
	}
	return 0
}

func (m *MvccWrite) GetLastChangeTs() uint64 {
	if m != nil {
		return m.LastChangeTs
	}
	return 0
}

func (m *MvccWrite) GetVersionsToLastChange() uint64 {
	if m != nil {
		return m.VersionsToLastChange
	}
	return 0
}

type MvccValue struct {
	StartTs uint64 `protobuf:"varint,1,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Value   []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MvccValue) Reset()                    { *m = MvccValue{} }
func (m *MvccValue) String() string            { return proto.CompactTextString(m) }
func (*MvccValue) ProtoMessage()               {}
func (*MvccValue) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{99} }

func (m *MvccValue) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *MvccValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type MvccLock struct {
	Type                 Op       `protobuf:"varint,1,opt,name=type,proto3,enum=kvrpcpb.Op" json:"type,omitempty"`
	StartTs              uint64   `protobuf:"varint,2,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	Primary              []byte   `protobuf:"bytes,3,opt,name=primary,proto3" json:"primary,omitempty"`
	ShortValue           []byte   `protobuf:"bytes,4,opt,name=short_value,json=shortValue,proto3" json:"short_value,omitempty"`
	Ttl                  uint64   `protobuf:"varint,5,opt,name=ttl,proto3" json:"ttl,omitempty"`
	ForUpdateTs          uint64   `protobuf:"varint,6,opt,name=for_update_ts,json=forUpdateTs,proto3" json:"for_update_ts,omitempty"`
	TxnSize              uint64   `protobuf:"varint,7,opt,name=txn_size,json=txnSize,proto3" json:"txn_size,omitempty"`
	UseAsyncCommit       bool     `protobuf:"varint,8,opt,name=use_async_commit,json=useAsyncCommit,proto3" json:"use_async_commit,omitempty"`
	Secondaries          [][]byte `protobuf:"bytes,9,rep,name=secondaries" json:"secondaries,omitempty"`
	RollbackTs           []uint64 `protobuf:"varint,10,rep,packed,name=rollback_ts,json=rollbackTs" json:"rollback_ts,omitempty"`
	LastChangeTs         uint64   `protobuf:"varint,11,opt,name=last_change_ts,json=lastChangeTs,proto3" json:"last_change_ts,omitempty"`
	VersionsToLastChange uint64   `protobuf:"varint,12,opt,name=versions_to_last_change,json=versionsToLastChange,proto3" json:"versions_to_last_change,omitempty"`
}

func (m *MvccLock) Reset()                    { *m = MvccLock{} }
func (m *MvccLock) String() string            { return proto.CompactTextString(m) }
func (*MvccLock) ProtoMessage()               {}
func (*MvccLock) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{100} }

func (m *MvccLock) GetType() Op {
	if m != nil {
		return m.Type
	}
	return Op_Put
}

func (m *MvccLock) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *MvccLock) GetPrimary() []byte {
	if m != nil {
		return m.Primary
	}
	return nil
}

func (m *MvccLock) GetShortValue() []byte {
	if m != nil {
		return m.ShortValue
	}
	return nil
}

func (m *MvccLock) GetTtl() uint64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *MvccLock) GetForUpdateTs() uint64 {
	if m != nil {
		return m.ForUpdateTs
	}
	return 0
}

func (m *MvccLock) GetTxnSize() uint64 {
	if m != nil {
		return m.TxnSize
	}
	return 0
}

func (m *MvccLock) GetUseAsyncCommit() bool {
	if m != nil {
		return m.UseAsyncCommit
	}
	return false
}

func (m *MvccLock) GetSecondaries() [][]byte {
	if m != nil {
		return m.Secondaries
	}
	return nil
}

func (m *MvccLock) GetRollbackTs() []uint64 {
	if m != nil {
		return m.RollbackTs
	}
	return nil
}

func (m *MvccLock) GetLastChangeTs() uint64 {
	if m != nil {
		return m.LastChangeTs
	}
	return 0
}

func (m *MvccLock) GetVersionsToLastChange() uint64 {
	if m != nil {
		return m.VersionsToLastChange
	}
	return 0
}

type MvccInfo struct {
	Lock   *MvccLock    `protobuf:"bytes,1,opt,name=lock" json:"lock,omitempty"`
	Writes []*MvccWrite `protobuf:"bytes,2,rep,name=writes" json:"writes,omitempty"`
	Values []*MvccValue `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
}

func (m *MvccInfo) Reset()                    { *m = MvccInfo{} }
func (m *MvccInfo) String() string            { return proto.CompactTextString(m) }
func (*MvccInfo) ProtoMessage()               {}
func (*MvccInfo) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{101} }

func (m *MvccInfo) GetLock() *MvccLock {
	if m != nil {
		return m.Lock
	}
	return nil
}

func (m *MvccInfo) GetWrites() []*MvccWrite {
	if m != nil {
		return m.Writes
	}
	return nil
}

func (m *MvccInfo) GetValues() []*MvccValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type TxnInfo struct {
	Txn    uint64 `protobuf:"varint,1,opt,name=txn,proto3" json:"txn,omitempty"`
	Status uint64 `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *TxnInfo) Reset()                    { *m = TxnInfo{} }
func (m *TxnInfo) String() string            { return proto.CompactTextString(m) }
func (*TxnInfo) ProtoMessage()               {}
func (*TxnInfo) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{102} }

func (m *TxnInfo) GetTxn() uint64 {
	if m != nil {
		return m.Txn
	}
	return 0
}

func (m *TxnInfo) GetStatus() uint64 {
	if m != nil {
		return m.Status
	}
	return 0
}

type KeyRange struct {
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *KeyRange) Reset()                    { *m = KeyRange{} }
func (m *KeyRange) String() string            { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()               {}
func (*KeyRange) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{103} }

func (m *KeyRange) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *KeyRange) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

type LeaderInfo struct {
	RegionId    uint64              `protobuf:"varint,1,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	PeerId      uint64              `protobuf:"varint,2,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	Term        uint64              `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`
	RegionEpoch *metapb.RegionEpoch `protobuf:"bytes,4,opt,name=region_epoch,json=regionEpoch" json:"region_epoch,omitempty"`
	ReadState   *ReadState          `protobuf:"bytes,5,opt,name=read_state,json=readState" json:"read_state,omitempty"`
}

func (m *LeaderInfo) Reset()                    { *m = LeaderInfo{} }
func (m *LeaderInfo) String() string            { return proto.CompactTextString(m) }
func (*LeaderInfo) ProtoMessage()               {}
func (*LeaderInfo) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{104} }

func (m *LeaderInfo) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *LeaderInfo) GetPeerId() uint64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *LeaderInfo) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *LeaderInfo) GetRegionEpoch() *metapb.RegionEpoch {
	if m != nil {
		return m.RegionEpoch
	}
	return nil
}

func (m *LeaderInfo) GetReadState() *ReadState {
	if m != nil {
		return m.ReadState
	}
	return nil
}

type ReadState struct {
	AppliedIndex uint64 `protobuf:"varint,1,opt,name=applied_index,json=appliedIndex,proto3" json:"applied_index,omitempty"`
	SafeTs       uint64 `protobuf:"varint,2,opt,name=safe_ts,json=safeTs,proto3" json:"safe_ts,omitempty"`
}

func (m *ReadState) Reset()                    { *m = ReadState{} }
func (m *ReadState) String() string            { return proto.CompactTextString(m) }
func (*ReadState) ProtoMessage()               {}
func (*ReadState) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{105} }

func (m *ReadState) GetAppliedIndex() uint64 {
	if m != nil {
		return m.AppliedIndex
	}
	return 0
}

func (m *ReadState) GetSafeTs() uint64 {
	if m != nil {
		return m.SafeTs
	}
	return 0
}

type CheckLeaderRequest struct {
	Regions []*LeaderInfo `protobuf:"bytes,1,rep,name=regions" json:"regions,omitempty"`
	Ts      uint64        `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
}

func (m *CheckLeaderRequest) Reset()                    { *m = CheckLeaderRequest{} }
func (m *CheckLeaderRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckLeaderRequest) ProtoMessage()               {}
func (*CheckLeaderRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{106} }

func (m *CheckLeaderRequest) GetRegions() []*LeaderInfo {
	if m != nil {
		return m.Regions
	}
	return nil
}

func (m *CheckLeaderRequest) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

type CheckLeaderResponse struct {
	Regions []uint64 `protobuf:"varint,1,rep,packed,name=regions" json:"regions,omitempty"`
	Ts      uint64   `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
}

func (m *CheckLeaderResponse) Reset()                    { *m = CheckLeaderResponse{} }
func (m *CheckLeaderResponse) String() string            { return proto.CompactTextString(m) }
func (*CheckLeaderResponse) ProtoMessage()               {}
func (*CheckLeaderResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{107} }

func (m *CheckLeaderResponse) GetRegions() []uint64 {
	if m != nil {
		return m.Regions
	}
	return nil
}

func (m *CheckLeaderResponse) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

type StoreSafeTSRequest struct {
	// Get the minimal `safe_ts` from regions that overlap with the key range [`start_key`, `end_key`)
	// An empty key range means all regions in the store
	KeyRange *KeyRange `protobuf:"bytes,1,opt,name=key_range,json=keyRange" json:"key_range,omitempty"`
}

func (m *StoreSafeTSRequest) Reset()                    { *m = StoreSafeTSRequest{} }
func (m *StoreSafeTSRequest) String() string            { return proto.CompactTextString(m) }
func (*StoreSafeTSRequest) ProtoMessage()               {}
func (*StoreSafeTSRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{108} }

func (m *StoreSafeTSRequest) GetKeyRange() *KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

type StoreSafeTSResponse struct {
	SafeTs uint64 `protobuf:"varint,1,opt,name=safe_ts,json=safeTs,proto3" json:"safe_ts,omitempty"`
}

func (m *StoreSafeTSResponse) Reset()                    { *m = StoreSafeTSResponse{} }
func (m *StoreSafeTSResponse) String() string            { return proto.CompactTextString(m) }
func (*StoreSafeTSResponse) ProtoMessage()               {}
func (*StoreSafeTSResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{109} }

func (m *StoreSafeTSResponse) GetSafeTs() uint64 {
	if m != nil {
		return m.SafeTs
	}
	return 0
}

type RawGetKeyTTLRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Key     []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Cf      string   `protobuf:"bytes,3,opt,name=cf,proto3" json:"cf,omitempty"`
}

func (m *RawGetKeyTTLRequest) Reset()                    { *m = RawGetKeyTTLRequest{} }
func (m *RawGetKeyTTLRequest) String() string            { return proto.CompactTextString(m) }
func (*RawGetKeyTTLRequest) ProtoMessage()               {}
func (*RawGetKeyTTLRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{110} }

func (m *RawGetKeyTTLRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawGetKeyTTLRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RawGetKeyTTLRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

type RawGetKeyTTLResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Ttl         uint64         `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	NotFound    bool           `protobuf:"varint,4,opt,name=not_found,json=notFound,proto3" json:"not_found,omitempty"`
}

func (m *RawGetKeyTTLResponse) Reset()                    { *m = RawGetKeyTTLResponse{} }
func (m *RawGetKeyTTLResponse) String() string            { return proto.CompactTextString(m) }
func (*RawGetKeyTTLResponse) ProtoMessage()               {}
func (*RawGetKeyTTLResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{111} }

func (m *RawGetKeyTTLResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawGetKeyTTLResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RawGetKeyTTLResponse) GetTtl() uint64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *RawGetKeyTTLResponse) GetNotFound() bool {
	if m != nil {
		return m.NotFound
	}
	return false
}

type RawCASRequest struct {
	Context          *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Key              []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value            []byte   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	PreviousNotExist bool     `protobuf:"varint,4,opt,name=previous_not_exist,json=previousNotExist,proto3" json:"previous_not_exist,omitempty"`
	PreviousValue    []byte   `protobuf:"bytes,5,opt,name=previous_value,json=previousValue,proto3" json:"previous_value,omitempty"`
	Cf               string   `protobuf:"bytes,6,opt,name=cf,proto3" json:"cf,omitempty"`
	Ttl              uint64   `protobuf:"varint,7,opt,name=ttl,proto3" json:"ttl,omitempty"`
}

func (m *RawCASRequest) Reset()                    { *m = RawCASRequest{} }
func (m *RawCASRequest) String() string            { return proto.CompactTextString(m) }
func (*RawCASRequest) ProtoMessage()               {}
func (*RawCASRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{112} }

func (m *RawCASRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawCASRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RawCASRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RawCASRequest) GetPreviousNotExist() bool {
	if m != nil {
		return m.PreviousNotExist
	}
	return false
}

func (m *RawCASRequest) GetPreviousValue() []byte {
	if m != nil {
		return m.PreviousValue
	}
	return nil
}

func (m *RawCASRequest) GetCf() string {
	if m != nil {
		return m.Cf
	}
	return ""
}

func (m *RawCASRequest) GetTtl() uint64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

type RawCASResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Succeed     bool           `protobuf:"varint,3,opt,name=succeed,proto3" json:"succeed,omitempty"`
	// The previous value regardless of whether the comparison is succeed.
	PreviousNotExist bool   `protobuf:"varint,4,opt,name=previous_not_exist,json=previousNotExist,proto3" json:"previous_not_exist,omitempty"`
	PreviousValue    []byte `protobuf:"bytes,5,opt,name=previous_value,json=previousValue,proto3" json:"previous_value,omitempty"`
}

func (m *RawCASResponse) Reset()                    { *m = RawCASResponse{} }
func (m *RawCASResponse) String() string            { return proto.CompactTextString(m) }
func (*RawCASResponse) ProtoMessage()               {}
func (*RawCASResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{113} }

func (m *RawCASResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawCASResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RawCASResponse) GetSucceed() bool {
	if m != nil {
		return m.Succeed
	}
	return false
}

func (m *RawCASResponse) GetPreviousNotExist() bool {
	if m != nil {
		return m.PreviousNotExist
	}
	return false
}

func (m *RawCASResponse) GetPreviousValue() []byte {
	if m != nil {
		return m.PreviousValue
	}
	return nil
}

type GetLockWaitInfoRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
}

func (m *GetLockWaitInfoRequest) Reset()                    { *m = GetLockWaitInfoRequest{} }
func (m *GetLockWaitInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLockWaitInfoRequest) ProtoMessage()               {}
func (*GetLockWaitInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{114} }

func (m *GetLockWaitInfoRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

type GetLockWaitInfoResponse struct {
	RegionError *errorpb.Error           `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string                   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Entries     []*deadlock.WaitForEntry `protobuf:"bytes,3,rep,name=entries" json:"entries,omitempty"`
}

func (m *GetLockWaitInfoResponse) Reset()         { *m = GetLockWaitInfoResponse{} }
func (m *GetLockWaitInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetLockWaitInfoResponse) ProtoMessage()    {}
func (*GetLockWaitInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{115}
}

func (m *GetLockWaitInfoResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *GetLockWaitInfoResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *GetLockWaitInfoResponse) GetEntries() []*deadlock.WaitForEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type GetLockWaitHistoryRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
}

func (m *GetLockWaitHistoryRequest) Reset()         { *m = GetLockWaitHistoryRequest{} }
func (m *GetLockWaitHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*GetLockWaitHistoryRequest) ProtoMessage()    {}
func (*GetLockWaitHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{116}
}

func (m *GetLockWaitHistoryRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

type GetLockWaitHistoryResponse struct {
	RegionError *errorpb.Error           `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string                   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Entries     []*deadlock.WaitForEntry `protobuf:"bytes,3,rep,name=entries" json:"entries,omitempty"`
}

func (m *GetLockWaitHistoryResponse) Reset()         { *m = GetLockWaitHistoryResponse{} }
func (m *GetLockWaitHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*GetLockWaitHistoryResponse) ProtoMessage()    {}
func (*GetLockWaitHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{117}
}

func (m *GetLockWaitHistoryResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *GetLockWaitHistoryResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *GetLockWaitHistoryResponse) GetEntries() []*deadlock.WaitForEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type RawCoprocessorRequest struct {
	Context  *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	CoprName string   `protobuf:"bytes,2,opt,name=copr_name,json=coprName,proto3" json:"copr_name,omitempty"`
	// Coprorcessor version constraint following SEMVER definition.
	CoprVersionReq string      `protobuf:"bytes,3,opt,name=copr_version_req,json=coprVersionReq,proto3" json:"copr_version_req,omitempty"`
	Ranges         []*KeyRange `protobuf:"bytes,4,rep,name=ranges" json:"ranges,omitempty"`
	Data           []byte      `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *RawCoprocessorRequest) Reset()                    { *m = RawCoprocessorRequest{} }
func (m *RawCoprocessorRequest) String() string            { return proto.CompactTextString(m) }
func (*RawCoprocessorRequest) ProtoMessage()               {}
func (*RawCoprocessorRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{118} }

func (m *RawCoprocessorRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawCoprocessorRequest) GetCoprName() string {
	if m != nil {
		return m.CoprName
	}
	return ""
}

func (m *RawCoprocessorRequest) GetCoprVersionReq() string {
	if m != nil {
		return m.CoprVersionReq
	}
	return ""
}

func (m *RawCoprocessorRequest) GetRanges() []*KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *RawCoprocessorRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type RawCoprocessorResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	// Error message for cases like if no coprocessor with a matching name is found
	// or on a version mismatch between plugin_api and the coprocessor.
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Data  []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *RawCoprocessorResponse) Reset()                    { *m = RawCoprocessorResponse{} }
func (m *RawCoprocessorResponse) String() string            { return proto.CompactTextString(m) }
func (*RawCoprocessorResponse) ProtoMessage()               {}
func (*RawCoprocessorResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{119} }

func (m *RawCoprocessorResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawCoprocessorResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RawCoprocessorResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type RawChecksumRequest struct {
	Context   *Context          `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Algorithm ChecksumAlgorithm `protobuf:"varint,2,opt,name=algorithm,proto3,enum=kvrpcpb.ChecksumAlgorithm" json:"algorithm,omitempty"`
	Ranges    []*KeyRange       `protobuf:"bytes,3,rep,name=ranges" json:"ranges,omitempty"`
}

func (m *RawChecksumRequest) Reset()                    { *m = RawChecksumRequest{} }
func (m *RawChecksumRequest) String() string            { return proto.CompactTextString(m) }
func (*RawChecksumRequest) ProtoMessage()               {}
func (*RawChecksumRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{120} }

func (m *RawChecksumRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *RawChecksumRequest) GetAlgorithm() ChecksumAlgorithm {
	if m != nil {
		return m.Algorithm
	}
	return ChecksumAlgorithm_Crc64_Xor
}

func (m *RawChecksumRequest) GetRanges() []*KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

type RawChecksumResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Error       string         `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Checksum    uint64         `protobuf:"varint,3,opt,name=checksum,proto3" json:"checksum,omitempty"`
	TotalKvs    uint64         `protobuf:"varint,4,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes  uint64         `protobuf:"varint,5,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
}

func (m *RawChecksumResponse) Reset()                    { *m = RawChecksumResponse{} }
func (m *RawChecksumResponse) String() string            { return proto.CompactTextString(m) }
func (*RawChecksumResponse) ProtoMessage()               {}
func (*RawChecksumResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{121} }

func (m *RawChecksumResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *RawChecksumResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RawChecksumResponse) GetChecksum() uint64 {
	if m != nil {
		return m.Checksum
	}
	return 0
}

func (m *RawChecksumResponse) GetTotalKvs() uint64 {
	if m != nil {
		return m.TotalKvs
	}
	return 0
}

func (m *RawChecksumResponse) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

type CompactError struct {
	// Types that are valid to be assigned to Error:
	//	*CompactError_ErrInvalidStartKey
	//	*CompactError_ErrPhysicalTableNotExist
	//	*CompactError_ErrCompactInProgress
	//	*CompactError_ErrTooManyPendingTasks
	Error isCompactError_Error `protobuf_oneof:"error"`
}

func (m *CompactError) Reset()                    { *m = CompactError{} }
func (m *CompactError) String() string            { return proto.CompactTextString(m) }
func (*CompactError) ProtoMessage()               {}
func (*CompactError) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{122} }

type isCompactError_Error interface {
	isCompactError_Error()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CompactError_ErrInvalidStartKey struct {
	ErrInvalidStartKey *CompactErrorInvalidStartKey `protobuf:"bytes,1,opt,name=err_invalid_start_key,json=errInvalidStartKey,oneof"`
}
type CompactError_ErrPhysicalTableNotExist struct {
	ErrPhysicalTableNotExist *CompactErrorPhysicalTableNotExist `protobuf:"bytes,2,opt,name=err_physical_table_not_exist,json=errPhysicalTableNotExist,oneof"`
}
type CompactError_ErrCompactInProgress struct {
	ErrCompactInProgress *CompactErrorCompactInProgress `protobuf:"bytes,3,opt,name=err_compact_in_progress,json=errCompactInProgress,oneof"`
}
type CompactError_ErrTooManyPendingTasks struct {
	ErrTooManyPendingTasks *CompactErrorTooManyPendingTasks `protobuf:"bytes,4,opt,name=err_too_many_pending_tasks,json=errTooManyPendingTasks,oneof"`
}

func (*CompactError_ErrInvalidStartKey) isCompactError_Error()       {}
func (*CompactError_ErrPhysicalTableNotExist) isCompactError_Error() {}
func (*CompactError_ErrCompactInProgress) isCompactError_Error()     {}
func (*CompactError_ErrTooManyPendingTasks) isCompactError_Error()   {}

func (m *CompactError) GetError() isCompactError_Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CompactError) GetErrInvalidStartKey() *CompactErrorInvalidStartKey {
	if x, ok := m.GetError().(*CompactError_ErrInvalidStartKey); ok {
		return x.ErrInvalidStartKey
	}
	return nil
}

func (m *CompactError) GetErrPhysicalTableNotExist() *CompactErrorPhysicalTableNotExist {
	if x, ok := m.GetError().(*CompactError_ErrPhysicalTableNotExist); ok {
		return x.ErrPhysicalTableNotExist
	}
	return nil
}

func (m *CompactError) GetErrCompactInProgress() *CompactErrorCompactInProgress {
	if x, ok := m.GetError().(*CompactError_ErrCompactInProgress); ok {
		return x.ErrCompactInProgress
	}
	return nil
}

func (m *CompactError) GetErrTooManyPendingTasks() *CompactErrorTooManyPendingTasks {
	if x, ok := m.GetError().(*CompactError_ErrTooManyPendingTasks); ok {
		return x.ErrTooManyPendingTasks
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CompactError) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CompactError_OneofMarshaler, _CompactError_OneofUnmarshaler, _CompactError_OneofSizer, []interface{}{
		(*CompactError_ErrInvalidStartKey)(nil),
		(*CompactError_ErrPhysicalTableNotExist)(nil),
		(*CompactError_ErrCompactInProgress)(nil),
		(*CompactError_ErrTooManyPendingTasks)(nil),
	}
}

func _CompactError_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CompactError)
	// error
	switch x := m.Error.(type) {
	case *CompactError_ErrInvalidStartKey:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErrInvalidStartKey); err != nil {
			return err
		}
	case *CompactError_ErrPhysicalTableNotExist:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErrPhysicalTableNotExist); err != nil {
			return err
		}
	case *CompactError_ErrCompactInProgress:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErrCompactInProgress); err != nil {
			return err
		}
	case *CompactError_ErrTooManyPendingTasks:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErrTooManyPendingTasks); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CompactError.Error has unexpected type %T", x)
	}
	return nil
}

func _CompactError_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CompactError)
	switch tag {
	case 1: // error.err_invalid_start_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CompactErrorInvalidStartKey)
		err := b.DecodeMessage(msg)
		m.Error = &CompactError_ErrInvalidStartKey{msg}
		return true, err
	case 2: // error.err_physical_table_not_exist
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CompactErrorPhysicalTableNotExist)
		err := b.DecodeMessage(msg)
		m.Error = &CompactError_ErrPhysicalTableNotExist{msg}
		return true, err
	case 3: // error.err_compact_in_progress
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CompactErrorCompactInProgress)
		err := b.DecodeMessage(msg)
		m.Error = &CompactError_ErrCompactInProgress{msg}
		return true, err
	case 4: // error.err_too_many_pending_tasks
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CompactErrorTooManyPendingTasks)
		err := b.DecodeMessage(msg)
		m.Error = &CompactError_ErrTooManyPendingTasks{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CompactError_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CompactError)
	// error
	switch x := m.Error.(type) {
	case *CompactError_ErrInvalidStartKey:
		s := proto.Size(x.ErrInvalidStartKey)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CompactError_ErrPhysicalTableNotExist:
		s := proto.Size(x.ErrPhysicalTableNotExist)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CompactError_ErrCompactInProgress:
		s := proto.Size(x.ErrCompactInProgress)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CompactError_ErrTooManyPendingTasks:
		s := proto.Size(x.ErrTooManyPendingTasks)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CompactErrorInvalidStartKey struct {
}

func (m *CompactErrorInvalidStartKey) Reset()         { *m = CompactErrorInvalidStartKey{} }
func (m *CompactErrorInvalidStartKey) String() string { return proto.CompactTextString(m) }
func (*CompactErrorInvalidStartKey) ProtoMessage()    {}
func (*CompactErrorInvalidStartKey) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{123}
}

type CompactErrorPhysicalTableNotExist struct {
}

func (m *CompactErrorPhysicalTableNotExist) Reset()         { *m = CompactErrorPhysicalTableNotExist{} }
func (m *CompactErrorPhysicalTableNotExist) String() string { return proto.CompactTextString(m) }
func (*CompactErrorPhysicalTableNotExist) ProtoMessage()    {}
func (*CompactErrorPhysicalTableNotExist) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{124}
}

type CompactErrorCompactInProgress struct {
}

func (m *CompactErrorCompactInProgress) Reset()         { *m = CompactErrorCompactInProgress{} }
func (m *CompactErrorCompactInProgress) String() string { return proto.CompactTextString(m) }
func (*CompactErrorCompactInProgress) ProtoMessage()    {}
func (*CompactErrorCompactInProgress) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{125}
}

type CompactErrorTooManyPendingTasks struct {
}

func (m *CompactErrorTooManyPendingTasks) Reset()         { *m = CompactErrorTooManyPendingTasks{} }
func (m *CompactErrorTooManyPendingTasks) String() string { return proto.CompactTextString(m) }
func (*CompactErrorTooManyPendingTasks) ProtoMessage()    {}
func (*CompactErrorTooManyPendingTasks) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{126}
}

type CompactRequest struct {
	// If specified, the compaction will start from this start key.
	// If unspecified, the compaction will start from beginning.
	// NOTE 1: The start key should be never manually constructed. You should always use a key
	// returned in CompactResponse.
	// NOTE 2: the compaction range will be always restricted by physical_table_id.
	StartKey []byte `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// The physical table that will be compacted.
	//
	// TODO: this is information that TiKV doesn't need to know.
	// See https://github.com/pingcap/kvproto/issues/912
	PhysicalTableId int64 `protobuf:"varint,2,opt,name=physical_table_id,json=physicalTableId,proto3" json:"physical_table_id,omitempty"`
	// The logical table id of the compaction. When receiving parallel requests with the same
	// logical table id, err_compact_in_progress will be returned.
	//
	// TODO: this is information that TiKV doesn't need to know.
	// See https://github.com/pingcap/kvproto/issues/912
	LogicalTableId int64 `protobuf:"varint,3,opt,name=logical_table_id,json=logicalTableId,proto3" json:"logical_table_id,omitempty"`
	// API version of the request
	ApiVersion APIVersion `protobuf:"varint,7,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// Keyspace of the table located in.
	KeyspaceId uint32 `protobuf:"varint,8,opt,name=keyspace_id,json=keyspaceId,proto3" json:"keyspace_id,omitempty"`
}

func (m *CompactRequest) Reset()                    { *m = CompactRequest{} }
func (m *CompactRequest) String() string            { return proto.CompactTextString(m) }
func (*CompactRequest) ProtoMessage()               {}
func (*CompactRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{127} }

func (m *CompactRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *CompactRequest) GetPhysicalTableId() int64 {
	if m != nil {
		return m.PhysicalTableId
	}
	return 0
}

func (m *CompactRequest) GetLogicalTableId() int64 {
	if m != nil {
		return m.LogicalTableId
	}
	return 0
}

func (m *CompactRequest) GetApiVersion() APIVersion {
	if m != nil {
		return m.ApiVersion
	}
	return APIVersion_V1
}

func (m *CompactRequest) GetKeyspaceId() uint32 {
	if m != nil {
		return m.KeyspaceId
	}
	return 0
}

type CompactResponse struct {
	Error *CompactError `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// The compaction is done incrementally. If there are more data to compact, this field
	// will be set. The client can request to compact more data according to the `compacted_end_key`.
	HasRemaining      bool   `protobuf:"varint,2,opt,name=has_remaining,json=hasRemaining,proto3" json:"has_remaining,omitempty"`
	CompactedStartKey []byte `protobuf:"bytes,3,opt,name=compacted_start_key,json=compactedStartKey,proto3" json:"compacted_start_key,omitempty"`
	CompactedEndKey   []byte `protobuf:"bytes,4,opt,name=compacted_end_key,json=compactedEndKey,proto3" json:"compacted_end_key,omitempty"`
}

func (m *CompactResponse) Reset()                    { *m = CompactResponse{} }
func (m *CompactResponse) String() string            { return proto.CompactTextString(m) }
func (*CompactResponse) ProtoMessage()               {}
func (*CompactResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{128} }

func (m *CompactResponse) GetError() *CompactError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CompactResponse) GetHasRemaining() bool {
	if m != nil {
		return m.HasRemaining
	}
	return false
}

func (m *CompactResponse) GetCompactedStartKey() []byte {
	if m != nil {
		return m.CompactedStartKey
	}
	return nil
}

func (m *CompactResponse) GetCompactedEndKey() []byte {
	if m != nil {
		return m.CompactedEndKey
	}
	return nil
}

type TiFlashSystemTableRequest struct {
	Sql string `protobuf:"bytes,1,opt,name=sql,proto3" json:"sql,omitempty"`
}

func (m *TiFlashSystemTableRequest) Reset()         { *m = TiFlashSystemTableRequest{} }
func (m *TiFlashSystemTableRequest) String() string { return proto.CompactTextString(m) }
func (*TiFlashSystemTableRequest) ProtoMessage()    {}
func (*TiFlashSystemTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{129}
}

func (m *TiFlashSystemTableRequest) GetSql() string {
	if m != nil {
		return m.Sql
	}
	return ""
}

type TiFlashSystemTableResponse struct {
	Data github_com_pingcap_kvproto_pkg_sharedbytes.SharedBytes `protobuf:"bytes,1,opt,name=data,proto3,customtype=github.com/pingcap/kvproto/pkg/sharedbytes.SharedBytes" json:"data"`
}

func (m *TiFlashSystemTableResponse) Reset()         { *m = TiFlashSystemTableResponse{} }
func (m *TiFlashSystemTableResponse) String() string { return proto.CompactTextString(m) }
func (*TiFlashSystemTableResponse) ProtoMessage()    {}
func (*TiFlashSystemTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorKvrpcpb, []int{130}
}

type TxnEntry struct {
	// Types that are valid to be assigned to Entry:
	//	*TxnEntry_Prewrite_
	//	*TxnEntry_Commit_
	Entry isTxnEntry_Entry `protobuf_oneof:"entry"`
}

func (m *TxnEntry) Reset()                    { *m = TxnEntry{} }
func (m *TxnEntry) String() string            { return proto.CompactTextString(m) }
func (*TxnEntry) ProtoMessage()               {}
func (*TxnEntry) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{131} }

type isTxnEntry_Entry interface {
	isTxnEntry_Entry()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TxnEntry_Prewrite_ struct {
	Prewrite *TxnEntry_Prewrite `protobuf:"bytes,1,opt,name=prewrite,oneof"`
}
type TxnEntry_Commit_ struct {
	Commit *TxnEntry_Commit `protobuf:"bytes,2,opt,name=commit,oneof"`
}

func (*TxnEntry_Prewrite_) isTxnEntry_Entry() {}
func (*TxnEntry_Commit_) isTxnEntry_Entry()   {}

func (m *TxnEntry) GetEntry() isTxnEntry_Entry {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *TxnEntry) GetPrewrite() *TxnEntry_Prewrite {
	if x, ok := m.GetEntry().(*TxnEntry_Prewrite_); ok {
		return x.Prewrite
	}
	return nil
}

func (m *TxnEntry) GetCommit() *TxnEntry_Commit {
	if x, ok := m.GetEntry().(*TxnEntry_Commit_); ok {
		return x.Commit
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TxnEntry) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TxnEntry_OneofMarshaler, _TxnEntry_OneofUnmarshaler, _TxnEntry_OneofSizer, []interface{}{
		(*TxnEntry_Prewrite_)(nil),
		(*TxnEntry_Commit_)(nil),
	}
}

func _TxnEntry_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TxnEntry)
	// entry
	switch x := m.Entry.(type) {
	case *TxnEntry_Prewrite_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Prewrite); err != nil {
			return err
		}
	case *TxnEntry_Commit_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Commit); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TxnEntry.Entry has unexpected type %T", x)
	}
	return nil
}

func _TxnEntry_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TxnEntry)
	switch tag {
	case 1: // entry.prewrite
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TxnEntry_Prewrite)
		err := b.DecodeMessage(msg)
		m.Entry = &TxnEntry_Prewrite_{msg}
		return true, err
	case 2: // entry.commit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TxnEntry_Commit)
		err := b.DecodeMessage(msg)
		m.Entry = &TxnEntry_Commit_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TxnEntry_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TxnEntry)
	// entry
	switch x := m.Entry.(type) {
	case *TxnEntry_Prewrite_:
		s := proto.Size(x.Prewrite)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TxnEntry_Commit_:
		s := proto.Size(x.Commit)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TxnEntry_Prewrite struct {
	Key        []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value      []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	StartTs    uint64 `protobuf:"varint,3,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	PrimaryKey []byte `protobuf:"bytes,4,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
}

func (m *TxnEntry_Prewrite) Reset()                    { *m = TxnEntry_Prewrite{} }
func (m *TxnEntry_Prewrite) String() string            { return proto.CompactTextString(m) }
func (*TxnEntry_Prewrite) ProtoMessage()               {}
func (*TxnEntry_Prewrite) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{131, 0} }

func (m *TxnEntry_Prewrite) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *TxnEntry_Prewrite) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TxnEntry_Prewrite) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *TxnEntry_Prewrite) GetPrimaryKey() []byte {
	if m != nil {
		return m.PrimaryKey
	}
	return nil
}

type TxnEntry_Commit struct {
	Key      []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value    []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	StartTs  uint64 `protobuf:"varint,3,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	CommitTs uint64 `protobuf:"varint,4,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
}

func (m *TxnEntry_Commit) Reset()                    { *m = TxnEntry_Commit{} }
func (m *TxnEntry_Commit) String() string            { return proto.CompactTextString(m) }
func (*TxnEntry_Commit) ProtoMessage()               {}
func (*TxnEntry_Commit) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{131, 1} }

func (m *TxnEntry_Commit) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *TxnEntry_Commit) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TxnEntry_Commit) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *TxnEntry_Commit) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

// ScanTxnEntriesRequest is like ScanRequest, but retrieves transaction entries
// instead of key-value pairs.
type ScanTxnEntriesRequest struct {
	Context *Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// start_key and end_key must be specified, however limit is optional.
	// by default limit is 0, which means no limit.
	StartKey []byte `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	Limit    uint32 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	KeyOnly  bool   `protobuf:"varint,5,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	// entries will be filtered by commit_ts >= start_ts.
	// uncommitted entries will be kept.
	StartTs uint64 `protobuf:"varint,6,opt,name=start_ts,json=startTs,proto3" json:"start_ts,omitempty"`
	// only keeps specified versions at most for every key.
	// default is 0, which means all versions will be kept.
	VersionsPerKey uint32 `protobuf:"varint,7,opt,name=versions_per_key,json=versionsPerKey,proto3" json:"versions_per_key,omitempty"`
}

func (m *ScanTxnEntriesRequest) Reset()                    { *m = ScanTxnEntriesRequest{} }
func (m *ScanTxnEntriesRequest) String() string            { return proto.CompactTextString(m) }
func (*ScanTxnEntriesRequest) ProtoMessage()               {}
func (*ScanTxnEntriesRequest) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{132} }

func (m *ScanTxnEntriesRequest) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ScanTxnEntriesRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *ScanTxnEntriesRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *ScanTxnEntriesRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ScanTxnEntriesRequest) GetKeyOnly() bool {
	if m != nil {
		return m.KeyOnly
	}
	return false
}

func (m *ScanTxnEntriesRequest) GetStartTs() uint64 {
	if m != nil {
		return m.StartTs
	}
	return 0
}

func (m *ScanTxnEntriesRequest) GetVersionsPerKey() uint32 {
	if m != nil {
		return m.VersionsPerKey
	}
	return 0
}

type ScanTxnEntriesResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	Entries     []*TxnEntry    `protobuf:"bytes,2,rep,name=entries" json:"entries,omitempty"`
}

func (m *ScanTxnEntriesResponse) Reset()                    { *m = ScanTxnEntriesResponse{} }
func (m *ScanTxnEntriesResponse) String() string            { return proto.CompactTextString(m) }
func (*ScanTxnEntriesResponse) ProtoMessage()               {}
func (*ScanTxnEntriesResponse) Descriptor() ([]byte, []int) { return fileDescriptorKvrpcpb, []int{133} }

func (m *ScanTxnEntriesResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *ScanTxnEntriesResponse) GetEntries() []*TxnEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func init() {
	proto.RegisterType((*GetRequest)(nil), "kvrpcpb.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "kvrpcpb.GetResponse")
	proto.RegisterType((*ScanRequest)(nil), "kvrpcpb.ScanRequest")
	proto.RegisterType((*ScanResponse)(nil), "kvrpcpb.ScanResponse")
	proto.RegisterType((*PrewriteRequest)(nil), "kvrpcpb.PrewriteRequest")
	proto.RegisterType((*PrewriteRequest_ForUpdateTSConstraint)(nil), "kvrpcpb.PrewriteRequest.ForUpdateTSConstraint")
	proto.RegisterType((*PrewriteResponse)(nil), "kvrpcpb.PrewriteResponse")
	proto.RegisterType((*PessimisticLockRequest)(nil), "kvrpcpb.PessimisticLockRequest")
	proto.RegisterType((*PessimisticLockKeyResult)(nil), "kvrpcpb.PessimisticLockKeyResult")
	proto.RegisterType((*PessimisticLockResponse)(nil), "kvrpcpb.PessimisticLockResponse")
	proto.RegisterType((*PessimisticRollbackRequest)(nil), "kvrpcpb.PessimisticRollbackRequest")
	proto.RegisterType((*PessimisticRollbackResponse)(nil), "kvrpcpb.PessimisticRollbackResponse")
	proto.RegisterType((*TxnHeartBeatRequest)(nil), "kvrpcpb.TxnHeartBeatRequest")
	proto.RegisterType((*TxnHeartBeatResponse)(nil), "kvrpcpb.TxnHeartBeatResponse")
	proto.RegisterType((*CheckTxnStatusRequest)(nil), "kvrpcpb.CheckTxnStatusRequest")
	proto.RegisterType((*CheckTxnStatusResponse)(nil), "kvrpcpb.CheckTxnStatusResponse")
	proto.RegisterType((*CheckSecondaryLocksRequest)(nil), "kvrpcpb.CheckSecondaryLocksRequest")
	proto.RegisterType((*CheckSecondaryLocksResponse)(nil), "kvrpcpb.CheckSecondaryLocksResponse")
	proto.RegisterType((*CommitRequest)(nil), "kvrpcpb.CommitRequest")
	proto.RegisterType((*CommitResponse)(nil), "kvrpcpb.CommitResponse")
	proto.RegisterType((*ImportRequest)(nil), "kvrpcpb.ImportRequest")
	proto.RegisterType((*ImportResponse)(nil), "kvrpcpb.ImportResponse")
	proto.RegisterType((*CleanupRequest)(nil), "kvrpcpb.CleanupRequest")
	proto.RegisterType((*CleanupResponse)(nil), "kvrpcpb.CleanupResponse")
	proto.RegisterType((*BatchGetRequest)(nil), "kvrpcpb.BatchGetRequest")
	proto.RegisterType((*BatchGetResponse)(nil), "kvrpcpb.BatchGetResponse")
	proto.RegisterType((*BatchRollbackRequest)(nil), "kvrpcpb.BatchRollbackRequest")
	proto.RegisterType((*BatchRollbackResponse)(nil), "kvrpcpb.BatchRollbackResponse")
	proto.RegisterType((*ScanLockRequest)(nil), "kvrpcpb.ScanLockRequest")
	proto.RegisterType((*ScanLockResponse)(nil), "kvrpcpb.ScanLockResponse")
	proto.RegisterType((*ResolveLockRequest)(nil), "kvrpcpb.ResolveLockRequest")
	proto.RegisterType((*ResolveLockResponse)(nil), "kvrpcpb.ResolveLockResponse")
	proto.RegisterType((*GCRequest)(nil), "kvrpcpb.GCRequest")
	proto.RegisterType((*GCResponse)(nil), "kvrpcpb.GCResponse")
	proto.RegisterType((*DeleteRangeRequest)(nil), "kvrpcpb.DeleteRangeRequest")
	proto.RegisterType((*DeleteRangeResponse)(nil), "kvrpcpb.DeleteRangeResponse")
	proto.RegisterType((*PrepareFlashbackToVersionRequest)(nil), "kvrpcpb.PrepareFlashbackToVersionRequest")
	proto.RegisterType((*PrepareFlashbackToVersionResponse)(nil), "kvrpcpb.PrepareFlashbackToVersionResponse")
	proto.RegisterType((*FlashbackToVersionRequest)(nil), "kvrpcpb.FlashbackToVersionRequest")
	proto.RegisterType((*FlashbackToVersionResponse)(nil), "kvrpcpb.FlashbackToVersionResponse")
	proto.RegisterType((*RawGetRequest)(nil), "kvrpcpb.RawGetRequest")
	proto.RegisterType((*RawGetResponse)(nil), "kvrpcpb.RawGetResponse")
	proto.RegisterType((*RawBatchGetRequest)(nil), "kvrpcpb.RawBatchGetRequest")
	proto.RegisterType((*RawBatchGetResponse)(nil), "kvrpcpb.RawBatchGetResponse")
	proto.RegisterType((*RawPutRequest)(nil), "kvrpcpb.RawPutRequest")
	proto.RegisterType((*RawPutResponse)(nil), "kvrpcpb.RawPutResponse")
	proto.RegisterType((*RawBatchPutRequest)(nil), "kvrpcpb.RawBatchPutRequest")
	proto.RegisterType((*RawBatchPutResponse)(nil), "kvrpcpb.RawBatchPutResponse")
	proto.RegisterType((*RawDeleteRequest)(nil), "kvrpcpb.RawDeleteRequest")
	proto.RegisterType((*RawDeleteResponse)(nil), "kvrpcpb.RawDeleteResponse")
	proto.RegisterType((*RawBatchDeleteRequest)(nil), "kvrpcpb.RawBatchDeleteRequest")
	proto.RegisterType((*RawBatchDeleteResponse)(nil), "kvrpcpb.RawBatchDeleteResponse")
	proto.RegisterType((*RawScanRequest)(nil), "kvrpcpb.RawScanRequest")
	proto.RegisterType((*RawScanResponse)(nil), "kvrpcpb.RawScanResponse")
	proto.RegisterType((*RawDeleteRangeRequest)(nil), "kvrpcpb.RawDeleteRangeRequest")
	proto.RegisterType((*RawDeleteRangeResponse)(nil), "kvrpcpb.RawDeleteRangeResponse")
	proto.RegisterType((*RawBatchScanRequest)(nil), "kvrpcpb.RawBatchScanRequest")
	proto.RegisterType((*RawBatchScanResponse)(nil), "kvrpcpb.RawBatchScanResponse")
	proto.RegisterType((*UnsafeDestroyRangeRequest)(nil), "kvrpcpb.UnsafeDestroyRangeRequest")
	proto.RegisterType((*UnsafeDestroyRangeResponse)(nil), "kvrpcpb.UnsafeDestroyRangeResponse")
	proto.RegisterType((*RegisterLockObserverRequest)(nil), "kvrpcpb.RegisterLockObserverRequest")
	proto.RegisterType((*RegisterLockObserverResponse)(nil), "kvrpcpb.RegisterLockObserverResponse")
	proto.RegisterType((*CheckLockObserverRequest)(nil), "kvrpcpb.CheckLockObserverRequest")
	proto.RegisterType((*CheckLockObserverResponse)(nil), "kvrpcpb.CheckLockObserverResponse")
	proto.RegisterType((*RemoveLockObserverRequest)(nil), "kvrpcpb.RemoveLockObserverRequest")
	proto.RegisterType((*RemoveLockObserverResponse)(nil), "kvrpcpb.RemoveLockObserverResponse")
	proto.RegisterType((*PhysicalScanLockRequest)(nil), "kvrpcpb.PhysicalScanLockRequest")
	proto.RegisterType((*PhysicalScanLockResponse)(nil), "kvrpcpb.PhysicalScanLockResponse")
	proto.RegisterType((*SplitRegionRequest)(nil), "kvrpcpb.SplitRegionRequest")
	proto.RegisterType((*SplitRegionResponse)(nil), "kvrpcpb.SplitRegionResponse")
	proto.RegisterType((*ReadIndexRequest)(nil), "kvrpcpb.ReadIndexRequest")
	proto.RegisterType((*ReadIndexResponse)(nil), "kvrpcpb.ReadIndexResponse")
	proto.RegisterType((*MvccGetByKeyRequest)(nil), "kvrpcpb.MvccGetByKeyRequest")
	proto.RegisterType((*MvccGetByKeyResponse)(nil), "kvrpcpb.MvccGetByKeyResponse")
	proto.RegisterType((*MvccGetByStartTsRequest)(nil), "kvrpcpb.MvccGetByStartTsRequest")
	proto.RegisterType((*MvccGetByStartTsResponse)(nil), "kvrpcpb.MvccGetByStartTsResponse")
	proto.RegisterType((*Context)(nil), "kvrpcpb.Context")
	proto.RegisterType((*ResourceControlContext)(nil), "kvrpcpb.ResourceControlContext")
	proto.RegisterType((*SourceStmt)(nil), "kvrpcpb.SourceStmt")
	proto.RegisterType((*LockInfo)(nil), "kvrpcpb.LockInfo")
	proto.RegisterType((*KeyError)(nil), "kvrpcpb.KeyError")
	proto.RegisterType((*WriteConflict)(nil), "kvrpcpb.WriteConflict")
	proto.RegisterType((*AlreadyExist)(nil), "kvrpcpb.AlreadyExist")
	proto.RegisterType((*Deadlock)(nil), "kvrpcpb.Deadlock")
	proto.RegisterType((*CommitTsExpired)(nil), "kvrpcpb.CommitTsExpired")
	proto.RegisterType((*TxnNotFound)(nil), "kvrpcpb.TxnNotFound")
	proto.RegisterType((*CommitTsTooLarge)(nil), "kvrpcpb.CommitTsTooLarge")
	proto.RegisterType((*AssertionFailed)(nil), "kvrpcpb.AssertionFailed")
	proto.RegisterType((*PrimaryMismatch)(nil), "kvrpcpb.PrimaryMismatch")
	proto.RegisterType((*TimeDetail)(nil), "kvrpcpb.TimeDetail")
	proto.RegisterType((*TimeDetailV2)(nil), "kvrpcpb.TimeDetailV2")
	proto.RegisterType((*ScanInfo)(nil), "kvrpcpb.ScanInfo")
	proto.RegisterType((*ScanDetail)(nil), "kvrpcpb.ScanDetail")
	proto.RegisterType((*ScanDetailV2)(nil), "kvrpcpb.ScanDetailV2")
	proto.RegisterType((*ExecDetails)(nil), "kvrpcpb.ExecDetails")
	proto.RegisterType((*ExecDetailsV2)(nil), "kvrpcpb.ExecDetailsV2")
	proto.RegisterType((*WriteDetail)(nil), "kvrpcpb.WriteDetail")
	proto.RegisterType((*KvPair)(nil), "kvrpcpb.KvPair")
	proto.RegisterType((*Mutation)(nil), "kvrpcpb.Mutation")
	proto.RegisterType((*MvccWrite)(nil), "kvrpcpb.MvccWrite")
	proto.RegisterType((*MvccValue)(nil), "kvrpcpb.MvccValue")
	proto.RegisterType((*MvccLock)(nil), "kvrpcpb.MvccLock")
	proto.RegisterType((*MvccInfo)(nil), "kvrpcpb.MvccInfo")
	proto.RegisterType((*TxnInfo)(nil), "kvrpcpb.TxnInfo")
	proto.RegisterType((*KeyRange)(nil), "kvrpcpb.KeyRange")
	proto.RegisterType((*LeaderInfo)(nil), "kvrpcpb.LeaderInfo")
	proto.RegisterType((*ReadState)(nil), "kvrpcpb.ReadState")
	proto.RegisterType((*CheckLeaderRequest)(nil), "kvrpcpb.CheckLeaderRequest")
	proto.RegisterType((*CheckLeaderResponse)(nil), "kvrpcpb.CheckLeaderResponse")
	proto.RegisterType((*StoreSafeTSRequest)(nil), "kvrpcpb.StoreSafeTSRequest")
	proto.RegisterType((*StoreSafeTSResponse)(nil), "kvrpcpb.StoreSafeTSResponse")
	proto.RegisterType((*RawGetKeyTTLRequest)(nil), "kvrpcpb.RawGetKeyTTLRequest")
	proto.RegisterType((*RawGetKeyTTLResponse)(nil), "kvrpcpb.RawGetKeyTTLResponse")
	proto.RegisterType((*RawCASRequest)(nil), "kvrpcpb.RawCASRequest")
	proto.RegisterType((*RawCASResponse)(nil), "kvrpcpb.RawCASResponse")
	proto.RegisterType((*GetLockWaitInfoRequest)(nil), "kvrpcpb.GetLockWaitInfoRequest")
	proto.RegisterType((*GetLockWaitInfoResponse)(nil), "kvrpcpb.GetLockWaitInfoResponse")
	proto.RegisterType((*GetLockWaitHistoryRequest)(nil), "kvrpcpb.GetLockWaitHistoryRequest")
	proto.RegisterType((*GetLockWaitHistoryResponse)(nil), "kvrpcpb.GetLockWaitHistoryResponse")
	proto.RegisterType((*RawCoprocessorRequest)(nil), "kvrpcpb.RawCoprocessorRequest")
	proto.RegisterType((*RawCoprocessorResponse)(nil), "kvrpcpb.RawCoprocessorResponse")
	proto.RegisterType((*RawChecksumRequest)(nil), "kvrpcpb.RawChecksumRequest")
	proto.RegisterType((*RawChecksumResponse)(nil), "kvrpcpb.RawChecksumResponse")
	proto.RegisterType((*CompactError)(nil), "kvrpcpb.CompactError")
	proto.RegisterType((*CompactErrorInvalidStartKey)(nil), "kvrpcpb.CompactErrorInvalidStartKey")
	proto.RegisterType((*CompactErrorPhysicalTableNotExist)(nil), "kvrpcpb.CompactErrorPhysicalTableNotExist")
	proto.RegisterType((*CompactErrorCompactInProgress)(nil), "kvrpcpb.CompactErrorCompactInProgress")
	proto.RegisterType((*CompactErrorTooManyPendingTasks)(nil), "kvrpcpb.CompactErrorTooManyPendingTasks")
	proto.RegisterType((*CompactRequest)(nil), "kvrpcpb.CompactRequest")
	proto.RegisterType((*CompactResponse)(nil), "kvrpcpb.CompactResponse")
	proto.RegisterType((*TiFlashSystemTableRequest)(nil), "kvrpcpb.TiFlashSystemTableRequest")
	proto.RegisterType((*TiFlashSystemTableResponse)(nil), "kvrpcpb.TiFlashSystemTableResponse")
	proto.RegisterType((*TxnEntry)(nil), "kvrpcpb.TxnEntry")
	proto.RegisterType((*TxnEntry_Prewrite)(nil), "kvrpcpb.TxnEntry.Prewrite")
	proto.RegisterType((*TxnEntry_Commit)(nil), "kvrpcpb.TxnEntry.Commit")
	proto.RegisterType((*ScanTxnEntriesRequest)(nil), "kvrpcpb.ScanTxnEntriesRequest")
	proto.RegisterType((*ScanTxnEntriesResponse)(nil), "kvrpcpb.ScanTxnEntriesResponse")
	proto.RegisterEnum("kvrpcpb.PessimisticLockWakeUpMode", PessimisticLockWakeUpMode_name, PessimisticLockWakeUpMode_value)
	proto.RegisterEnum("kvrpcpb.PessimisticLockKeyResultType", PessimisticLockKeyResultType_name, PessimisticLockKeyResultType_value)
	proto.RegisterEnum("kvrpcpb.APIVersion", APIVersion_name, APIVersion_value)
	proto.RegisterEnum("kvrpcpb.CommandPri", CommandPri_name, CommandPri_value)
	proto.RegisterEnum("kvrpcpb.IsolationLevel", IsolationLevel_name, IsolationLevel_value)
	proto.RegisterEnum("kvrpcpb.DiskFullOpt", DiskFullOpt_name, DiskFullOpt_value)
	proto.RegisterEnum("kvrpcpb.Op", Op_name, Op_value)
	proto.RegisterEnum("kvrpcpb.Assertion", Assertion_name, Assertion_value)
	proto.RegisterEnum("kvrpcpb.AssertionLevel", AssertionLevel_name, AssertionLevel_value)
	proto.RegisterEnum("kvrpcpb.Action", Action_name, Action_value)
	proto.RegisterEnum("kvrpcpb.ExtraOp", ExtraOp_name, ExtraOp_value)
	proto.RegisterEnum("kvrpcpb.ChecksumAlgorithm", ChecksumAlgorithm_name, ChecksumAlgorithm_value)
	proto.RegisterEnum("kvrpcpb.PrewriteRequest_PessimisticAction", PrewriteRequest_PessimisticAction_name, PrewriteRequest_PessimisticAction_value)
	proto.RegisterEnum("kvrpcpb.WriteConflict_Reason", WriteConflict_Reason_name, WriteConflict_Reason_value)
}
func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n1, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *GetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n2, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n3, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.NotFound {
		dAtA[i] = 0x20
		i++
		if m.NotFound {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n4, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n5, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Limit))
	}
	if m.Version != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Version))
	}
	if m.KeyOnly {
		dAtA[i] = 0x28
		i++
		if m.KeyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Reverse {
		dAtA[i] = 0x30
		i++
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.SampleStep != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.SampleStep))
	}
	return i, nil
}

func (m *ScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n6, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Error != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n7, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *PrewriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrewriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n8, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Mutations) > 0 {
		for _, msg := range m.Mutations {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PrimaryLock) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.PrimaryLock)))
		i += copy(dAtA[i:], m.PrimaryLock)
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartVersion))
	}
	if m.LockTtl != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockTtl))
	}
	if m.SkipConstraintCheck {
		dAtA[i] = 0x30
		i++
		if m.SkipConstraintCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PessimisticActions) > 0 {
		dAtA10 := make([]byte, len(m.PessimisticActions)*10)
		var j9 int
		for _, num := range m.PessimisticActions {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if m.TxnSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TxnSize))
	}
	if m.ForUpdateTs != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ForUpdateTs))
	}
	if m.MinCommitTs != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MinCommitTs))
	}
	if m.UseAsyncCommit {
		dAtA[i] = 0x58
		i++
		if m.UseAsyncCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Secondaries) > 0 {
		for _, b := range m.Secondaries {
			dAtA[i] = 0x62
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.TryOnePc {
		dAtA[i] = 0x68
		i++
		if m.TryOnePc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxCommitTs != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MaxCommitTs))
	}
	if m.AssertionLevel != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.AssertionLevel))
	}
	if len(m.ForUpdateTsConstraints) > 0 {
		for _, msg := range m.ForUpdateTsConstraints {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PrewriteRequest_ForUpdateTSConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrewriteRequest_ForUpdateTSConstraint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Index))
	}
	if m.ExpectedForUpdateTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExpectedForUpdateTs))
	}
	return i, nil
}

func (m *PrewriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrewriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n11, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MinCommitTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MinCommitTs))
	}
	if m.OnePcCommitTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.OnePcCommitTs))
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n12, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *PessimisticLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PessimisticLockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n13, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Mutations) > 0 {
		for _, msg := range m.Mutations {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PrimaryLock) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.PrimaryLock)))
		i += copy(dAtA[i:], m.PrimaryLock)
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartVersion))
	}
	if m.LockTtl != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockTtl))
	}
	if m.ForUpdateTs != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ForUpdateTs))
	}
	if m.IsFirstLock {
		dAtA[i] = 0x38
		i++
		if m.IsFirstLock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WaitTimeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.WaitTimeout))
	}
	if m.Force {
		dAtA[i] = 0x48
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReturnValues {
		dAtA[i] = 0x50
		i++
		if m.ReturnValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MinCommitTs != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MinCommitTs))
	}
	if m.CheckExistence {
		dAtA[i] = 0x60
		i++
		if m.CheckExistence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LockOnlyIfExists {
		dAtA[i] = 0x68
		i++
		if m.LockOnlyIfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WakeUpMode != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.WakeUpMode))
	}
	return i, nil
}

func (m *PessimisticLockKeyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PessimisticLockKeyResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Type))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Existence {
		dAtA[i] = 0x18
		i++
		if m.Existence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LockedWithConflictTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockedWithConflictTs))
	}
	if m.SkipResolvingLock {
		dAtA[i] = 0x58
		i++
		if m.SkipResolvingLock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PessimisticLockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PessimisticLockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n14, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitTs))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.NotFounds) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.NotFounds)))
		for _, b := range m.NotFounds {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n15, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x42
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PessimisticRollbackRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PessimisticRollbackRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n16, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartVersion))
	}
	if m.ForUpdateTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ForUpdateTs))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x22
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *PessimisticRollbackResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PessimisticRollbackResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n17, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n18, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *TxnHeartBeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnHeartBeatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n19, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.PrimaryLock) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.PrimaryLock)))
		i += copy(dAtA[i:], m.PrimaryLock)
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartVersion))
	}
	if m.AdviseLockTtl != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.AdviseLockTtl))
	}
	return i, nil
}

func (m *TxnHeartBeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnHeartBeatResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n20, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n21, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.LockTtl != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockTtl))
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n22, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *CheckTxnStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckTxnStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n23, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.PrimaryKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.PrimaryKey)))
		i += copy(dAtA[i:], m.PrimaryKey)
	}
	if m.LockTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockTs))
	}
	if m.CallerStartTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CallerStartTs))
	}
	if m.CurrentTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CurrentTs))
	}
	if m.RollbackIfNotExist {
		dAtA[i] = 0x30
		i++
		if m.RollbackIfNotExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ForceSyncCommit {
		dAtA[i] = 0x38
		i++
		if m.ForceSyncCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ResolvingPessimisticLock {
		dAtA[i] = 0x40
		i++
		if m.ResolvingPessimisticLock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.VerifyIsPrimary {
		dAtA[i] = 0x48
		i++
		if m.VerifyIsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CheckTxnStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckTxnStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n24, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n25, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.LockTtl != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockTtl))
	}
	if m.CommitVersion != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitVersion))
	}
	if m.Action != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Action))
	}
	if m.LockInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockInfo.Size()))
		n26, err := m.LockInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n27, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *CheckSecondaryLocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckSecondaryLocksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n28, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartVersion))
	}
	return i, nil
}

func (m *CheckSecondaryLocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckSecondaryLocksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n29, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n30, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Locks) > 0 {
		for _, msg := range m.Locks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitTs))
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n31, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *CommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n32, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartVersion))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.CommitVersion != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitVersion))
	}
	return i, nil
}

func (m *CommitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n33, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n34, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.CommitVersion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitVersion))
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n35, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *ImportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mutations) > 0 {
		for _, msg := range m.Mutations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CommitVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitVersion))
	}
	return i, nil
}

func (m *ImportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n36, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *CleanupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n37, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartVersion))
	}
	if m.CurrentTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CurrentTs))
	}
	return i, nil
}

func (m *CleanupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanupResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n38, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n39, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.CommitVersion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitVersion))
	}
	return i, nil
}

func (m *BatchGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n40, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *BatchGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n41, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n42, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Error != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n43, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *BatchRollbackRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchRollbackRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n44, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartVersion))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *BatchRollbackResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchRollbackResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n45, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n46, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n47, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *ScanLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanLockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n48, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.MaxVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MaxVersion))
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Limit))
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	return i, nil
}

func (m *ScanLockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanLockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n49, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n50, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if len(m.Locks) > 0 {
		for _, msg := range m.Locks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n51, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *ResolveLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveLockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n52, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.StartVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartVersion))
	}
	if m.CommitVersion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitVersion))
	}
	if len(m.TxnInfos) > 0 {
		for _, msg := range m.TxnInfos {
			dAtA[i] = 0x22
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *ResolveLockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveLockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n53, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n54, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.ExecDetailsV2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExecDetailsV2.Size()))
		n55, err := m.ExecDetailsV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *GCRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n56, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.SafePoint != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.SafePoint))
	}
	return i, nil
}

func (m *GCResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n57, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n58, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}

func (m *DeleteRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n59, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.NotifyOnly {
		dAtA[i] = 0x20
		i++
		if m.NotifyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeleteRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n60, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *PrepareFlashbackToVersionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareFlashbackToVersionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n61, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if m.Version != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *PrepareFlashbackToVersionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareFlashbackToVersionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n62, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *FlashbackToVersionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashbackToVersionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n63, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Version))
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitTs))
	}
	return i, nil
}

func (m *FlashbackToVersionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlashbackToVersionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n64, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *RawGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n65, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	return i, nil
}

func (m *RawGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n66, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.NotFound {
		dAtA[i] = 0x20
		i++
		if m.NotFound {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RawBatchGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawBatchGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n67, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	return i, nil
}

func (m *RawBatchGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawBatchGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n68, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawPutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawPutRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n69, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Ttl))
	}
	if m.ForCas {
		dAtA[i] = 0x30
		i++
		if m.ForCas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RawPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawPutResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n70, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *RawBatchPutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawBatchPutRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n71, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Ttl))
	}
	if m.ForCas {
		dAtA[i] = 0x28
		i++
		if m.ForCas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Ttls) > 0 {
		dAtA73 := make([]byte, len(m.Ttls)*10)
		var j72 int
		for _, num := range m.Ttls {
			for num >= 1<<7 {
				dAtA73[j72] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j72++
			}
			dAtA73[j72] = uint8(num)
			j72++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(j72))
		i += copy(dAtA[i:], dAtA73[:j72])
	}
	return i, nil
}

func (m *RawBatchPutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawBatchPutResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n74, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *RawDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n75, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	if m.ForCas {
		dAtA[i] = 0x20
		i++
		if m.ForCas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RawDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n76, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *RawBatchDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawBatchDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n77, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	if m.ForCas {
		dAtA[i] = 0x20
		i++
		if m.ForCas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RawBatchDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawBatchDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n78, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *RawScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawScanRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n79, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Limit))
	}
	if m.KeyOnly {
		dAtA[i] = 0x20
		i++
		if m.KeyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	if m.Reverse {
		dAtA[i] = 0x30
		i++
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	return i, nil
}

func (m *RawScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawScanResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n80, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if len(m.Kvs) > 0 {
		for _, msg := range m.Kvs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawDeleteRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawDeleteRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n81, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	return i, nil
}

func (m *RawDeleteRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawDeleteRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n82, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *RawBatchScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawBatchScanRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n83, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.EachLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.EachLimit))
	}
	if m.KeyOnly {
		dAtA[i] = 0x20
		i++
		if m.KeyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	if m.Reverse {
		dAtA[i] = 0x30
		i++
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RawBatchScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawBatchScanResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n84, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if len(m.Kvs) > 0 {
		for _, msg := range m.Kvs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UnsafeDestroyRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsafeDestroyRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n85, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	return i, nil
}

func (m *UnsafeDestroyRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsafeDestroyRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n86, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *RegisterLockObserverRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterLockObserverRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n87, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.MaxTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MaxTs))
	}
	return i, nil
}

func (m *RegisterLockObserverResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterLockObserverResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *CheckLockObserverRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckLockObserverRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n88, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.MaxTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MaxTs))
	}
	return i, nil
}

func (m *CheckLockObserverResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckLockObserverResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.IsClean {
		dAtA[i] = 0x10
		i++
		if m.IsClean {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Locks) > 0 {
		for _, msg := range m.Locks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RemoveLockObserverRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveLockObserverRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n89, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if m.MaxTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MaxTs))
	}
	return i, nil
}

func (m *RemoveLockObserverResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveLockObserverResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *PhysicalScanLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalScanLockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n90, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if m.MaxTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MaxTs))
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *PhysicalScanLockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhysicalScanLockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Locks) > 0 {
		for _, msg := range m.Locks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SplitRegionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitRegionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n91, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if len(m.SplitKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.SplitKey)))
		i += copy(dAtA[i:], m.SplitKey)
	}
	if len(m.SplitKeys) > 0 {
		for _, b := range m.SplitKeys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.IsRawKv {
		dAtA[i] = 0x20
		i++
		if m.IsRawKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SplitRegionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitRegionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n92, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.Left != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Left.Size()))
		n93, err := m.Left.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	if m.Right != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Right.Size()))
		n94, err := m.Right.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	if len(m.Regions) > 0 {
		for _, msg := range m.Regions {
			dAtA[i] = 0x22
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReadIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n95, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReadIndexResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadIndexResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n96, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	if m.ReadIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ReadIndex))
	}
	if m.Locked != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Locked.Size()))
		n97, err := m.Locked.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	return i, nil
}

func (m *MvccGetByKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccGetByKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n98, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *MvccGetByKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccGetByKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n99, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Info != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Info.Size()))
		n100, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n100
	}
	return i, nil
}

func (m *MvccGetByStartTsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccGetByStartTsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n101, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	return i, nil
}

func (m *MvccGetByStartTsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccGetByStartTsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n102, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n102
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Info != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Info.Size()))
		n103, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	return i, nil
}

func (m *Context) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Context) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionId))
	}
	if m.RegionEpoch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionEpoch.Size()))
		n104, err := m.RegionEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	if m.Peer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Peer.Size()))
		n105, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	if m.Term != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Term))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Priority))
	}
	if m.IsolationLevel != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.IsolationLevel))
	}
	if m.NotFillCache {
		dAtA[i] = 0x40
		i++
		if m.NotFillCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SyncLog {
		dAtA[i] = 0x48
		i++
		if m.SyncLog {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RecordTimeStat {
		dAtA[i] = 0x50
		i++
		if m.RecordTimeStat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RecordScanStat {
		dAtA[i] = 0x58
		i++
		if m.RecordScanStat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplicaRead {
		dAtA[i] = 0x60
		i++
		if m.ReplicaRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ResolvedLocks) > 0 {
		dAtA107 := make([]byte, len(m.ResolvedLocks)*10)
		var j106 int
		for _, num := range m.ResolvedLocks {
			for num >= 1<<7 {
				dAtA107[j106] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j106++
			}
			dAtA107[j106] = uint8(num)
			j106++
		}
		dAtA[i] = 0x6a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(j106))
		i += copy(dAtA[i:], dAtA107[:j106])
	}
	if m.MaxExecutionDurationMs != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MaxExecutionDurationMs))
	}
	if m.AppliedIndex != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.AppliedIndex))
	}
	if m.TaskId != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TaskId))
	}
	if m.StaleRead {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.StaleRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ResourceGroupTag) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.ResourceGroupTag)))
		i += copy(dAtA[i:], m.ResourceGroupTag)
	}
	if m.DiskFullOpt != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.DiskFullOpt))
	}
	if m.IsRetryRequest {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsRetryRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ApiVersion != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ApiVersion))
	}
	if len(m.CommittedLocks) > 0 {
		dAtA109 := make([]byte, len(m.CommittedLocks)*10)
		var j108 int
		for _, num := range m.CommittedLocks {
			for num >= 1<<7 {
				dAtA109[j108] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j108++
			}
			dAtA109[j108] = uint8(num)
			j108++
		}
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(j108))
		i += copy(dAtA[i:], dAtA109[:j108])
	}
	if m.TraceContext != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TraceContext.Size()))
		n110, err := m.TraceContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	if len(m.RequestSource) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.RequestSource)))
		i += copy(dAtA[i:], m.RequestSource)
	}
	if m.TxnSource != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TxnSource))
	}
	if m.BusyThresholdMs != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.BusyThresholdMs))
	}
	if m.ResourceControlContext != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ResourceControlContext.Size()))
		n111, err := m.ResourceControlContext.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	if m.KeyspaceId != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.KeyspaceId))
	}
	if m.BucketsVersion != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.BucketsVersion))
	}
	if m.SourceStmt != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.SourceStmt.Size()))
		n112, err := m.SourceStmt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n112
	}
	return i, nil
}

func (m *ResourceControlContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceControlContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceGroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.ResourceGroupName)))
		i += copy(dAtA[i:], m.ResourceGroupName)
	}
	if m.Penalty != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Penalty.Size()))
		n113, err := m.Penalty.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n113
	}
	if m.OverridePriority != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.OverridePriority))
	}
	return i, nil
}

func (m *SourceStmt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceStmt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if m.ConnectionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ConnectionId))
	}
	if m.StmtId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StmtId))
	}
	if len(m.SessionAlias) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.SessionAlias)))
		i += copy(dAtA[i:], m.SessionAlias)
	}
	return i, nil
}

func (m *LockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PrimaryLock) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.PrimaryLock)))
		i += copy(dAtA[i:], m.PrimaryLock)
	}
	if m.LockVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockVersion))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.LockTtl != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockTtl))
	}
	if m.TxnSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TxnSize))
	}
	if m.LockType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockType))
	}
	if m.LockForUpdateTs != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockForUpdateTs))
	}
	if m.UseAsyncCommit {
		dAtA[i] = 0x40
		i++
		if m.UseAsyncCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MinCommitTs != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MinCommitTs))
	}
	if len(m.Secondaries) > 0 {
		for _, b := range m.Secondaries {
			dAtA[i] = 0x52
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.DurationToLastUpdateMs != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.DurationToLastUpdateMs))
	}
	return i, nil
}

func (m *KeyError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Locked != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Locked.Size()))
		n114, err := m.Locked.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n114
	}
	if len(m.Retryable) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Retryable)))
		i += copy(dAtA[i:], m.Retryable)
	}
	if len(m.Abort) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Abort)))
		i += copy(dAtA[i:], m.Abort)
	}
	if m.Conflict != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Conflict.Size()))
		n115, err := m.Conflict.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	if m.AlreadyExist != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.AlreadyExist.Size()))
		n116, err := m.AlreadyExist.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	if m.Deadlock != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Deadlock.Size()))
		n117, err := m.Deadlock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n117
	}
	if m.CommitTsExpired != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitTsExpired.Size()))
		n118, err := m.CommitTsExpired.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n118
	}
	if m.TxnNotFound != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TxnNotFound.Size()))
		n119, err := m.TxnNotFound.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n119
	}
	if m.CommitTsTooLarge != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitTsTooLarge.Size()))
		n120, err := m.CommitTsTooLarge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n120
	}
	if m.AssertionFailed != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.AssertionFailed.Size()))
		n121, err := m.AssertionFailed.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n121
	}
	if m.PrimaryMismatch != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.PrimaryMismatch.Size()))
		n122, err := m.PrimaryMismatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n122
	}
	return i, nil
}

func (m *WriteConflict) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteConflict) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if m.ConflictTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ConflictTs))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Primary) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Primary)))
		i += copy(dAtA[i:], m.Primary)
	}
	if m.ConflictCommitTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ConflictCommitTs))
	}
	if m.Reason != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Reason))
	}
	return i, nil
}

func (m *AlreadyExist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlreadyExist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *Deadlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deadlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LockTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockTs))
	}
	if len(m.LockKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.LockKey)))
		i += copy(dAtA[i:], m.LockKey)
	}
	if m.DeadlockKeyHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.DeadlockKeyHash))
	}
	if len(m.WaitChain) > 0 {
		for _, msg := range m.WaitChain {
			dAtA[i] = 0x22
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CommitTsExpired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitTsExpired) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if m.AttemptedCommitTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.AttemptedCommitTs))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.MinCommitTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.MinCommitTs))
	}
	return i, nil
}

func (m *TxnNotFound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnNotFound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if len(m.PrimaryKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.PrimaryKey)))
		i += copy(dAtA[i:], m.PrimaryKey)
	}
	return i, nil
}

func (m *CommitTsTooLarge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitTsTooLarge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommitTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitTs))
	}
	return i, nil
}

func (m *AssertionFailed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssertionFailed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Assertion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Assertion))
	}
	if m.ExistingStartTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExistingStartTs))
	}
	if m.ExistingCommitTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ExistingCommitTs))
	}
	return i, nil
}

func (m *PrimaryMismatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryMismatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LockInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LockInfo.Size()))
		n123, err := m.LockInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n123
	}
	return i, nil
}

func (m *TimeDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WaitWallTimeMs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.WaitWallTimeMs))
	}
	if m.ProcessWallTimeMs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ProcessWallTimeMs))
	}
	if m.KvReadWallTimeMs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.KvReadWallTimeMs))
	}
	if m.TotalRpcWallTimeNs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TotalRpcWallTimeNs))
	}
	return i, nil
}

func (m *TimeDetailV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeDetailV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WaitWallTimeNs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.WaitWallTimeNs))
	}
	if m.ProcessWallTimeNs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ProcessWallTimeNs))
	}
	if m.ProcessSuspendWallTimeNs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ProcessSuspendWallTimeNs))
	}
	if m.KvReadWallTimeNs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.KvReadWallTimeNs))
	}
	if m.TotalRpcWallTimeNs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TotalRpcWallTimeNs))
	}
	return i, nil
}

func (m *ScanInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Total))
	}
	if m.Processed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Processed))
	}
	if m.ReadBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ReadBytes))
	}
	return i, nil
}

func (m *ScanDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Write != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Write.Size()))
		n124, err := m.Write.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n124
	}
	if m.Lock != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Lock.Size()))
		n125, err := m.Lock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n125
	}
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Data.Size()))
		n126, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n126
	}
	return i, nil
}

func (m *ScanDetailV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanDetailV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProcessedVersions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ProcessedVersions))
	}
	if m.TotalVersions != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TotalVersions))
	}
	if m.RocksdbDeleteSkippedCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RocksdbDeleteSkippedCount))
	}
	if m.RocksdbKeySkippedCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RocksdbKeySkippedCount))
	}
	if m.RocksdbBlockCacheHitCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RocksdbBlockCacheHitCount))
	}
	if m.RocksdbBlockReadCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RocksdbBlockReadCount))
	}
	if m.RocksdbBlockReadByte != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RocksdbBlockReadByte))
	}
	if m.ProcessedVersionsSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ProcessedVersionsSize))
	}
	if m.RocksdbBlockReadNanos != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RocksdbBlockReadNanos))
	}
	if m.GetSnapshotNanos != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.GetSnapshotNanos))
	}
	if m.ReadIndexProposeWaitNanos != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ReadIndexProposeWaitNanos))
	}
	if m.ReadIndexConfirmWaitNanos != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ReadIndexConfirmWaitNanos))
	}
	if m.ReadPoolScheduleWaitNanos != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ReadPoolScheduleWaitNanos))
	}
	return i, nil
}

func (m *ExecDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeDetail != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TimeDetail.Size()))
		n127, err := m.TimeDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n127
	}
	if m.ScanDetail != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ScanDetail.Size()))
		n128, err := m.ScanDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n128
	}
	return i, nil
}

func (m *ExecDetailsV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecDetailsV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeDetail != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TimeDetail.Size()))
		n129, err := m.TimeDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n129
	}
	if m.ScanDetailV2 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ScanDetailV2.Size()))
		n130, err := m.ScanDetailV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n130
	}
	if m.WriteDetail != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.WriteDetail.Size()))
		n131, err := m.WriteDetail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n131
	}
	if m.TimeDetailV2 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TimeDetailV2.Size()))
		n132, err := m.TimeDetailV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n132
	}
	return i, nil
}

func (m *WriteDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StoreBatchWaitNanos != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StoreBatchWaitNanos))
	}
	if m.ProposeSendWaitNanos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ProposeSendWaitNanos))
	}
	if m.PersistLogNanos != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.PersistLogNanos))
	}
	if m.RaftDbWriteLeaderWaitNanos != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RaftDbWriteLeaderWaitNanos))
	}
	if m.RaftDbSyncLogNanos != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RaftDbSyncLogNanos))
	}
	if m.RaftDbWriteMemtableNanos != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RaftDbWriteMemtableNanos))
	}
	if m.CommitLogNanos != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitLogNanos))
	}
	if m.ApplyBatchWaitNanos != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ApplyBatchWaitNanos))
	}
	if m.ApplyLogNanos != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ApplyLogNanos))
	}
	if m.ApplyMutexLockNanos != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ApplyMutexLockNanos))
	}
	if m.ApplyWriteLeaderWaitNanos != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ApplyWriteLeaderWaitNanos))
	}
	if m.ApplyWriteWalNanos != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ApplyWriteWalNanos))
	}
	if m.ApplyWriteMemtableNanos != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ApplyWriteMemtableNanos))
	}
	if m.LatchWaitNanos != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LatchWaitNanos))
	}
	if m.ProcessNanos != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ProcessNanos))
	}
	if m.ThrottleNanos != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ThrottleNanos))
	}
	if m.PessimisticLockWaitNanos != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.PessimisticLockWaitNanos))
	}
	return i, nil
}

func (m *KvPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KvPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n133, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n133
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Mutation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mutation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Op))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Assertion != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Assertion))
	}
	return i, nil
}

func (m *MvccWrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccWrite) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Type))
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitTs))
	}
	if len(m.ShortValue) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.ShortValue)))
		i += copy(dAtA[i:], m.ShortValue)
	}
	if m.HasOverlappedRollback {
		dAtA[i] = 0x28
		i++
		if m.HasOverlappedRollback {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasGcFence {
		dAtA[i] = 0x30
		i++
		if m.HasGcFence {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GcFence != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.GcFence))
	}
	if m.LastChangeTs != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LastChangeTs))
	}
	if m.VersionsToLastChange != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.VersionsToLastChange))
	}
	return i, nil
}

func (m *MvccValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *MvccLock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccLock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Type))
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if len(m.Primary) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Primary)))
		i += copy(dAtA[i:], m.Primary)
	}
	if len(m.ShortValue) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.ShortValue)))
		i += copy(dAtA[i:], m.ShortValue)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Ttl))
	}
	if m.ForUpdateTs != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ForUpdateTs))
	}
	if m.TxnSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TxnSize))
	}
	if m.UseAsyncCommit {
		dAtA[i] = 0x40
		i++
		if m.UseAsyncCommit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Secondaries) > 0 {
		for _, b := range m.Secondaries {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.RollbackTs) > 0 {
		dAtA135 := make([]byte, len(m.RollbackTs)*10)
		var j134 int
		for _, num := range m.RollbackTs {
			for num >= 1<<7 {
				dAtA135[j134] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j134++
			}
			dAtA135[j134] = uint8(num)
			j134++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(j134))
		i += copy(dAtA[i:], dAtA135[:j134])
	}
	if m.LastChangeTs != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LastChangeTs))
	}
	if m.VersionsToLastChange != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.VersionsToLastChange))
	}
	return i, nil
}

func (m *MvccInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MvccInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lock != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Lock.Size()))
		n136, err := m.Lock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n136
	}
	if len(m.Writes) > 0 {
		for _, msg := range m.Writes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TxnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Txn != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Txn))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *KeyRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StartKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	return i, nil
}

func (m *LeaderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionId))
	}
	if m.PeerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.PeerId))
	}
	if m.Term != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Term))
	}
	if m.RegionEpoch != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionEpoch.Size()))
		n137, err := m.RegionEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n137
	}
	if m.ReadState != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ReadState.Size()))
		n138, err := m.ReadState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n138
	}
	return i, nil
}

func (m *ReadState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AppliedIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.AppliedIndex))
	}
	if m.SafeTs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.SafeTs))
	}
	return i, nil
}

func (m *CheckLeaderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckLeaderRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Regions) > 0 {
		for _, msg := range m.Regions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Ts))
	}
	return i, nil
}

func (m *CheckLeaderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckLeaderResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Regions) > 0 {
		dAtA140 := make([]byte, len(m.Regions)*10)
		var j139 int
		for _, num := range m.Regions {
			for num >= 1<<7 {
				dAtA140[j139] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j139++
			}
			dAtA140[j139] = uint8(num)
			j139++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(j139))
		i += copy(dAtA[i:], dAtA140[:j139])
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Ts))
	}
	return i, nil
}

func (m *StoreSafeTSRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreSafeTSRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyRange != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.KeyRange.Size()))
		n141, err := m.KeyRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n141
	}
	return i, nil
}

func (m *StoreSafeTSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreSafeTSResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SafeTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.SafeTs))
	}
	return i, nil
}

func (m *RawGetKeyTTLRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawGetKeyTTLRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n142, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n142
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	return i, nil
}

func (m *RawGetKeyTTLResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawGetKeyTTLResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n143, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n143
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Ttl))
	}
	if m.NotFound {
		dAtA[i] = 0x20
		i++
		if m.NotFound {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RawCASRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCASRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n144, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n144
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.PreviousNotExist {
		dAtA[i] = 0x20
		i++
		if m.PreviousNotExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PreviousValue) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.PreviousValue)))
		i += copy(dAtA[i:], m.PreviousValue)
	}
	if len(m.Cf) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Cf)))
		i += copy(dAtA[i:], m.Cf)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Ttl))
	}
	return i, nil
}

func (m *RawCASResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCASResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n145, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n145
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Succeed {
		dAtA[i] = 0x18
		i++
		if m.Succeed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PreviousNotExist {
		dAtA[i] = 0x20
		i++
		if m.PreviousNotExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PreviousValue) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.PreviousValue)))
		i += copy(dAtA[i:], m.PreviousValue)
	}
	return i, nil
}

func (m *GetLockWaitInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockWaitInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n146, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n146
	}
	return i, nil
}

func (m *GetLockWaitInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockWaitInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n147, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n147
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetLockWaitHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockWaitHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n148, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n148
	}
	return i, nil
}

func (m *GetLockWaitHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockWaitHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n149, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n149
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawCoprocessorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCoprocessorRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n150, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n150
	}
	if len(m.CoprName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.CoprName)))
		i += copy(dAtA[i:], m.CoprName)
	}
	if len(m.CoprVersionReq) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.CoprVersionReq)))
		i += copy(dAtA[i:], m.CoprVersionReq)
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x22
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *RawCoprocessorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawCoprocessorResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n151, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n151
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *RawChecksumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawChecksumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n152, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n152
	}
	if m.Algorithm != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Algorithm))
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RawChecksumResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawChecksumResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n153, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n153
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Checksum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Checksum))
	}
	if m.TotalKvs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.TotalBytes))
	}
	return i, nil
}

func (m *CompactError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		nn154, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn154
	}
	return i, nil
}

func (m *CompactError_ErrInvalidStartKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ErrInvalidStartKey != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ErrInvalidStartKey.Size()))
		n155, err := m.ErrInvalidStartKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n155
	}
	return i, nil
}
func (m *CompactError_ErrPhysicalTableNotExist) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ErrPhysicalTableNotExist != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ErrPhysicalTableNotExist.Size()))
		n156, err := m.ErrPhysicalTableNotExist.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n156
	}
	return i, nil
}
func (m *CompactError_ErrCompactInProgress) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ErrCompactInProgress != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ErrCompactInProgress.Size()))
		n157, err := m.ErrCompactInProgress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n157
	}
	return i, nil
}
func (m *CompactError_ErrTooManyPendingTasks) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ErrTooManyPendingTasks != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ErrTooManyPendingTasks.Size()))
		n158, err := m.ErrTooManyPendingTasks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n158
	}
	return i, nil
}
func (m *CompactErrorInvalidStartKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactErrorInvalidStartKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CompactErrorPhysicalTableNotExist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactErrorPhysicalTableNotExist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CompactErrorCompactInProgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactErrorCompactInProgress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CompactErrorTooManyPendingTasks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactErrorTooManyPendingTasks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CompactRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StartKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if m.PhysicalTableId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.PhysicalTableId))
	}
	if m.LogicalTableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.LogicalTableId))
	}
	if m.ApiVersion != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.ApiVersion))
	}
	if m.KeyspaceId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.KeyspaceId))
	}
	return i, nil
}

func (m *CompactResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Error.Size()))
		n159, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n159
	}
	if m.HasRemaining {
		dAtA[i] = 0x10
		i++
		if m.HasRemaining {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CompactedStartKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.CompactedStartKey)))
		i += copy(dAtA[i:], m.CompactedStartKey)
	}
	if len(m.CompactedEndKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.CompactedEndKey)))
		i += copy(dAtA[i:], m.CompactedEndKey)
	}
	return i, nil
}

func (m *TiFlashSystemTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiFlashSystemTableRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sql) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Sql)))
		i += copy(dAtA[i:], m.Sql)
	}
	return i, nil
}

func (m *TiFlashSystemTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TiFlashSystemTableResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Data.Size()))
	n160, err := m.Data.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n160
	return i, nil
}

func (m *TxnEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Entry != nil {
		nn161, err := m.Entry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn161
	}
	return i, nil
}

func (m *TxnEntry_Prewrite_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Prewrite != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Prewrite.Size()))
		n162, err := m.Prewrite.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n162
	}
	return i, nil
}
func (m *TxnEntry_Commit_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Commit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Commit.Size()))
		n163, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n163
	}
	return i, nil
}
func (m *TxnEntry_Prewrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnEntry_Prewrite) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if len(m.PrimaryKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.PrimaryKey)))
		i += copy(dAtA[i:], m.PrimaryKey)
	}
	return i, nil
}

func (m *TxnEntry_Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnEntry_Commit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.CommitTs))
	}
	return i, nil
}

func (m *ScanTxnEntriesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanTxnEntriesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Context.Size()))
		n164, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n164
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.Limit))
	}
	if m.KeyOnly {
		dAtA[i] = 0x28
		i++
		if m.KeyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StartTs != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.StartTs))
	}
	if m.VersionsPerKey != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.VersionsPerKey))
	}
	return i, nil
}

func (m *ScanTxnEntriesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanTxnEntriesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKvrpcpb(dAtA, i, uint64(m.RegionError.Size()))
		n165, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n165
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKvrpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintKvrpcpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Version))
	}
	return n
}

func (m *GetResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.NotFound {
		n += 2
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *ScanRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Limit))
	}
	if m.Version != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Version))
	}
	if m.KeyOnly {
		n += 2
	}
	if m.Reverse {
		n += 2
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.SampleStep != 0 {
		n += 1 + sovKvrpcpb(uint64(m.SampleStep))
	}
	return n
}

func (m *ScanResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *PrewriteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	l = len(m.PrimaryLock)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartVersion))
	}
	if m.LockTtl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockTtl))
	}
	if m.SkipConstraintCheck {
		n += 2
	}
	if len(m.PessimisticActions) > 0 {
		l = 0
		for _, e := range m.PessimisticActions {
			l += sovKvrpcpb(uint64(e))
		}
		n += 1 + sovKvrpcpb(uint64(l)) + l
	}
	if m.TxnSize != 0 {
		n += 1 + sovKvrpcpb(uint64(m.TxnSize))
	}
	if m.ForUpdateTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ForUpdateTs))
	}
	if m.MinCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MinCommitTs))
	}
	if m.UseAsyncCommit {
		n += 2
	}
	if len(m.Secondaries) > 0 {
		for _, b := range m.Secondaries {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.TryOnePc {
		n += 2
	}
	if m.MaxCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MaxCommitTs))
	}
	if m.AssertionLevel != 0 {
		n += 1 + sovKvrpcpb(uint64(m.AssertionLevel))
	}
	if len(m.ForUpdateTsConstraints) > 0 {
		for _, e := range m.ForUpdateTsConstraints {
			l = e.Size()
			n += 2 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *PrewriteRequest_ForUpdateTSConstraint) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Index))
	}
	if m.ExpectedForUpdateTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ExpectedForUpdateTs))
	}
	return n
}

func (m *PrewriteResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.MinCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MinCommitTs))
	}
	if m.OnePcCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.OnePcCommitTs))
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *PessimisticLockRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	l = len(m.PrimaryLock)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartVersion))
	}
	if m.LockTtl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockTtl))
	}
	if m.ForUpdateTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ForUpdateTs))
	}
	if m.IsFirstLock {
		n += 2
	}
	if m.WaitTimeout != 0 {
		n += 1 + sovKvrpcpb(uint64(m.WaitTimeout))
	}
	if m.Force {
		n += 2
	}
	if m.ReturnValues {
		n += 2
	}
	if m.MinCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MinCommitTs))
	}
	if m.CheckExistence {
		n += 2
	}
	if m.LockOnlyIfExists {
		n += 2
	}
	if m.WakeUpMode != 0 {
		n += 1 + sovKvrpcpb(uint64(m.WakeUpMode))
	}
	return n
}

func (m *PessimisticLockKeyResult) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Existence {
		n += 2
	}
	if m.LockedWithConflictTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockedWithConflictTs))
	}
	if m.SkipResolvingLock {
		n += 2
	}
	return n
}

func (m *PessimisticLockResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.CommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitTs))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if len(m.NotFounds) > 0 {
		n += 1 + sovKvrpcpb(uint64(len(m.NotFounds))) + len(m.NotFounds)*1
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *PessimisticRollbackRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartVersion))
	}
	if m.ForUpdateTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ForUpdateTs))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *PessimisticRollbackResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *TxnHeartBeatRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.PrimaryLock)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartVersion))
	}
	if m.AdviseLockTtl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.AdviseLockTtl))
	}
	return n
}

func (m *TxnHeartBeatResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.LockTtl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockTtl))
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *CheckTxnStatusRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.PrimaryKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.LockTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockTs))
	}
	if m.CallerStartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CallerStartTs))
	}
	if m.CurrentTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CurrentTs))
	}
	if m.RollbackIfNotExist {
		n += 2
	}
	if m.ForceSyncCommit {
		n += 2
	}
	if m.ResolvingPessimisticLock {
		n += 2
	}
	if m.VerifyIsPrimary {
		n += 2
	}
	return n
}

func (m *CheckTxnStatusResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.LockTtl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockTtl))
	}
	if m.CommitVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitVersion))
	}
	if m.Action != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Action))
	}
	if m.LockInfo != nil {
		l = m.LockInfo.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *CheckSecondaryLocksRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.StartVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartVersion))
	}
	return n
}

func (m *CheckSecondaryLocksResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.CommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitTs))
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *CommitRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartVersion))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.CommitVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitVersion))
	}
	return n
}

func (m *CommitResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.CommitVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitVersion))
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *ImportRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Mutations) > 0 {
		for _, e := range m.Mutations {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.CommitVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitVersion))
	}
	return n
}

func (m *ImportResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *CleanupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartVersion))
	}
	if m.CurrentTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CurrentTs))
	}
	return n
}

func (m *CleanupResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.CommitVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitVersion))
	}
	return n
}

func (m *BatchGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Version))
	}
	return n
}

func (m *BatchGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *BatchRollbackRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartVersion))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *BatchRollbackResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *ScanLockRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.MaxVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MaxVersion))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Limit))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *ScanLockResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *ResolveLockRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartVersion))
	}
	if m.CommitVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitVersion))
	}
	if len(m.TxnInfos) > 0 {
		for _, e := range m.TxnInfos {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *ResolveLockResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ExecDetailsV2 != nil {
		l = m.ExecDetailsV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *GCRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.SafePoint != 0 {
		n += 1 + sovKvrpcpb(uint64(m.SafePoint))
	}
	return n
}

func (m *GCResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *DeleteRangeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.NotifyOnly {
		n += 2
	}
	return n
}

func (m *DeleteRangeResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *PrepareFlashbackToVersionRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	if m.Version != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Version))
	}
	return n
}

func (m *PrepareFlashbackToVersionResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *FlashbackToVersionRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Version))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitTs))
	}
	return n
}

func (m *FlashbackToVersionResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.NotFound {
		n += 2
	}
	return n
}

func (m *RawBatchGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawBatchGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *RawPutRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Ttl))
	}
	if m.ForCas {
		n += 2
	}
	return n
}

func (m *RawPutResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawBatchPutRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Ttl))
	}
	if m.ForCas {
		n += 2
	}
	if len(m.Ttls) > 0 {
		l = 0
		for _, e := range m.Ttls {
			l += sovKvrpcpb(uint64(e))
		}
		n += 1 + sovKvrpcpb(uint64(l)) + l
	}
	return n
}

func (m *RawBatchPutResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ForCas {
		n += 2
	}
	return n
}

func (m *RawDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawBatchDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ForCas {
		n += 2
	}
	return n
}

func (m *RawBatchDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawScanRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Limit))
	}
	if m.KeyOnly {
		n += 2
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Reverse {
		n += 2
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawScanResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Kvs) > 0 {
		for _, e := range m.Kvs {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *RawDeleteRangeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawDeleteRangeResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawBatchScanRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.EachLimit != 0 {
		n += 1 + sovKvrpcpb(uint64(m.EachLimit))
	}
	if m.KeyOnly {
		n += 2
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Reverse {
		n += 2
	}
	return n
}

func (m *RawBatchScanResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Kvs) > 0 {
		for _, e := range m.Kvs {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *UnsafeDestroyRangeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *UnsafeDestroyRangeResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RegisterLockObserverRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.MaxTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MaxTs))
	}
	return n
}

func (m *RegisterLockObserverResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *CheckLockObserverRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.MaxTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MaxTs))
	}
	return n
}

func (m *CheckLockObserverResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.IsClean {
		n += 2
	}
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *RemoveLockObserverRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.MaxTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MaxTs))
	}
	return n
}

func (m *RemoveLockObserverResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *PhysicalScanLockRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.MaxTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MaxTs))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Limit))
	}
	return n
}

func (m *PhysicalScanLockResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *SplitRegionRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.SplitKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.SplitKeys) > 0 {
		for _, b := range m.SplitKeys {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.IsRawKv {
		n += 2
	}
	return n
}

func (m *SplitRegionResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Regions) > 0 {
		for _, e := range m.Regions {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *ReadIndexRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *ReadIndexResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ReadIndex != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ReadIndex))
	}
	if m.Locked != nil {
		l = m.Locked.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *MvccGetByKeyRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *MvccGetByKeyResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *MvccGetByStartTsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	return n
}

func (m *MvccGetByStartTsResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *Context) Size() (n int) {
	var l int
	_ = l
	if m.RegionId != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RegionId))
	}
	if m.RegionEpoch != nil {
		l = m.RegionEpoch.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Term))
	}
	if m.Priority != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Priority))
	}
	if m.IsolationLevel != 0 {
		n += 1 + sovKvrpcpb(uint64(m.IsolationLevel))
	}
	if m.NotFillCache {
		n += 2
	}
	if m.SyncLog {
		n += 2
	}
	if m.RecordTimeStat {
		n += 2
	}
	if m.RecordScanStat {
		n += 2
	}
	if m.ReplicaRead {
		n += 2
	}
	if len(m.ResolvedLocks) > 0 {
		l = 0
		for _, e := range m.ResolvedLocks {
			l += sovKvrpcpb(uint64(e))
		}
		n += 1 + sovKvrpcpb(uint64(l)) + l
	}
	if m.MaxExecutionDurationMs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MaxExecutionDurationMs))
	}
	if m.AppliedIndex != 0 {
		n += 1 + sovKvrpcpb(uint64(m.AppliedIndex))
	}
	if m.TaskId != 0 {
		n += 2 + sovKvrpcpb(uint64(m.TaskId))
	}
	if m.StaleRead {
		n += 3
	}
	l = len(m.ResourceGroupTag)
	if l > 0 {
		n += 2 + l + sovKvrpcpb(uint64(l))
	}
	if m.DiskFullOpt != 0 {
		n += 2 + sovKvrpcpb(uint64(m.DiskFullOpt))
	}
	if m.IsRetryRequest {
		n += 3
	}
	if m.ApiVersion != 0 {
		n += 2 + sovKvrpcpb(uint64(m.ApiVersion))
	}
	if len(m.CommittedLocks) > 0 {
		l = 0
		for _, e := range m.CommittedLocks {
			l += sovKvrpcpb(uint64(e))
		}
		n += 2 + sovKvrpcpb(uint64(l)) + l
	}
	if m.TraceContext != nil {
		l = m.TraceContext.Size()
		n += 2 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.RequestSource)
	if l > 0 {
		n += 2 + l + sovKvrpcpb(uint64(l))
	}
	if m.TxnSource != 0 {
		n += 2 + sovKvrpcpb(uint64(m.TxnSource))
	}
	if m.BusyThresholdMs != 0 {
		n += 2 + sovKvrpcpb(uint64(m.BusyThresholdMs))
	}
	if m.ResourceControlContext != nil {
		l = m.ResourceControlContext.Size()
		n += 2 + l + sovKvrpcpb(uint64(l))
	}
	if m.KeyspaceId != 0 {
		n += 2 + sovKvrpcpb(uint64(m.KeyspaceId))
	}
	if m.BucketsVersion != 0 {
		n += 2 + sovKvrpcpb(uint64(m.BucketsVersion))
	}
	if m.SourceStmt != nil {
		l = m.SourceStmt.Size()
		n += 2 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *ResourceControlContext) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceGroupName)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Penalty != nil {
		l = m.Penalty.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.OverridePriority != 0 {
		n += 1 + sovKvrpcpb(uint64(m.OverridePriority))
	}
	return n
}

func (m *SourceStmt) Size() (n int) {
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	if m.ConnectionId != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ConnectionId))
	}
	if m.StmtId != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StmtId))
	}
	l = len(m.SessionAlias)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *LockInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.PrimaryLock)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.LockVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockVersion))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.LockTtl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockTtl))
	}
	if m.TxnSize != 0 {
		n += 1 + sovKvrpcpb(uint64(m.TxnSize))
	}
	if m.LockType != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockType))
	}
	if m.LockForUpdateTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockForUpdateTs))
	}
	if m.UseAsyncCommit {
		n += 2
	}
	if m.MinCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MinCommitTs))
	}
	if len(m.Secondaries) > 0 {
		for _, b := range m.Secondaries {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.DurationToLastUpdateMs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.DurationToLastUpdateMs))
	}
	return n
}

func (m *KeyError) Size() (n int) {
	var l int
	_ = l
	if m.Locked != nil {
		l = m.Locked.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Retryable)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Abort)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Conflict != nil {
		l = m.Conflict.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.AlreadyExist != nil {
		l = m.AlreadyExist.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Deadlock != nil {
		l = m.Deadlock.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.CommitTsExpired != nil {
		l = m.CommitTsExpired.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.TxnNotFound != nil {
		l = m.TxnNotFound.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.CommitTsTooLarge != nil {
		l = m.CommitTsTooLarge.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.AssertionFailed != nil {
		l = m.AssertionFailed.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.PrimaryMismatch != nil {
		l = m.PrimaryMismatch.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *WriteConflict) Size() (n int) {
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	if m.ConflictTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ConflictTs))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Primary)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ConflictCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ConflictCommitTs))
	}
	if m.Reason != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Reason))
	}
	return n
}

func (m *AlreadyExist) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *Deadlock) Size() (n int) {
	var l int
	_ = l
	if m.LockTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LockTs))
	}
	l = len(m.LockKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.DeadlockKeyHash != 0 {
		n += 1 + sovKvrpcpb(uint64(m.DeadlockKeyHash))
	}
	if len(m.WaitChain) > 0 {
		for _, e := range m.WaitChain {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *CommitTsExpired) Size() (n int) {
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	if m.AttemptedCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.AttemptedCommitTs))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.MinCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.MinCommitTs))
	}
	return n
}

func (m *TxnNotFound) Size() (n int) {
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	l = len(m.PrimaryKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *CommitTsTooLarge) Size() (n int) {
	var l int
	_ = l
	if m.CommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitTs))
	}
	return n
}

func (m *AssertionFailed) Size() (n int) {
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Assertion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Assertion))
	}
	if m.ExistingStartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ExistingStartTs))
	}
	if m.ExistingCommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ExistingCommitTs))
	}
	return n
}

func (m *PrimaryMismatch) Size() (n int) {
	var l int
	_ = l
	if m.LockInfo != nil {
		l = m.LockInfo.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *TimeDetail) Size() (n int) {
	var l int
	_ = l
	if m.WaitWallTimeMs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.WaitWallTimeMs))
	}
	if m.ProcessWallTimeMs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ProcessWallTimeMs))
	}
	if m.KvReadWallTimeMs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.KvReadWallTimeMs))
	}
	if m.TotalRpcWallTimeNs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.TotalRpcWallTimeNs))
	}
	return n
}

func (m *TimeDetailV2) Size() (n int) {
	var l int
	_ = l
	if m.WaitWallTimeNs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.WaitWallTimeNs))
	}
	if m.ProcessWallTimeNs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ProcessWallTimeNs))
	}
	if m.ProcessSuspendWallTimeNs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ProcessSuspendWallTimeNs))
	}
	if m.KvReadWallTimeNs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.KvReadWallTimeNs))
	}
	if m.TotalRpcWallTimeNs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.TotalRpcWallTimeNs))
	}
	return n
}

func (m *ScanInfo) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Total))
	}
	if m.Processed != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Processed))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ReadBytes))
	}
	return n
}

func (m *ScanDetail) Size() (n int) {
	var l int
	_ = l
	if m.Write != nil {
		l = m.Write.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Lock != nil {
		l = m.Lock.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *ScanDetailV2) Size() (n int) {
	var l int
	_ = l
	if m.ProcessedVersions != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ProcessedVersions))
	}
	if m.TotalVersions != 0 {
		n += 1 + sovKvrpcpb(uint64(m.TotalVersions))
	}
	if m.RocksdbDeleteSkippedCount != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RocksdbDeleteSkippedCount))
	}
	if m.RocksdbKeySkippedCount != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RocksdbKeySkippedCount))
	}
	if m.RocksdbBlockCacheHitCount != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RocksdbBlockCacheHitCount))
	}
	if m.RocksdbBlockReadCount != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RocksdbBlockReadCount))
	}
	if m.RocksdbBlockReadByte != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RocksdbBlockReadByte))
	}
	if m.ProcessedVersionsSize != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ProcessedVersionsSize))
	}
	if m.RocksdbBlockReadNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RocksdbBlockReadNanos))
	}
	if m.GetSnapshotNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.GetSnapshotNanos))
	}
	if m.ReadIndexProposeWaitNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ReadIndexProposeWaitNanos))
	}
	if m.ReadIndexConfirmWaitNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ReadIndexConfirmWaitNanos))
	}
	if m.ReadPoolScheduleWaitNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ReadPoolScheduleWaitNanos))
	}
	return n
}

func (m *ExecDetails) Size() (n int) {
	var l int
	_ = l
	if m.TimeDetail != nil {
		l = m.TimeDetail.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ScanDetail != nil {
		l = m.ScanDetail.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *ExecDetailsV2) Size() (n int) {
	var l int
	_ = l
	if m.TimeDetail != nil {
		l = m.TimeDetail.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ScanDetailV2 != nil {
		l = m.ScanDetailV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.WriteDetail != nil {
		l = m.WriteDetail.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.TimeDetailV2 != nil {
		l = m.TimeDetailV2.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *WriteDetail) Size() (n int) {
	var l int
	_ = l
	if m.StoreBatchWaitNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StoreBatchWaitNanos))
	}
	if m.ProposeSendWaitNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ProposeSendWaitNanos))
	}
	if m.PersistLogNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.PersistLogNanos))
	}
	if m.RaftDbWriteLeaderWaitNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RaftDbWriteLeaderWaitNanos))
	}
	if m.RaftDbSyncLogNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RaftDbSyncLogNanos))
	}
	if m.RaftDbWriteMemtableNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RaftDbWriteMemtableNanos))
	}
	if m.CommitLogNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitLogNanos))
	}
	if m.ApplyBatchWaitNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ApplyBatchWaitNanos))
	}
	if m.ApplyLogNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ApplyLogNanos))
	}
	if m.ApplyMutexLockNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ApplyMutexLockNanos))
	}
	if m.ApplyWriteLeaderWaitNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ApplyWriteLeaderWaitNanos))
	}
	if m.ApplyWriteWalNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ApplyWriteWalNanos))
	}
	if m.ApplyWriteMemtableNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ApplyWriteMemtableNanos))
	}
	if m.LatchWaitNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LatchWaitNanos))
	}
	if m.ProcessNanos != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ProcessNanos))
	}
	if m.ThrottleNanos != 0 {
		n += 2 + sovKvrpcpb(uint64(m.ThrottleNanos))
	}
	if m.PessimisticLockWaitNanos != 0 {
		n += 2 + sovKvrpcpb(uint64(m.PessimisticLockWaitNanos))
	}
	return n
}

func (m *KvPair) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *Mutation) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Op))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Assertion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Assertion))
	}
	return n
}

func (m *MvccWrite) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Type))
	}
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitTs))
	}
	l = len(m.ShortValue)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.HasOverlappedRollback {
		n += 2
	}
	if m.HasGcFence {
		n += 2
	}
	if m.GcFence != 0 {
		n += 1 + sovKvrpcpb(uint64(m.GcFence))
	}
	if m.LastChangeTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LastChangeTs))
	}
	if m.VersionsToLastChange != 0 {
		n += 1 + sovKvrpcpb(uint64(m.VersionsToLastChange))
	}
	return n
}

func (m *MvccValue) Size() (n int) {
	var l int
	_ = l
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *MvccLock) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Type))
	}
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	l = len(m.Primary)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.ShortValue)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Ttl))
	}
	if m.ForUpdateTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ForUpdateTs))
	}
	if m.TxnSize != 0 {
		n += 1 + sovKvrpcpb(uint64(m.TxnSize))
	}
	if m.UseAsyncCommit {
		n += 2
	}
	if len(m.Secondaries) > 0 {
		for _, b := range m.Secondaries {
			l = len(b)
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if len(m.RollbackTs) > 0 {
		l = 0
		for _, e := range m.RollbackTs {
			l += sovKvrpcpb(uint64(e))
		}
		n += 1 + sovKvrpcpb(uint64(l)) + l
	}
	if m.LastChangeTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LastChangeTs))
	}
	if m.VersionsToLastChange != 0 {
		n += 1 + sovKvrpcpb(uint64(m.VersionsToLastChange))
	}
	return n
}

func (m *MvccInfo) Size() (n int) {
	var l int
	_ = l
	if m.Lock != nil {
		l = m.Lock.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Writes) > 0 {
		for _, e := range m.Writes {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *TxnInfo) Size() (n int) {
	var l int
	_ = l
	if m.Txn != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Txn))
	}
	if m.Status != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Status))
	}
	return n
}

func (m *KeyRange) Size() (n int) {
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *LeaderInfo) Size() (n int) {
	var l int
	_ = l
	if m.RegionId != 0 {
		n += 1 + sovKvrpcpb(uint64(m.RegionId))
	}
	if m.PeerId != 0 {
		n += 1 + sovKvrpcpb(uint64(m.PeerId))
	}
	if m.Term != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Term))
	}
	if m.RegionEpoch != nil {
		l = m.RegionEpoch.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.ReadState != nil {
		l = m.ReadState.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *ReadState) Size() (n int) {
	var l int
	_ = l
	if m.AppliedIndex != 0 {
		n += 1 + sovKvrpcpb(uint64(m.AppliedIndex))
	}
	if m.SafeTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.SafeTs))
	}
	return n
}

func (m *CheckLeaderRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Regions) > 0 {
		for _, e := range m.Regions {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	if m.Ts != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Ts))
	}
	return n
}

func (m *CheckLeaderResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Regions) > 0 {
		l = 0
		for _, e := range m.Regions {
			l += sovKvrpcpb(uint64(e))
		}
		n += 1 + sovKvrpcpb(uint64(l)) + l
	}
	if m.Ts != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Ts))
	}
	return n
}

func (m *StoreSafeTSRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyRange != nil {
		l = m.KeyRange.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *StoreSafeTSResponse) Size() (n int) {
	var l int
	_ = l
	if m.SafeTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.SafeTs))
	}
	return n
}

func (m *RawGetKeyTTLRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawGetKeyTTLResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Ttl))
	}
	if m.NotFound {
		n += 2
	}
	return n
}

func (m *RawCASRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.PreviousNotExist {
		n += 2
	}
	l = len(m.PreviousValue)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Cf)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Ttl))
	}
	return n
}

func (m *RawCASResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Succeed {
		n += 2
	}
	if m.PreviousNotExist {
		n += 2
	}
	l = len(m.PreviousValue)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *GetLockWaitInfoRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *GetLockWaitInfoResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *GetLockWaitHistoryRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *GetLockWaitHistoryResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *RawCoprocessorRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.CoprName)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.CoprVersionReq)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawCoprocessorResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *RawChecksumRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Algorithm != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Algorithm))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func (m *RawChecksumResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Checksum != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Checksum))
	}
	if m.TotalKvs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovKvrpcpb(uint64(m.TotalBytes))
	}
	return n
}

func (m *CompactError) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		n += m.Error.Size()
	}
	return n
}

func (m *CompactError_ErrInvalidStartKey) Size() (n int) {
	var l int
	_ = l
	if m.ErrInvalidStartKey != nil {
		l = m.ErrInvalidStartKey.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}
func (m *CompactError_ErrPhysicalTableNotExist) Size() (n int) {
	var l int
	_ = l
	if m.ErrPhysicalTableNotExist != nil {
		l = m.ErrPhysicalTableNotExist.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}
func (m *CompactError_ErrCompactInProgress) Size() (n int) {
	var l int
	_ = l
	if m.ErrCompactInProgress != nil {
		l = m.ErrCompactInProgress.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}
func (m *CompactError_ErrTooManyPendingTasks) Size() (n int) {
	var l int
	_ = l
	if m.ErrTooManyPendingTasks != nil {
		l = m.ErrTooManyPendingTasks.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}
func (m *CompactErrorInvalidStartKey) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CompactErrorPhysicalTableNotExist) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CompactErrorCompactInProgress) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CompactErrorTooManyPendingTasks) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CompactRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.PhysicalTableId != 0 {
		n += 1 + sovKvrpcpb(uint64(m.PhysicalTableId))
	}
	if m.LogicalTableId != 0 {
		n += 1 + sovKvrpcpb(uint64(m.LogicalTableId))
	}
	if m.ApiVersion != 0 {
		n += 1 + sovKvrpcpb(uint64(m.ApiVersion))
	}
	if m.KeyspaceId != 0 {
		n += 1 + sovKvrpcpb(uint64(m.KeyspaceId))
	}
	return n
}

func (m *CompactResponse) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.HasRemaining {
		n += 2
	}
	l = len(m.CompactedStartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.CompactedEndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *TiFlashSystemTableRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *TiFlashSystemTableResponse) Size() (n int) {
	var l int
	_ = l
	l = m.Data.Size()
	n += 1 + l + sovKvrpcpb(uint64(l))
	return n
}

func (m *TxnEntry) Size() (n int) {
	var l int
	_ = l
	if m.Entry != nil {
		n += m.Entry.Size()
	}
	return n
}

func (m *TxnEntry_Prewrite_) Size() (n int) {
	var l int
	_ = l
	if m.Prewrite != nil {
		l = m.Prewrite.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}
func (m *TxnEntry_Commit_) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}
func (m *TxnEntry_Prewrite) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	l = len(m.PrimaryKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	return n
}

func (m *TxnEntry_Commit) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	if m.CommitTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.CommitTs))
	}
	return n
}

func (m *ScanTxnEntriesRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovKvrpcpb(uint64(m.Limit))
	}
	if m.KeyOnly {
		n += 2
	}
	if m.StartTs != 0 {
		n += 1 + sovKvrpcpb(uint64(m.StartTs))
	}
	if m.VersionsPerKey != 0 {
		n += 1 + sovKvrpcpb(uint64(m.VersionsPerKey))
	}
	return n
}

func (m *ScanTxnEntriesResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovKvrpcpb(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovKvrpcpb(uint64(l))
		}
	}
	return n
}

func sovKvrpcpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozKvrpcpb(x uint64) (n int) {
	return sovKvrpcpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotFound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotFound = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOnly = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleStep", wireType)
			}
			m.SampleStep = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SampleStep |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &KvPair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrewriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrewriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrewriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, &Mutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryLock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryLock = append(m.PrimaryLock[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryLock == nil {
				m.PrimaryLock = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTtl", wireType)
			}
			m.LockTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTtl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipConstraintCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipConstraintCheck = bool(v != 0)
		case 7:
			if wireType == 0 {
				var v PrewriteRequest_PessimisticAction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (PrewriteRequest_PessimisticAction(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PessimisticActions = append(m.PessimisticActions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKvrpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v PrewriteRequest_PessimisticAction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKvrpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (PrewriteRequest_PessimisticAction(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PessimisticActions = append(m.PessimisticActions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PessimisticActions", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnSize", wireType)
			}
			m.TxnSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForUpdateTs", wireType)
			}
			m.ForUpdateTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForUpdateTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCommitTs", wireType)
			}
			m.MinCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseAsyncCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseAsyncCommit = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secondaries", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secondaries = append(m.Secondaries, make([]byte, postIndex-iNdEx))
			copy(m.Secondaries[len(m.Secondaries)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TryOnePc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TryOnePc = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCommitTs", wireType)
			}
			m.MaxCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssertionLevel", wireType)
			}
			m.AssertionLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssertionLevel |= (AssertionLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForUpdateTsConstraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForUpdateTsConstraints = append(m.ForUpdateTsConstraints, &PrewriteRequest_ForUpdateTSConstraint{})
			if err := m.ForUpdateTsConstraints[len(m.ForUpdateTsConstraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrewriteRequest_ForUpdateTSConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForUpdateTSConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForUpdateTSConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedForUpdateTs", wireType)
			}
			m.ExpectedForUpdateTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedForUpdateTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrewriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrewriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrewriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &KeyError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCommitTs", wireType)
			}
			m.MinCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnePcCommitTs", wireType)
			}
			m.OnePcCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnePcCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PessimisticLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PessimisticLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PessimisticLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, &Mutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryLock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryLock = append(m.PrimaryLock[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryLock == nil {
				m.PrimaryLock = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTtl", wireType)
			}
			m.LockTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTtl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForUpdateTs", wireType)
			}
			m.ForUpdateTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForUpdateTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFirstLock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFirstLock = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeout", wireType)
			}
			m.WaitTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeout |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReturnValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReturnValues = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCommitTs", wireType)
			}
			m.MinCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckExistence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckExistence = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockOnlyIfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockOnlyIfExists = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WakeUpMode", wireType)
			}
			m.WakeUpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WakeUpMode |= (PessimisticLockWakeUpMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PessimisticLockKeyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PessimisticLockKeyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PessimisticLockKeyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (PessimisticLockKeyResultType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Existence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Existence = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedWithConflictTs", wireType)
			}
			m.LockedWithConflictTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockedWithConflictTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipResolvingLock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipResolvingLock = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PessimisticLockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PessimisticLockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PessimisticLockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &KeyError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NotFounds = append(m.NotFounds, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKvrpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKvrpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NotFounds = append(m.NotFounds, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotFounds", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &PessimisticLockKeyResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PessimisticRollbackRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PessimisticRollbackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PessimisticRollbackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForUpdateTs", wireType)
			}
			m.ForUpdateTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForUpdateTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PessimisticRollbackResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PessimisticRollbackResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PessimisticRollbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &KeyError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnHeartBeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnHeartBeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnHeartBeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryLock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryLock = append(m.PrimaryLock[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryLock == nil {
				m.PrimaryLock = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdviseLockTtl", wireType)
			}
			m.AdviseLockTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdviseLockTtl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnHeartBeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnHeartBeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnHeartBeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTtl", wireType)
			}
			m.LockTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTtl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckTxnStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckTxnStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckTxnStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKey = append(m.PrimaryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryKey == nil {
				m.PrimaryKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTs", wireType)
			}
			m.LockTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerStartTs", wireType)
			}
			m.CallerStartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallerStartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTs", wireType)
			}
			m.CurrentTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackIfNotExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RollbackIfNotExist = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceSyncCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceSyncCommit = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvingPessimisticLock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResolvingPessimisticLock = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyIsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifyIsPrimary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckTxnStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckTxnStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckTxnStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTtl", wireType)
			}
			m.LockTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTtl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitVersion", wireType)
			}
			m.CommitVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (Action(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockInfo == nil {
				m.LockInfo = &LockInfo{}
			}
			if err := m.LockInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckSecondaryLocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckSecondaryLocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckSecondaryLocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckSecondaryLocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckSecondaryLocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckSecondaryLocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, &LockInfo{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitVersion", wireType)
			}
			m.CommitVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitVersion", wireType)
			}
			m.CommitVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mutations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mutations = append(m.Mutations, &Mutation{})
			if err := m.Mutations[len(m.Mutations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitVersion", wireType)
			}
			m.CommitVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTs", wireType)
			}
			m.CurrentTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitVersion", wireType)
			}
			m.CommitVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &KvPair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchRollbackRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchRollbackRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchRollbackRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchRollbackResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchRollbackResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchRollbackResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxVersion", wireType)
			}
			m.MaxVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanLockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanLockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanLockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, &LockInfo{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitVersion", wireType)
			}
			m.CommitVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnInfos = append(m.TxnInfos, &TxnInfo{})
			if err := m.TxnInfos[len(m.TxnInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveLockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveLockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveLockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDetailsV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecDetailsV2 == nil {
				m.ExecDetailsV2 = &ExecDetailsV2{}
			}
			if err := m.ExecDetailsV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafePoint", wireType)
			}
			m.SafePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafePoint |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotifyOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareFlashbackToVersionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareFlashbackToVersionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareFlashbackToVersionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareFlashbackToVersionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareFlashbackToVersionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareFlashbackToVersionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashbackToVersionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashbackToVersionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashbackToVersionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlashbackToVersionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlashbackToVersionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlashbackToVersionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotFound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotFound = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawBatchGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawBatchGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawBatchGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawBatchGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawBatchGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawBatchGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &KvPair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawPutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawPutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawPutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForCas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForCas = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawBatchPutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawBatchPutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawBatchPutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &KvPair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForCas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForCas = bool(v != 0)
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ttls = append(m.Ttls, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKvrpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKvrpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ttls = append(m.Ttls, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttls", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawBatchPutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawBatchPutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawBatchPutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForCas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForCas = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawBatchDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawBatchDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawBatchDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForCas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForCas = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawBatchDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawBatchDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawBatchDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOnly = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kvs = append(m.Kvs, &KvPair{})
			if err := m.Kvs[len(m.Kvs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawDeleteRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawDeleteRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawDeleteRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawDeleteRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawDeleteRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawDeleteRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawBatchScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawBatchScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawBatchScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &KeyRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EachLimit", wireType)
			}
			m.EachLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EachLimit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOnly = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawBatchScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawBatchScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawBatchScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kvs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kvs = append(m.Kvs, &KvPair{})
			if err := m.Kvs[len(m.Kvs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsafeDestroyRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsafeDestroyRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsafeDestroyRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsafeDestroyRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsafeDestroyRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsafeDestroyRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterLockObserverRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterLockObserverRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterLockObserverRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			m.MaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterLockObserverResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterLockObserverResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterLockObserverResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckLockObserverRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckLockObserverRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckLockObserverRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			m.MaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckLockObserverResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckLockObserverResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckLockObserverResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClean", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClean = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, &LockInfo{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveLockObserverRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveLockObserverRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveLockObserverRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			m.MaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveLockObserverResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveLockObserverResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveLockObserverResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalScanLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalScanLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalScanLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTs", wireType)
			}
			m.MaxTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhysicalScanLockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhysicalScanLockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhysicalScanLockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, &LockInfo{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitRegionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitRegionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitRegionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKey = append(m.SplitKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitKey == nil {
				m.SplitKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKeys = append(m.SplitKeys, make([]byte, postIndex-iNdEx))
			copy(m.SplitKeys[len(m.SplitKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRawKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRawKv = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitRegionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitRegionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitRegionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &metapb.Region{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &metapb.Region{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, &metapb.Region{})
			if err := m.Regions[len(m.Regions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &KeyRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadIndexResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadIndexResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadIndexResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIndex", wireType)
			}
			m.ReadIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Locked == nil {
				m.Locked = &LockInfo{}
			}
			if err := m.Locked.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccGetByKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccGetByKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccGetByKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccGetByKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccGetByKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccGetByKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &MvccInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccGetByStartTsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccGetByStartTsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccGetByStartTsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccGetByStartTsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccGetByStartTsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccGetByStartTsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &MvccInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Context) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Context: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Context: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionEpoch == nil {
				m.RegionEpoch = &metapb.RegionEpoch{}
			}
			if err := m.RegionEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &metapb.Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (CommandPri(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolationLevel", wireType)
			}
			m.IsolationLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsolationLevel |= (IsolationLevel(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotFillCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotFillCache = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncLog", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SyncLog = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordTimeStat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecordTimeStat = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordScanStat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecordScanStat = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReplicaRead = bool(v != 0)
		case 13:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ResolvedLocks = append(m.ResolvedLocks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKvrpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKvrpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ResolvedLocks = append(m.ResolvedLocks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedLocks", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxExecutionDurationMs", wireType)
			}
			m.MaxExecutionDurationMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxExecutionDurationMs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedIndex", wireType)
			}
			m.AppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppliedIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaleRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StaleRead = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroupTag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroupTag = append(m.ResourceGroupTag[:0], dAtA[iNdEx:postIndex]...)
			if m.ResourceGroupTag == nil {
				m.ResourceGroupTag = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskFullOpt", wireType)
			}
			m.DiskFullOpt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskFullOpt |= (DiskFullOpt(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRetryRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRetryRequest = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			m.ApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiVersion |= (APIVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CommittedLocks = append(m.CommittedLocks, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKvrpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKvrpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CommittedLocks = append(m.CommittedLocks, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedLocks", wireType)
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TraceContext == nil {
				m.TraceContext = &tracepb.TraceContext{}
			}
			if err := m.TraceContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnSource", wireType)
			}
			m.TxnSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnSource |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusyThresholdMs", wireType)
			}
			m.BusyThresholdMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusyThresholdMs |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceControlContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceControlContext == nil {
				m.ResourceControlContext = &ResourceControlContext{}
			}
			if err := m.ResourceControlContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			m.KeyspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BucketsVersion", wireType)
			}
			m.BucketsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BucketsVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceStmt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceStmt == nil {
				m.SourceStmt = &SourceStmt{}
			}
			if err := m.SourceStmt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceControlContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceControlContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceControlContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Penalty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Penalty == nil {
				m.Penalty = &resource_manager.Consumption{}
			}
			if err := m.Penalty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverridePriority", wireType)
			}
			m.OverridePriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverridePriority |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceStmt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceStmt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceStmt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			m.ConnectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StmtId", wireType)
			}
			m.StmtId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StmtId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAlias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionAlias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryLock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryLock = append(m.PrimaryLock[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryLock == nil {
				m.PrimaryLock = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockVersion", wireType)
			}
			m.LockVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTtl", wireType)
			}
			m.LockTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTtl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnSize", wireType)
			}
			m.TxnSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockType", wireType)
			}
			m.LockType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockType |= (Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockForUpdateTs", wireType)
			}
			m.LockForUpdateTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockForUpdateTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseAsyncCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseAsyncCommit = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCommitTs", wireType)
			}
			m.MinCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secondaries", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secondaries = append(m.Secondaries, make([]byte, postIndex-iNdEx))
			copy(m.Secondaries[len(m.Secondaries)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationToLastUpdateMs", wireType)
			}
			m.DurationToLastUpdateMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationToLastUpdateMs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Locked == nil {
				m.Locked = &LockInfo{}
			}
			if err := m.Locked.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retryable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Retryable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conflict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conflict == nil {
				m.Conflict = &WriteConflict{}
			}
			if err := m.Conflict.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlreadyExist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AlreadyExist == nil {
				m.AlreadyExist = &AlreadyExist{}
			}
			if err := m.AlreadyExist.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deadlock == nil {
				m.Deadlock = &Deadlock{}
			}
			if err := m.Deadlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTsExpired", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitTsExpired == nil {
				m.CommitTsExpired = &CommitTsExpired{}
			}
			if err := m.CommitTsExpired.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnNotFound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnNotFound == nil {
				m.TxnNotFound = &TxnNotFound{}
			}
			if err := m.TxnNotFound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTsTooLarge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitTsTooLarge == nil {
				m.CommitTsTooLarge = &CommitTsTooLarge{}
			}
			if err := m.CommitTsTooLarge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssertionFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssertionFailed == nil {
				m.AssertionFailed = &AssertionFailed{}
			}
			if err := m.AssertionFailed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMismatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimaryMismatch == nil {
				m.PrimaryMismatch = &PrimaryMismatch{}
			}
			if err := m.PrimaryMismatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteConflict) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteConflict: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteConflict: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictTs", wireType)
			}
			m.ConflictTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConflictTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Primary = append(m.Primary[:0], dAtA[iNdEx:postIndex]...)
			if m.Primary == nil {
				m.Primary = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictCommitTs", wireType)
			}
			m.ConflictCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConflictCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (WriteConflict_Reason(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlreadyExist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlreadyExist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlreadyExist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deadlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deadlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deadlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTs", wireType)
			}
			m.LockTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LockTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockKey = append(m.LockKey[:0], dAtA[iNdEx:postIndex]...)
			if m.LockKey == nil {
				m.LockKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadlockKeyHash", wireType)
			}
			m.DeadlockKeyHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadlockKeyHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitChain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WaitChain = append(m.WaitChain, &deadlock.WaitForEntry{})
			if err := m.WaitChain[len(m.WaitChain)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitTsExpired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitTsExpired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitTsExpired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttemptedCommitTs", wireType)
			}
			m.AttemptedCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttemptedCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCommitTs", wireType)
			}
			m.MinCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnNotFound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnNotFound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnNotFound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKey = append(m.PrimaryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryKey == nil {
				m.PrimaryKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitTsTooLarge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitTsTooLarge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitTsTooLarge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssertionFailed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssertionFailed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssertionFailed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assertion", wireType)
			}
			m.Assertion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Assertion |= (Assertion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingStartTs", wireType)
			}
			m.ExistingStartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExistingStartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingCommitTs", wireType)
			}
			m.ExistingCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExistingCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryMismatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryMismatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryMismatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockInfo == nil {
				m.LockInfo = &LockInfo{}
			}
			if err := m.LockInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitWallTimeMs", wireType)
			}
			m.WaitWallTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitWallTimeMs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessWallTimeMs", wireType)
			}
			m.ProcessWallTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessWallTimeMs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvReadWallTimeMs", wireType)
			}
			m.KvReadWallTimeMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KvReadWallTimeMs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRpcWallTimeNs", wireType)
			}
			m.TotalRpcWallTimeNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRpcWallTimeNs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeDetailV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeDetailV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeDetailV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitWallTimeNs", wireType)
			}
			m.WaitWallTimeNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitWallTimeNs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessWallTimeNs", wireType)
			}
			m.ProcessWallTimeNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessWallTimeNs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessSuspendWallTimeNs", wireType)
			}
			m.ProcessSuspendWallTimeNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessSuspendWallTimeNs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvReadWallTimeNs", wireType)
			}
			m.KvReadWallTimeNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KvReadWallTimeNs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRpcWallTimeNs", wireType)
			}
			m.TotalRpcWallTimeNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRpcWallTimeNs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processed", wireType)
			}
			m.Processed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Processed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Write == nil {
				m.Write = &ScanInfo{}
			}
			if err := m.Write.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lock == nil {
				m.Lock = &ScanInfo{}
			}
			if err := m.Lock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ScanInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanDetailV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanDetailV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanDetailV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessedVersions", wireType)
			}
			m.ProcessedVersions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessedVersions |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVersions", wireType)
			}
			m.TotalVersions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalVersions |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbDeleteSkippedCount", wireType)
			}
			m.RocksdbDeleteSkippedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RocksdbDeleteSkippedCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbKeySkippedCount", wireType)
			}
			m.RocksdbKeySkippedCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RocksdbKeySkippedCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbBlockCacheHitCount", wireType)
			}
			m.RocksdbBlockCacheHitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RocksdbBlockCacheHitCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbBlockReadCount", wireType)
			}
			m.RocksdbBlockReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RocksdbBlockReadCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbBlockReadByte", wireType)
			}
			m.RocksdbBlockReadByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RocksdbBlockReadByte |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessedVersionsSize", wireType)
			}
			m.ProcessedVersionsSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessedVersionsSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RocksdbBlockReadNanos", wireType)
			}
			m.RocksdbBlockReadNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RocksdbBlockReadNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSnapshotNanos", wireType)
			}
			m.GetSnapshotNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetSnapshotNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIndexProposeWaitNanos", wireType)
			}
			m.ReadIndexProposeWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadIndexProposeWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIndexConfirmWaitNanos", wireType)
			}
			m.ReadIndexConfirmWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadIndexConfirmWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadPoolScheduleWaitNanos", wireType)
			}
			m.ReadPoolScheduleWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadPoolScheduleWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeDetail == nil {
				m.TimeDetail = &TimeDetail{}
			}
			if err := m.TimeDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScanDetail == nil {
				m.ScanDetail = &ScanDetail{}
			}
			if err := m.ScanDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecDetailsV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecDetailsV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecDetailsV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeDetail == nil {
				m.TimeDetail = &TimeDetail{}
			}
			if err := m.TimeDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanDetailV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScanDetailV2 == nil {
				m.ScanDetailV2 = &ScanDetailV2{}
			}
			if err := m.ScanDetailV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteDetail == nil {
				m.WriteDetail = &WriteDetail{}
			}
			if err := m.WriteDetail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeDetailV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeDetailV2 == nil {
				m.TimeDetailV2 = &TimeDetailV2{}
			}
			if err := m.TimeDetailV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreBatchWaitNanos", wireType)
			}
			m.StoreBatchWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreBatchWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposeSendWaitNanos", wireType)
			}
			m.ProposeSendWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposeSendWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistLogNanos", wireType)
			}
			m.PersistLogNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PersistLogNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftDbWriteLeaderWaitNanos", wireType)
			}
			m.RaftDbWriteLeaderWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftDbWriteLeaderWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftDbSyncLogNanos", wireType)
			}
			m.RaftDbSyncLogNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftDbSyncLogNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftDbWriteMemtableNanos", wireType)
			}
			m.RaftDbWriteMemtableNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftDbWriteMemtableNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitLogNanos", wireType)
			}
			m.CommitLogNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitLogNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyBatchWaitNanos", wireType)
			}
			m.ApplyBatchWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyBatchWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyLogNanos", wireType)
			}
			m.ApplyLogNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyLogNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyMutexLockNanos", wireType)
			}
			m.ApplyMutexLockNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyMutexLockNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyWriteLeaderWaitNanos", wireType)
			}
			m.ApplyWriteLeaderWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyWriteLeaderWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyWriteWalNanos", wireType)
			}
			m.ApplyWriteWalNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyWriteWalNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyWriteMemtableNanos", wireType)
			}
			m.ApplyWriteMemtableNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyWriteMemtableNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatchWaitNanos", wireType)
			}
			m.LatchWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatchWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessNanos", wireType)
			}
			m.ProcessNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottleNanos", wireType)
			}
			m.ThrottleNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThrottleNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PessimisticLockWaitNanos", wireType)
			}
			m.PessimisticLockWaitNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PessimisticLockWaitNanos |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KvPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KvPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KvPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &KeyError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mutation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mutation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mutation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assertion", wireType)
			}
			m.Assertion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Assertion |= (Assertion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccWrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccWrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccWrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortValue = append(m.ShortValue[:0], dAtA[iNdEx:postIndex]...)
			if m.ShortValue == nil {
				m.ShortValue = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasOverlappedRollback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasOverlappedRollback = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasGcFence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasGcFence = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcFence", wireType)
			}
			m.GcFence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GcFence |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChangeTs", wireType)
			}
			m.LastChangeTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastChangeTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionsToLastChange", wireType)
			}
			m.VersionsToLastChange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionsToLastChange |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccLock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccLock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccLock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Op(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Primary = append(m.Primary[:0], dAtA[iNdEx:postIndex]...)
			if m.Primary == nil {
				m.Primary = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortValue = append(m.ShortValue[:0], dAtA[iNdEx:postIndex]...)
			if m.ShortValue == nil {
				m.ShortValue = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForUpdateTs", wireType)
			}
			m.ForUpdateTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForUpdateTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnSize", wireType)
			}
			m.TxnSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseAsyncCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseAsyncCommit = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secondaries", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secondaries = append(m.Secondaries, make([]byte, postIndex-iNdEx))
			copy(m.Secondaries[len(m.Secondaries)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RollbackTs = append(m.RollbackTs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKvrpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKvrpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RollbackTs = append(m.RollbackTs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackTs", wireType)
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChangeTs", wireType)
			}
			m.LastChangeTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastChangeTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionsToLastChange", wireType)
			}
			m.VersionsToLastChange = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionsToLastChange |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MvccInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MvccInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MvccInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lock == nil {
				m.Lock = &MvccLock{}
			}
			if err := m.Lock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Writes = append(m.Writes, &MvccWrite{})
			if err := m.Writes[len(m.Writes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &MvccValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			m.Txn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Txn |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionEpoch == nil {
				m.RegionEpoch = &metapb.RegionEpoch{}
			}
			if err := m.RegionEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadState == nil {
				m.ReadState = &ReadState{}
			}
			if err := m.ReadState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedIndex", wireType)
			}
			m.AppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppliedIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeTs", wireType)
			}
			m.SafeTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckLeaderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckLeaderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckLeaderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, &LeaderInfo{})
			if err := m.Regions[len(m.Regions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckLeaderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckLeaderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckLeaderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Regions = append(m.Regions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKvrpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKvrpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Regions = append(m.Regions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreSafeTSRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreSafeTSRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreSafeTSRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreSafeTSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreSafeTSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreSafeTSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeTs", wireType)
			}
			m.SafeTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawGetKeyTTLRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawGetKeyTTLRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawGetKeyTTLRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawGetKeyTTLResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawGetKeyTTLResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawGetKeyTTLResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotFound", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotFound = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCASRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCASRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCASRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousNotExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreviousNotExist = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousValue = append(m.PreviousValue[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviousValue == nil {
				m.PreviousValue = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCASResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCASResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCASResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Succeed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Succeed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousNotExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreviousNotExist = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousValue = append(m.PreviousValue[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviousValue == nil {
				m.PreviousValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockWaitInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockWaitInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockWaitInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockWaitInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockWaitInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockWaitInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &deadlock.WaitForEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockWaitHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockWaitHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockWaitHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockWaitHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockWaitHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockWaitHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &deadlock.WaitForEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCoprocessorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCoprocessorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCoprocessorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoprName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoprName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoprVersionReq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoprVersionReq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &KeyRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawCoprocessorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawCoprocessorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawCoprocessorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawChecksumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawChecksumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawChecksumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= (ChecksumAlgorithm(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &KeyRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawChecksumResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawChecksumResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawChecksumResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			m.Checksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Checksum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalKvs", wireType)
			}
			m.TotalKvs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalKvs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrInvalidStartKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompactErrorInvalidStartKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Error = &CompactError_ErrInvalidStartKey{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrPhysicalTableNotExist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompactErrorPhysicalTableNotExist{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Error = &CompactError_ErrPhysicalTableNotExist{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCompactInProgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompactErrorCompactInProgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Error = &CompactError_ErrCompactInProgress{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrTooManyPendingTasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompactErrorTooManyPendingTasks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Error = &CompactError_ErrTooManyPendingTasks{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactErrorInvalidStartKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactErrorInvalidStartKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactErrorInvalidStartKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactErrorPhysicalTableNotExist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactErrorPhysicalTableNotExist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactErrorPhysicalTableNotExist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactErrorCompactInProgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactErrorCompactInProgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactErrorCompactInProgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactErrorTooManyPendingTasks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactErrorTooManyPendingTasks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactErrorTooManyPendingTasks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalTableId", wireType)
			}
			m.PhysicalTableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhysicalTableId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalTableId", wireType)
			}
			m.LogicalTableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogicalTableId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			m.ApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiVersion |= (APIVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceId", wireType)
			}
			m.KeyspaceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &CompactError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasRemaining", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasRemaining = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactedStartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompactedStartKey = append(m.CompactedStartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.CompactedStartKey == nil {
				m.CompactedStartKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactedEndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompactedEndKey = append(m.CompactedEndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.CompactedEndKey == nil {
				m.CompactedEndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiFlashSystemTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiFlashSystemTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiFlashSystemTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TiFlashSystemTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TiFlashSystemTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TiFlashSystemTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TxnEntry_Prewrite{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entry = &TxnEntry_Prewrite_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TxnEntry_Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Entry = &TxnEntry_Commit_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnEntry_Prewrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Prewrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Prewrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryKey = append(m.PrimaryKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrimaryKey == nil {
				m.PrimaryKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnEntry_Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanTxnEntriesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanTxnEntriesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanTxnEntriesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOnly = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTs", wireType)
			}
			m.StartTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionsPerKey", wireType)
			}
			m.VersionsPerKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionsPerKey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanTxnEntriesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanTxnEntriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanTxnEntriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TxnEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKvrpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKvrpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKvrpcpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKvrpcpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKvrpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthKvrpcpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKvrpcpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKvrpcpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKvrpcpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKvrpcpb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kvrpcpb.proto", fileDescriptorKvrpcpb) }

var fileDescriptorKvrpcpb = []byte{
	// 7048 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x7c, 0x59, 0x6c, 0x23, 0xc9,
	0x79, 0xb0, 0x9a, 0xa4, 0x44, 0xea, 0xa3, 0x44, 0xb5, 0x4a, 0x17, 0xa5, 0x99, 0xd9, 0x99, 0xe9,
	0xf5, 0xec, 0x8e, 0xb5, 0x5e, 0x8d, 0x57, 0x7b, 0xf8, 0xfc, 0xd7, 0x3b, 0xa3, 0xb9, 0xb4, 0x73,
	0x48, 0x68, 0x72, 0x67, 0xff, 0xc5, 0xff, 0xdb, 0xed, 0x52, 0xb3, 0x44, 0x36, 0xd4, 0xec, 0xee,
	0xed, 0x2a, 0x4a, 0xa2, 0x83, 0x00, 0x31, 0x72, 0x00, 0x0e, 0x12, 0x27, 0x36, 0x0c, 0x38, 0x80,
	0x8d, 0x00, 0x79, 0x30, 0x10, 0xe7, 0x21, 0x40, 0x90, 0x97, 0x1c, 0x0f, 0x41, 0x00, 0x3f, 0x6c,
	0x82, 0x18, 0x36, 0x10, 0x04, 0x0e, 0xec, 0xc0, 0x08, 0x36, 0x40, 0x5e, 0x93, 0x97, 0x20, 0x79,
	0x09, 0x12, 0xd4, 0xd5, 0x07, 0xc9, 0xd1, 0x68, 0x34, 0x9a, 0xb1, 0x93, 0x27, 0xb2, 0xbf, 0xef,
	0xab, 0xaa, 0xef, 0xaa, 0xaf, 0xae, 0xaf, 0x0a, 0xa6, 0xf7, 0xf6, 0xe3, 0xc8, 0x8d, 0x76, 0xd6,
	0xa2, 0x38, 0x64, 0x21, 0x2a, 0xab, 0xcf, 0x95, 0xa9, 0x2e, 0x61, 0x58, 0x83, 0x57, 0xa6, 0x49,
	0x1c, 0x87, 0x71, 0xf2, 0x39, 0xdf, 0x0e, 0xdb, 0xa1, 0xf8, 0x7b, 0x85, 0xff, 0x53, 0xd0, 0x99,
	0xb8, 0x47, 0x99, 0xf8, 0xab, 0x00, 0xb5, 0x16, 0xc1, 0x2d, 0x3f, 0x74, 0xf7, 0x74, 0x2d, 0x2c,
	0xc6, 0x2e, 0x49, 0x6a, 0x59, 0x8c, 0x09, 0x0d, 0x7b, 0xb1, 0x4b, 0x9c, 0x2e, 0x0e, 0x70, 0x9b,
	0xc4, 0x12, 0x6e, 0xb5, 0x00, 0x6e, 0x11, 0x66, 0x93, 0xf7, 0x7b, 0x84, 0x32, 0xb4, 0x0a, 0x65,
	0x37, 0x0c, 0x18, 0x39, 0x64, 0x75, 0xe3, 0x82, 0x71, 0xb9, 0xba, 0x6e, 0xae, 0x69, 0x96, 0x37,
	0x24, 0xdc, 0xd6, 0x04, 0xc8, 0x84, 0xe2, 0x1e, 0xe9, 0xd7, 0x0b, 0x17, 0x8c, 0xcb, 0x53, 0x36,
	0xff, 0x8b, 0xea, 0x50, 0xde, 0x27, 0x31, 0xf5, 0xc2, 0xa0, 0x5e, 0xbc, 0x60, 0x5c, 0x2e, 0xd9,
	0xfa, 0xd3, 0xfa, 0xd0, 0x80, 0xaa, 0x68, 0x86, 0x46, 0x61, 0x40, 0x09, 0x7a, 0x05, 0xa6, 0x62,
	0xd2, 0xf6, 0xc2, 0xc0, 0x11, 0xb2, 0xaa, 0xc6, 0x6a, 0x6b, 0x5a, 0xf2, 0x1b, 0xfc, 0xd7, 0xae,
	0x4a, 0x1a, 0xf1, 0x81, 0x5e, 0x84, 0x71, 0x49, 0x5b, 0x10, 0xb4, 0xb3, 0x09, 0x63, 0x77, 0x48,
	0x5f, 0x92, 0x4b, 0x3c, 0x9a, 0x87, 0xf1, 0x7d, 0xec, 0xf7, 0x88, 0xe0, 0x61, 0xca, 0x96, 0x1f,
	0xe8, 0x0c, 0x4c, 0x06, 0x21, 0x73, 0x76, 0xc3, 0x5e, 0xd0, 0xaa, 0x97, 0x2e, 0x18, 0x97, 0x2b,
	0x76, 0x25, 0x08, 0xd9, 0x4d, 0xfe, 0x8d, 0xde, 0x84, 0x19, 0x72, 0x48, 0x5c, 0xa7, 0x45, 0x18,
	0xf6, 0x7c, 0xea, 0xec, 0xaf, 0xd7, 0x27, 0x44, 0x2b, 0x8b, 0x49, 0x2b, 0x37, 0x0e, 0x89, 0x7b,
	0x5d, 0xa2, 0x1f, 0xac, 0xdb, 0xd3, 0x24, 0xfb, 0xf9, 0x76, 0xa9, 0x32, 0x6e, 0x4e, 0x58, 0xff,
	0x66, 0x40, 0xb5, 0xe1, 0xe2, 0xe0, 0x24, 0xca, 0x3c, 0x03, 0x93, 0x94, 0xe1, 0x98, 0x39, 0xa9,
	0x4a, 0x2b, 0x02, 0x70, 0x87, 0xf4, 0xb9, 0x44, 0xbe, 0xd7, 0xf5, 0x98, 0x90, 0x68, 0xda, 0x96,
	0x1f, 0x59, 0x6d, 0x97, 0x72, 0xda, 0x46, 0xcb, 0x50, 0xd9, 0x23, 0x7d, 0x27, 0x0c, 0xfc, 0x7e,
	0x7d, 0x5c, 0x88, 0x5a, 0xde, 0x23, 0xfd, 0xad, 0xc0, 0x17, 0x26, 0x8a, 0x09, 0xa7, 0x23, 0x42,
	0xc2, 0x8a, 0xad, 0x3f, 0xd1, 0x12, 0x94, 0x49, 0xd0, 0x12, 0xed, 0x97, 0x45, 0xfb, 0x13, 0x24,
	0x68, 0xf1, 0xd6, 0xcf, 0x43, 0x95, 0xe2, 0x6e, 0xe4, 0x13, 0x87, 0x32, 0x12, 0xd5, 0x2b, 0x82,
	0x07, 0x90, 0xa0, 0x06, 0x23, 0x91, 0xf5, 0x35, 0x03, 0xa6, 0xa4, 0xdc, 0x27, 0xb7, 0xee, 0x25,
	0x18, 0x8f, 0xb0, 0x17, 0xd3, 0x7a, 0xe1, 0x42, 0xf1, 0x72, 0x75, 0x7d, 0x26, 0xb5, 0xee, 0xfe,
	0x36, 0xf6, 0x62, 0x5b, 0x62, 0x53, 0x27, 0x28, 0x1e, 0xed, 0x04, 0xd6, 0x07, 0x65, 0x98, 0xd9,
	0x8e, 0xc9, 0x41, 0xec, 0x31, 0x72, 0x12, 0x7b, 0x5c, 0x81, 0xc9, 0x6e, 0x8f, 0x61, 0xe6, 0x85,
	0x81, 0xe6, 0x29, 0x6d, 0xec, 0x9e, 0xc2, 0xd8, 0x29, 0x0d, 0xba, 0x08, 0x53, 0x51, 0xec, 0x75,
	0x71, 0xdc, 0x77, 0x78, 0x27, 0x54, 0xce, 0x57, 0x55, 0xb0, 0xbb, 0xa1, 0xbb, 0x87, 0x9e, 0x87,
	0x69, 0x69, 0xe3, 0xbc, 0xd9, 0xa6, 0x04, 0xf0, 0x41, 0x6a, 0x3b, 0x5e, 0xde, 0x61, 0xcc, 0x17,
	0xb6, 0x2b, 0xd9, 0x65, 0xfe, 0xdd, 0x64, 0x3e, 0x5a, 0x87, 0x05, 0xba, 0xe7, 0x45, 0x8e, 0x1b,
	0x06, 0x94, 0xc5, 0xd8, 0x0b, 0x98, 0xe3, 0x76, 0x88, 0xbb, 0xa7, 0x2c, 0x39, 0xc7, 0x91, 0x1b,
	0x09, 0x6e, 0x83, 0xa3, 0xd0, 0xff, 0x83, 0xb9, 0x88, 0x50, 0xea, 0x75, 0x3d, 0xca, 0x3c, 0xd7,
	0xc1, 0xae, 0x94, 0xa8, 0x7c, 0xa1, 0x78, 0xb9, 0xb6, 0xbe, 0x9a, 0x48, 0x34, 0xa0, 0xaa, 0xb5,
	0xed, 0xb4, 0xcc, 0x55, 0x51, 0xc4, 0x46, 0xd1, 0x20, 0x88, 0x72, 0x5e, 0xd9, 0x61, 0xe0, 0x50,
	0xef, 0x4b, 0x44, 0xb8, 0x45, 0xc9, 0x2e, 0xb3, 0xc3, 0xa0, 0xe1, 0x7d, 0x89, 0x20, 0x0b, 0xa6,
	0x77, 0xc3, 0xd8, 0xe9, 0x45, 0x2d, 0xcc, 0x88, 0xc3, 0x68, 0x7d, 0x52, 0xe0, 0xab, 0xbb, 0x61,
	0xfc, 0x8e, 0x80, 0x35, 0x29, 0xa7, 0xe9, 0x7a, 0x81, 0xe3, 0x86, 0xdd, 0xae, 0xc7, 0x38, 0x0d,
	0x48, 0x9a, 0xae, 0x17, 0x6c, 0x08, 0x58, 0x93, 0xa2, 0xcb, 0x60, 0xf6, 0x28, 0x71, 0x30, 0xed,
	0x07, 0xae, 0xa2, 0xac, 0x57, 0x85, 0xb8, 0xb5, 0x1e, 0x25, 0x57, 0x39, 0x58, 0xd2, 0xa2, 0x0b,
	0x50, 0xa5, 0xc4, 0x0d, 0x83, 0x16, 0x8e, 0x3d, 0x42, 0xeb, 0x53, 0x17, 0x8a, 0x5c, 0xff, 0x19,
	0x10, 0x3a, 0x0b, 0xc0, 0x62, 0xde, 0x2d, 0x88, 0x13, 0xb9, 0xf5, 0x69, 0x19, 0x03, 0x58, 0xdc,
	0xdf, 0x0a, 0xc8, 0xb6, 0x2b, 0xb8, 0xc1, 0x87, 0x19, 0x6e, 0x6a, 0x8a, 0x1b, 0x7c, 0x98, 0x70,
	0xf3, 0x16, 0xcc, 0x60, 0x4a, 0x49, 0xcc, 0xc5, 0x77, 0x7c, 0xb2, 0x4f, 0xfc, 0xfa, 0xcc, 0x05,
	0xe3, 0x72, 0x6d, 0x7d, 0x29, 0xd1, 0xe4, 0x55, 0x8d, 0xbf, 0xcb, 0xd1, 0x76, 0x0d, 0xe7, 0xbe,
	0x91, 0x07, 0xcb, 0x39, 0xbd, 0x64, 0x8c, 0x49, 0xeb, 0xa6, 0xf0, 0xb3, 0xb5, 0x87, 0x5a, 0xe5,
	0x66, 0xa2, 0xbc, 0x46, 0x6a, 0x67, 0x7b, 0x31, 0xa3, 0xd3, 0x14, 0x4c, 0x57, 0x76, 0x60, 0x61,
	0x64, 0x01, 0x1e, 0x4e, 0xbc, 0xa0, 0x45, 0x0e, 0x45, 0x2f, 0x98, 0xb6, 0xe5, 0x07, 0x7a, 0x15,
	0x16, 0xc9, 0x61, 0x44, 0x5c, 0x46, 0x5a, 0x4e, 0xde, 0x74, 0x05, 0xa1, 0x88, 0x39, 0x8d, 0x4d,
	0x2b, 0xa5, 0xd6, 0x0e, 0xcc, 0x0e, 0xb9, 0x0a, 0x5a, 0x81, 0xc5, 0xc6, 0x9d, 0xcd, 0x6d, 0x67,
	0xfb, 0x46, 0xa3, 0xb1, 0x79, 0x6f, 0xb3, 0xd1, 0xdc, 0xdc, 0x70, 0x36, 0x6e, 0xdf, 0xd8, 0xb8,
	0x63, 0x8e, 0xa1, 0x3a, 0xcc, 0x5f, 0xdf, 0x1a, 0x81, 0x31, 0xd0, 0x12, 0xcc, 0x5d, 0xdf, 0x72,
	0x36, 0xb6, 0xee, 0x37, 0x9a, 0xf6, 0xd5, 0xcd, 0xfb, 0x4d, 0x85, 0x28, 0x58, 0xff, 0x69, 0x80,
	0x99, 0x6a, 0xe2, 0xe4, 0x21, 0xe6, 0xa3, 0x30, 0x21, 0xb0, 0xc3, 0xfd, 0x39, 0x09, 0x1e, 0x8a,
	0x60, 0xd8, 0x33, 0x8b, 0xc3, 0x9e, 0xf9, 0x22, 0x98, 0xd2, 0x93, 0x32, 0x64, 0xb2, 0x43, 0x4f,
	0x87, 0xdc, 0xa1, 0x12, 0xc2, 0x11, 0x83, 0xcb, 0xf8, 0x63, 0x0c, 0x2e, 0xd6, 0xf7, 0x4a, 0xb0,
	0x98, 0x51, 0x32, 0x0f, 0x25, 0xff, 0x5b, 0x22, 0xda, 0x50, 0x94, 0x98, 0x18, 0x19, 0x25, 0x3c,
	0xea, 0xec, 0x7a, 0x31, 0x65, 0x92, 0x8f, 0xb2, 0xe8, 0xb8, 0x55, 0x8f, 0xde, 0xe4, 0x30, 0xc1,
	0xc7, 0x45, 0x98, 0x3a, 0xc0, 0xdc, 0x04, 0x5e, 0x97, 0x84, 0x3d, 0x26, 0x82, 0x51, 0xd1, 0xae,
	0x72, 0x58, 0x53, 0x82, 0x50, 0x1d, 0xc6, 0x77, 0xc3, 0xd8, 0x25, 0x22, 0x10, 0x55, 0xae, 0x15,
	0xea, 0x86, 0x2d, 0x01, 0x5c, 0x88, 0x98, 0xb0, 0x5e, 0x1c, 0x38, 0x62, 0xa6, 0x20, 0xc3, 0x50,
	0xc5, 0x9e, 0x92, 0xc0, 0x07, 0x02, 0x36, 0xec, 0x11, 0xd5, 0x51, 0x1e, 0x31, 0x23, 0xe2, 0xb1,
	0x43, 0x0e, 0x3d, 0xca, 0x48, 0xe0, 0x92, 0xfa, 0x94, 0x0c, 0x55, 0x02, 0x7c, 0x43, 0x43, 0xd1,
	0xcb, 0x30, 0x27, 0x34, 0xc2, 0x07, 0x68, 0xc7, 0xdb, 0x95, 0xf4, 0x54, 0x45, 0x24, 0x93, 0xa3,
	0xf8, 0x58, 0xbd, 0xb9, 0x2b, 0x4a, 0x50, 0x74, 0x9d, 0x4b, 0xb7, 0x47, 0x9c, 0x5e, 0xe4, 0x74,
	0xc3, 0x16, 0x11, 0x81, 0xa9, 0xb6, 0x6e, 0xa5, 0x61, 0x22, 0xef, 0x1c, 0xef, 0xe2, 0x3d, 0xf2,
	0x4e, 0x74, 0x2f, 0x6c, 0x11, 0x1b, 0x0e, 0x92, 0xff, 0xd6, 0xbf, 0x1a, 0x50, 0x1f, 0xa0, 0xbc,
	0x43, 0xfa, 0x36, 0xa1, 0x3d, 0x9f, 0xa1, 0x4f, 0x41, 0x89, 0xf5, 0x23, 0x22, 0xbc, 0xa8, 0xb6,
	0x7e, 0xe9, 0x61, 0x55, 0x27, 0x05, 0x9a, 0xfd, 0x88, 0xd8, 0xa2, 0x48, 0x3a, 0xdd, 0x2a, 0x64,
	0xa7, 0x5b, 0x67, 0x61, 0x32, 0xd5, 0x42, 0x51, 0x08, 0x96, 0x02, 0xd0, 0xeb, 0xb0, 0xc4, 0xa5,
	0x24, 0x2d, 0xe7, 0xc0, 0x63, 0x1d, 0x1e, 0x03, 0x77, 0x7d, 0xcf, 0xcd, 0x74, 0xa1, 0x79, 0x89,
	0x7e, 0xd7, 0x63, 0x9d, 0x0d, 0x85, 0x6c, 0x52, 0xb4, 0x06, 0x62, 0x8c, 0x73, 0xf8, 0x54, 0xd6,
	0xdf, 0xf7, 0x82, 0xb6, 0x74, 0x08, 0x39, 0x1e, 0xcc, 0x72, 0x94, 0xad, 0x31, 0x9c, 0x5b, 0xeb,
	0x9f, 0x0b, 0xb0, 0x34, 0xd4, 0x73, 0x9e, 0x49, 0x00, 0x39, 0x0f, 0x93, 0x03, 0xc1, 0x43, 0x78,
	0x5c, 0xc5, 0xd5, 0xbe, 0x52, 0xd7, 0x5a, 0xe3, 0xf2, 0x4e, 0x49, 0x77, 0x94, 0x9a, 0x5b, 0x84,
	0x09, 0xe5, 0x87, 0xe3, 0x62, 0x08, 0x53, 0x5f, 0xe8, 0x1c, 0x40, 0x32, 0x81, 0xe5, 0x1d, 0xa5,
	0xc8, 0x55, 0xaa, 0x67, 0xb0, 0x23, 0xa3, 0x4c, 0xf9, 0x31, 0xa2, 0x0c, 0xfa, 0x0c, 0x9f, 0x18,
	0x72, 0xd3, 0xd2, 0x7a, 0x45, 0x48, 0x77, 0xf1, 0x91, 0x4e, 0x60, 0xeb, 0x12, 0xd6, 0x77, 0x0c,
	0x58, 0xc9, 0x50, 0xd9, 0xa1, 0xef, 0xef, 0xe0, 0x93, 0x85, 0xa9, 0xa1, 0x90, 0x52, 0x18, 0x11,
	0x52, 0x86, 0xe2, 0x46, 0x71, 0x38, 0x6e, 0x20, 0x28, 0xed, 0x91, 0x3e, 0x77, 0x28, 0xae, 0x45,
	0xf1, 0xdf, 0xfa, 0x73, 0x03, 0xce, 0x8c, 0xe4, 0xf3, 0x99, 0x38, 0xc5, 0x08, 0x13, 0x15, 0x1f,
	0x67, 0x20, 0xf8, 0x23, 0x03, 0xe6, 0x9a, 0x87, 0xc1, 0x6d, 0x82, 0x63, 0x76, 0x8d, 0xe0, 0x13,
	0x2d, 0xda, 0x06, 0x83, 0x7a, 0xe1, 0x18, 0x41, 0xbd, 0x38, 0xc2, 0x02, 0x2f, 0xc0, 0x0c, 0x6e,
	0xed, 0x7b, 0x94, 0x38, 0x49, 0x6c, 0x57, 0x83, 0x9f, 0x04, 0xdf, 0x95, 0x11, 0xde, 0xfa, 0xbe,
	0x01, 0xf3, 0x79, 0x9e, 0x9f, 0xc1, 0x0a, 0x30, 0x3b, 0xe2, 0x14, 0xf3, 0x23, 0xce, 0x08, 0x1b,
	0x94, 0x1e, 0xc7, 0x06, 0xbf, 0x59, 0x84, 0x05, 0x31, 0xb3, 0x6e, 0x1e, 0x06, 0x0d, 0x86, 0x59,
	0x8f, 0x9e, 0xc4, 0x0a, 0xe7, 0x41, 0x6b, 0x3c, 0xb3, 0xde, 0x03, 0x05, 0xe2, 0x6b, 0xae, 0x25,
	0x28, 0x4b, 0x09, 0xb4, 0x6b, 0x4f, 0x08, 0x01, 0x28, 0xd7, 0xbb, 0x8b, 0x7d, 0x9f, 0xc4, 0x8e,
	0xb4, 0x51, 0x3a, 0xe9, 0x90, 0xe0, 0x06, 0x87, 0x36, 0x45, 0xb4, 0x70, 0x7b, 0x71, 0x4c, 0x02,
	0x41, 0x22, 0x87, 0xdd, 0x49, 0x05, 0x69, 0x52, 0xf4, 0x0a, 0x2c, 0xc4, 0xca, 0xf9, 0xf9, 0x00,
	0xc4, 0x03, 0x8b, 0x88, 0xce, 0x6a, 0x29, 0x81, 0x34, 0x72, 0x73, 0xf7, 0x7e, 0xc8, 0xc4, 0x30,
	0x84, 0x56, 0x61, 0x56, 0x8c, 0x97, 0x4e, 0x76, 0x2a, 0x2e, 0xc7, 0xe2, 0x19, 0x81, 0x68, 0xa4,
	0x73, 0xf1, 0xcf, 0xc2, 0x4a, 0x1a, 0xa3, 0xb3, 0xeb, 0x0f, 0xe1, 0x73, 0x15, 0x51, 0xa8, 0x9e,
	0x50, 0x0c, 0xc4, 0x17, 0xde, 0xd2, 0x3e, 0x89, 0xbd, 0xdd, 0xbe, 0xe3, 0x51, 0x47, 0x29, 0x45,
	0x0e, 0xdb, 0xf6, 0x8c, 0x44, 0x6c, 0xd2, 0x6d, 0x09, 0xb6, 0x7e, 0x50, 0x80, 0xc5, 0x41, 0x7b,
	0xfc, 0x6c, 0x3d, 0xec, 0x12, 0xd4, 0x54, 0xe8, 0xcf, 0x4f, 0x8a, 0xa6, 0x25, 0x54, 0x77, 0xa0,
	0x17, 0x61, 0x42, 0x2e, 0xc6, 0x84, 0x71, 0x6a, 0x99, 0x15, 0xaf, 0x5a, 0x70, 0x29, 0x34, 0x5a,
	0x83, 0x49, 0xd1, 0x94, 0x17, 0xec, 0x86, 0x6a, 0x57, 0x22, 0xe5, 0x8b, 0xeb, 0x6b, 0x33, 0xd8,
	0x0d, 0x6d, 0xc1, 0x0e, 0xff, 0xf7, 0xa4, 0x03, 0x81, 0xf5, 0x65, 0x03, 0x56, 0x84, 0x46, 0x1b,
	0x6a, 0xe9, 0x24, 0xa2, 0xc2, 0x89, 0xdc, 0x5c, 0x87, 0xe0, 0x42, 0x1a, 0x82, 0x8f, 0x15, 0x5d,
	0xac, 0xff, 0x32, 0xe0, 0xcc, 0x48, 0x1e, 0x9e, 0x81, 0x69, 0x5f, 0x84, 0x71, 0xae, 0x4b, 0xde,
	0xf1, 0x8a, 0xa3, 0x75, 0x2d, 0xf1, 0xe8, 0x4c, 0x76, 0x8c, 0x97, 0x36, 0x4e, 0xc7, 0xf7, 0x27,
	0x9d, 0xf4, 0x7f, 0xd7, 0x80, 0x69, 0xd9, 0x99, 0x9e, 0xda, 0x20, 0xaa, 0xad, 0x53, 0xcc, 0x58,
	0xe7, 0x78, 0xce, 0x2b, 0xf7, 0xbb, 0xec, 0x89, 0x1d, 0x2f, 0xf0, 0xc3, 0xb6, 0xf5, 0xb7, 0x06,
	0xd4, 0x34, 0xaf, 0xcf, 0xc0, 0x40, 0xc3, 0x3c, 0x16, 0x47, 0x75, 0xb0, 0x27, 0x8d, 0xf4, 0x6d,
	0x98, 0xde, 0xec, 0x46, 0x61, 0x9c, 0x18, 0x20, 0xb7, 0x80, 0x32, 0x8e, 0xb1, 0x80, 0x1a, 0x66,
	0xb4, 0x30, 0x82, 0x51, 0xeb, 0x3d, 0xa8, 0xe9, 0x86, 0x4e, 0xae, 0xbd, 0xf9, 0xac, 0xf6, 0x26,
	0xf5, 0x2e, 0xd8, 0xd7, 0xb9, 0x65, 0x7c, 0x82, 0x83, 0x5e, 0x74, 0x3a, 0x3b, 0xbc, 0xc7, 0x9a,
	0x1b, 0xe4, 0xc7, 0x9e, 0xd2, 0xc0, 0xd8, 0x63, 0x7d, 0xc3, 0x80, 0x99, 0x84, 0xa9, 0x9f, 0x1b,
	0x7f, 0xb1, 0xf6, 0x60, 0xe6, 0x1a, 0x66, 0x6e, 0xe7, 0x84, 0xbb, 0xe1, 0xa3, 0x62, 0xdd, 0xc3,
	0xf7, 0xc3, 0x7f, 0x62, 0x80, 0x99, 0xb6, 0xf6, 0xd4, 0xb7, 0x4d, 0x9f, 0xb0, 0x2f, 0xa4, 0xba,
	0x1e, 0x3f, 0x5a, 0xd7, 0x6f, 0x97, 0x2a, 0x45, 0xb3, 0x64, 0xfd, 0x02, 0xcc, 0x0b, 0xe1, 0x9e,
	0xfa, 0x3a, 0x60, 0x44, 0x08, 0xb3, 0xfe, 0xd8, 0x80, 0x85, 0x81, 0xd6, 0x9f, 0x81, 0x93, 0x3d,
	0xe9, 0xdc, 0xfe, 0x0f, 0x0c, 0x98, 0x69, 0xb8, 0x38, 0x38, 0xe9, 0xee, 0xce, 0x79, 0xa8, 0x76,
	0xf1, 0xe1, 0x80, 0xb2, 0xa0, 0x8b, 0x0f, 0xb5, 0xaa, 0x72, 0x07, 0x0c, 0xc5, 0x87, 0x1d, 0x30,
	0x94, 0xb2, 0x07, 0x0c, 0x99, 0x13, 0x81, 0xf1, 0xec, 0x89, 0x80, 0xf5, 0x23, 0x03, 0xcc, 0x94,
	0xd9, 0x9f, 0xa7, 0x31, 0xf9, 0x49, 0x83, 0xfe, 0x0f, 0x0c, 0x40, 0x72, 0x0f, 0x81, 0x9c, 0xd4,
	0x12, 0xc7, 0x72, 0xdc, 0x63, 0x8e, 0x61, 0x2f, 0xc3, 0x24, 0x3b, 0x0c, 0xc4, 0xd4, 0x4f, 0x2e,
	0x64, 0xb3, 0x2d, 0x37, 0x0f, 0x03, 0x39, 0xf5, 0x63, 0xf2, 0x4f, 0xba, 0xe4, 0x1d, 0xcf, 0x74,
	0x07, 0xbe, 0x68, 0xcc, 0x49, 0xf4, 0x3f, 0xa0, 0x33, 0x3c, 0x80, 0xc9, 0x5b, 0x1b, 0x27, 0xd1,
	0xfd, 0x39, 0x00, 0x8a, 0x77, 0x89, 0x13, 0x85, 0x5e, 0xc0, 0x94, 0xe2, 0x27, 0x39, 0x64, 0x9b,
	0x03, 0xac, 0x0e, 0x00, 0xaf, 0xf7, 0xe9, 0x6b, 0xc0, 0xfa, 0xa6, 0x01, 0xe8, 0x3a, 0xf1, 0x09,
	0x23, 0x36, 0x0e, 0xda, 0xe4, 0xd4, 0x4f, 0x04, 0x33, 0x5d, 0xb3, 0x38, 0x78, 0x58, 0x17, 0x84,
	0x8c, 0xaf, 0x9d, 0xc4, 0xe9, 0x9f, 0x3c, 0xe8, 0x04, 0x09, 0xda, 0x0a, 0xfc, 0xbe, 0xf5, 0x05,
	0x98, 0xcb, 0x31, 0x76, 0xda, 0x53, 0x8e, 0x3f, 0x35, 0xe0, 0xc2, 0x76, 0x4c, 0x22, 0x1c, 0x93,
	0x9b, 0x3e, 0xa6, 0x1d, 0x1e, 0x81, 0x9b, 0xa1, 0x72, 0xe8, 0x67, 0xa7, 0x87, 0x65, 0xa8, 0x0c,
	0x2c, 0x90, 0xcb, 0x54, 0x2d, 0x8d, 0x33, 0xa3, 0xf2, 0x78, 0x7e, 0x54, 0xf6, 0xe1, 0xe2, 0x11,
	0xac, 0x9f, 0xb6, 0xa6, 0x7e, 0x60, 0xc0, 0xf2, 0xe9, 0xa8, 0x28, 0x23, 0x51, 0x21, 0x7f, 0x12,
	0x7c, 0x64, 0xd4, 0xcf, 0x28, 0xaf, 0xf4, 0x50, 0xe5, 0x8d, 0xe7, 0x95, 0x97, 0x5b, 0xf4, 0x4c,
	0xe4, 0x17, 0x3d, 0x16, 0x81, 0x95, 0x67, 0xa1, 0xb8, 0xcf, 0xc3, 0xb4, 0x8d, 0x0f, 0x4e, 0x2d,
	0x6b, 0xa1, 0x06, 0x05, 0x77, 0x57, 0x28, 0x67, 0xd2, 0x2e, 0xb8, 0xbb, 0xd6, 0x6f, 0x18, 0x50,
	0xd3, 0xf5, 0x9f, 0x32, 0xeb, 0x27, 0xc8, 0x4d, 0xb0, 0x5a, 0x80, 0x6c, 0x7c, 0x70, 0xda, 0x53,
	0xd3, 0x41, 0xa1, 0x43, 0x98, 0xcb, 0xb5, 0xf2, 0xb4, 0xa7, 0xa4, 0xd6, 0xef, 0x1a, 0xc2, 0x8a,
	0xdb, 0xbd, 0x53, 0xb2, 0xe2, 0x68, 0xcd, 0x4a, 0x31, 0x4b, 0x5a, 0x4c, 0x5e, 0x2e, 0x3d, 0x86,
	0xe2, 0x7f, 0x79, 0x27, 0xd8, 0x0d, 0x63, 0xc7, 0xc5, 0x54, 0xed, 0x7d, 0x4d, 0xec, 0x86, 0xf1,
	0x06, 0xa6, 0x7c, 0x59, 0xa6, 0xf9, 0x3b, 0x6d, 0x07, 0xfe, 0x33, 0x23, 0xb5, 0xe9, 0x09, 0x15,
	0x70, 0xcc, 0x89, 0xff, 0x80, 0x99, 0xd1, 0xbc, 0x94, 0xbf, 0x94, 0x9c, 0x48, 0x0c, 0xea, 0x60,
	0x3c, 0xab, 0x03, 0xee, 0x39, 0x8c, 0xf9, 0xf2, 0xb4, 0xa1, 0x64, 0x8b, 0xff, 0x7c, 0x00, 0xc9,
	0xf1, 0x7e, 0xda, 0xca, 0xe9, 0x83, 0x69, 0xe3, 0x03, 0x35, 0x46, 0x3d, 0x8d, 0x0e, 0x9e, 0x15,
	0xb7, 0x94, 0x33, 0xf9, 0xff, 0x87, 0xd9, 0x4c, 0xd3, 0xa7, 0x2d, 0xd8, 0x2f, 0x19, 0xb0, 0xa0,
	0x35, 0x77, 0x72, 0xf1, 0x8e, 0xd1, 0x99, 0x1f, 0x2e, 0x20, 0x86, 0xc5, 0x41, 0x0e, 0x4e, 0x5b,
	0xca, 0xef, 0xcb, 0xe8, 0xf9, 0x0c, 0xf3, 0xa0, 0xb2, 0xd9, 0x4e, 0xa5, 0x7c, 0xb6, 0x93, 0x54,
	0xcc, 0x78, 0xa2, 0x98, 0xc7, 0xcf, 0x7e, 0xb2, 0xda, 0x30, 0x93, 0x88, 0x73, 0x72, 0x5d, 0x5d,
	0x84, 0xe2, 0xde, 0xfe, 0x43, 0x3b, 0x2b, 0xc7, 0x59, 0x5f, 0x91, 0xee, 0xf1, 0x33, 0x99, 0x35,
	0x0e, 0x84, 0x49, 0xe5, 0x27, 0x4f, 0x75, 0x9e, 0xf8, 0x43, 0x23, 0x8d, 0x23, 0x27, 0x75, 0x96,
	0x8f, 0xc2, 0x44, 0xcc, 0xb9, 0x1b, 0x79, 0xf6, 0x26, 0xf9, 0x56, 0x04, 0x7c, 0x65, 0x40, 0xb0,
	0xdb, 0x71, 0xb2, 0xfe, 0x33, 0xc9, 0x21, 0x77, 0x4f, 0xcd, 0x87, 0x2c, 0x1f, 0xe6, 0xf3, 0x12,
	0x3d, 0x55, 0x7f, 0xf9, 0x45, 0x58, 0x7e, 0x27, 0xe0, 0x6b, 0x9b, 0xeb, 0x84, 0xb2, 0x38, 0xec,
	0x3f, 0x5b, 0x97, 0xe1, 0x73, 0xbd, 0x51, 0xcd, 0x9f, 0xb6, 0x9b, 0x7c, 0x11, 0xce, 0xd8, 0xa4,
	0xed, 0x51, 0x46, 0x62, 0xbe, 0x7c, 0xdd, 0xda, 0xa1, 0x24, 0xde, 0x27, 0xf1, 0x49, 0xe4, 0x5c,
	0x80, 0x89, 0x2e, 0x3e, 0x4c, 0x13, 0x9a, 0xc6, 0xbb, 0xf8, 0xb0, 0x49, 0xad, 0xd7, 0xe0, 0xec,
	0xe8, 0x16, 0x94, 0x28, 0x09, 0x5f, 0x46, 0x7e, 0x0e, 0x5a, 0x17, 0x07, 0x14, 0x4f, 0x89, 0xa9,
	0x1e, 0x2c, 0x8f, 0xa8, 0xfe, 0x28, 0x8e, 0xb8, 0x0b, 0x7b, 0xd4, 0x71, 0x7d, 0x82, 0xe5, 0x2a,
	0xa0, 0x62, 0x97, 0x3d, 0x2a, 0xf6, 0x59, 0x8f, 0xbd, 0x7d, 0x62, 0x7d, 0x01, 0x96, 0x6d, 0xd2,
	0x0d, 0xe5, 0x56, 0xc1, 0x53, 0x10, 0x6b, 0x1d, 0x56, 0x46, 0xd5, 0x7f, 0xa4, 0xa6, 0x7f, 0xcb,
	0x80, 0xa5, 0xed, 0x4e, 0x9f, 0x7a, 0x2e, 0xf6, 0x9f, 0x64, 0x87, 0x6c, 0x34, 0x4b, 0x27, 0xd8,
	0x17, 0xb3, 0xde, 0x83, 0xfa, 0x30, 0x43, 0x47, 0xda, 0x26, 0x31, 0x40, 0xe1, 0x11, 0x06, 0xf8,
	0xb6, 0x01, 0xa8, 0x11, 0xf9, 0x1e, 0xb3, 0x45, 0xcf, 0x38, 0xd9, 0x4e, 0xe0, 0x24, 0xe5, 0x35,
	0xa4, 0xdd, 0x59, 0xa6, 0x9e, 0x08, 0x20, 0x17, 0xea, 0x1c, 0x40, 0x42, 0xa0, 0xb7, 0x4e, 0x27,
	0x35, 0x96, 0xa2, 0x15, 0x98, 0xf4, 0xa8, 0x13, 0xe3, 0x03, 0x67, 0x6f, 0x5f, 0xc7, 0x42, 0x8f,
	0xda, 0xf8, 0xe0, 0xce, 0xbe, 0xf5, 0x3d, 0x03, 0xe6, 0x72, 0xec, 0x9d, 0xbc, 0xbb, 0xbf, 0x00,
	0x25, 0x9f, 0xec, 0x32, 0xb5, 0x93, 0x52, 0x5b, 0x53, 0x19, 0xf0, 0xb2, 0x62, 0xc1, 0xb1, 0xc0,
	0xa3, 0xcb, 0x30, 0x1e, 0x7b, 0xed, 0x0e, 0x53, 0x3b, 0x48, 0xa3, 0x08, 0x25, 0x01, 0xba, 0xcc,
	0x03, 0x73, 0x5b, 0x9c, 0xce, 0xc8, 0xad, 0xb2, 0x01, 0x5a, 0x5b, 0xa3, 0xad, 0x5f, 0x31, 0xc0,
	0xb4, 0x09, 0x6e, 0x6d, 0x06, 0x2d, 0x72, 0x78, 0x12, 0x1d, 0x67, 0x17, 0xc8, 0x85, 0xfc, 0x02,
	0x39, 0x1d, 0x93, 0x8a, 0x8f, 0x18, 0x93, 0xac, 0xdf, 0x36, 0x60, 0x36, 0xc3, 0xc6, 0xc9, 0x75,
	0x79, 0x0e, 0x20, 0x26, 0xb8, 0xe5, 0xc8, 0xac, 0x4e, 0xb5, 0xed, 0x15, 0xeb, 0x9a, 0x39, 0x4b,
	0x32, 0x9d, 0x6a, 0x28, 0x6b, 0x3a, 0x71, 0x3f, 0x45, 0x60, 0x35, 0x60, 0xee, 0xde, 0xbe, 0xeb,
	0xde, 0x22, 0xec, 0x5a, 0x5f, 0xe4, 0xf9, 0x9c, 0xc2, 0xfc, 0xdb, 0xfa, 0x35, 0x03, 0xe6, 0xf3,
	0xb5, 0x9e, 0xf6, 0xb2, 0xfa, 0x12, 0x94, 0xc4, 0xf1, 0xf8, 0xa0, 0x7c, 0xbc, 0x55, 0x21, 0x9f,
	0x40, 0x5b, 0x5f, 0x84, 0xa5, 0x84, 0x0f, 0x95, 0x28, 0x71, 0xba, 0xd6, 0xe7, 0xfd, 0xb7, 0x3e,
	0xdc, 0xc4, 0x69, 0x8b, 0xab, 0x54, 0x5c, 0x4c, 0x97, 0x38, 0x5a, 0x01, 0xa5, 0xa3, 0x15, 0xf0,
	0x35, 0x80, 0xf2, 0x46, 0x3a, 0xec, 0x2b, 0x6e, 0xbc, 0x96, 0x60, 0xa5, 0x64, 0x57, 0x24, 0x60,
	0xb3, 0x85, 0xde, 0x48, 0x59, 0x8d, 0x42, 0xb7, 0xa3, 0x7a, 0xe9, 0x5c, 0xbe, 0x43, 0xdd, 0xe0,
	0xa8, 0x84, 0x5f, 0xfe, 0x81, 0x2e, 0x40, 0x29, 0x22, 0x44, 0xa7, 0xe7, 0x4f, 0x69, 0xfa, 0x6d,
	0x42, 0x62, 0x5b, 0x60, 0xc4, 0x92, 0x92, 0xc4, 0x5d, 0xb5, 0x04, 0x17, 0xff, 0xd1, 0x15, 0xa8,
	0x44, 0xb1, 0x17, 0xc6, 0x1e, 0xeb, 0x8b, 0x39, 0x55, 0x6d, 0x7d, 0x2e, 0xa3, 0xfd, 0x6e, 0x17,
	0x07, 0xad, 0xed, 0xd8, 0xb3, 0x13, 0x22, 0xf4, 0x16, 0xcc, 0x78, 0x34, 0xf4, 0x71, 0x26, 0x0f,
	0xbb, 0x3c, 0x90, 0x87, 0xbd, 0xa9, 0xf1, 0x2a, 0x0f, 0xdb, 0xcb, 0x7d, 0xa3, 0x8f, 0x40, 0x4d,
	0x6c, 0xb9, 0x78, 0xbe, 0xef, 0xb8, 0xd8, 0xed, 0x10, 0x95, 0x95, 0x32, 0x15, 0x84, 0xec, 0xa6,
	0xe7, 0xfb, 0x1b, 0x1c, 0x26, 0x2c, 0xdd, 0x0f, 0x5c, 0xc7, 0x0f, 0xdb, 0x2a, 0x01, 0xa5, 0xcc,
	0xbf, 0xef, 0x86, 0x6d, 0x74, 0x19, 0xcc, 0x98, 0xb8, 0x61, 0xdc, 0x12, 0x49, 0xa7, 0x0e, 0x65,
	0x98, 0xa9, 0xc4, 0xd1, 0x9a, 0x84, 0x37, 0xbd, 0x2e, 0x69, 0x30, 0xcc, 0x32, 0x94, 0xd4, 0xc5,
	0x81, 0xa4, 0xac, 0x66, 0x29, 0xf9, 0x20, 0x22, 0x28, 0x2f, 0x72, 0xad, 0x47, 0xbe, 0xe7, 0x62,
	0x87, 0xf7, 0x5e, 0x95, 0x3d, 0x5a, 0x55, 0x30, 0x1e, 0x2a, 0xd0, 0x25, 0xa8, 0xc9, 0xbc, 0x19,
	0xd2, 0x72, 0xe4, 0x90, 0x32, 0x2d, 0xd6, 0xe6, 0xd3, 0x1a, 0x2a, 0x12, 0x25, 0xd0, 0xa7, 0x60,
	0x99, 0x0f, 0x76, 0xe4, 0x90, 0xb8, 0x3d, 0xa1, 0xa4, 0x56, 0x2f, 0x96, 0xda, 0xea, 0xea, 0xc4,
	0xf6, 0xc5, 0x2e, 0x3e, 0xbc, 0xa1, 0xf1, 0xd7, 0x15, 0xfa, 0x9e, 0x48, 0xd0, 0xc0, 0x51, 0xe4,
	0x7b, 0x44, 0xc7, 0x93, 0x19, 0x79, 0x7e, 0xa1, 0x80, 0x32, 0xa4, 0x2c, 0x41, 0x99, 0x61, 0xba,
	0xc7, 0x5d, 0xc7, 0x94, 0xf9, 0x49, 0xfc, 0x73, 0xb3, 0x25, 0x06, 0x17, 0x86, 0x7d, 0x22, 0x05,
	0x98, 0x95, 0x89, 0x9f, 0x02, 0x22, 0xd8, 0xff, 0x18, 0xa0, 0xe4, 0x1e, 0x52, 0x3b, 0x0e, 0x7b,
	0x91, 0xc3, 0x70, 0xbb, 0x8e, 0x84, 0x23, 0x9b, 0x1a, 0x73, 0x8b, 0x23, 0x9a, 0xb8, 0x8d, 0x3e,
	0x09, 0xd3, 0x2d, 0x8f, 0xee, 0x39, 0xbb, 0x3d, 0xdf, 0x77, 0xc2, 0x88, 0xd5, 0xe7, 0x84, 0x91,
	0xe7, 0x13, 0x23, 0x5f, 0xf7, 0xe8, 0xde, 0xcd, 0x9e, 0xef, 0x6f, 0x45, 0xcc, 0xae, 0xb6, 0xd2,
	0x0f, 0xae, 0x73, 0x3e, 0x88, 0x11, 0x16, 0xf7, 0x9d, 0x58, 0x76, 0xf1, 0xfa, 0xbc, 0xd4, 0xb9,
	0x47, 0x6d, 0x0e, 0xd6, 0x1d, 0xff, 0x35, 0xa8, 0xe2, 0xc8, 0x4b, 0x8e, 0x61, 0x16, 0x06, 0xdc,
	0xef, 0xea, 0xf6, 0xa6, 0xde, 0xc7, 0x04, 0x1c, 0x79, 0x69, 0xf6, 0xce, 0x8c, 0xdc, 0xf5, 0x64,
	0x89, 0x1d, 0x16, 0x85, 0x1d, 0x6a, 0x09, 0x58, 0x1a, 0xe2, 0xd3, 0x20, 0xef, 0x61, 0x39, 0x3a,
	0xba, 0x2c, 0x89, 0x9e, 0xb1, 0xb0, 0xa6, 0x6f, 0x67, 0x35, 0xf9, 0xaf, 0x0e, 0x31, 0x53, 0x2c,
	0xf3, 0x25, 0x6d, 0x2d, 0xb8, 0x74, 0xa4, 0x62, 0xea, 0x75, 0x11, 0x05, 0xa6, 0x15, 0xb4, 0x21,
	0x80, 0x5c, 0xe5, 0xe2, 0x16, 0x86, 0x24, 0x59, 0x96, 0xd1, 0x9f, 0x1d, 0x06, 0x0a, 0xbd, 0x0a,
	0xb3, 0x3b, 0x3d, 0xda, 0x77, 0x58, 0x27, 0x26, 0xb4, 0x13, 0xfa, 0x2d, 0xee, 0x02, 0x67, 0xc4,
	0x7c, 0x66, 0x86, 0x23, 0x9a, 0x1a, 0x7e, 0x8f, 0xa2, 0xf7, 0xa0, 0x9e, 0x98, 0x87, 0x33, 0x1c,
	0x87, 0x7e, 0xc2, 0xf8, 0x59, 0xc1, 0xf8, 0xf9, 0x44, 0x33, 0xb6, 0x22, 0xdc, 0x90, 0x74, 0x5a,
	0x84, 0xe4, 0x9e, 0x59, 0x1e, 0x8e, 0xce, 0x43, 0x95, 0xcf, 0x37, 0x22, 0xae, 0x0b, 0xaf, 0x55,
	0xbf, 0x20, 0x6f, 0x11, 0x69, 0xd0, 0x66, 0x8b, 0xab, 0x74, 0xa7, 0xe7, 0xee, 0x11, 0x46, 0x13,
	0x63, 0x5c, 0x14, 0xb2, 0xd4, 0x14, 0x58, 0xeb, 0xfe, 0x35, 0xa8, 0x2a, 0x16, 0x29, 0xeb, 0xb2,
	0xba, 0xa5, 0x42, 0x93, 0xe6, 0x4b, 0x8a, 0xdd, 0x60, 0x5d, 0x66, 0x03, 0x4d, 0xfe, 0xbf, 0x5d,
	0xaa, 0x94, 0xcc, 0xf1, 0xb7, 0x4b, 0x95, 0x15, 0xf3, 0x0c, 0xef, 0x51, 0xb8, 0xe5, 0xbc, 0xdf,
	0x0b, 0xe3, 0x5e, 0xd7, 0xfa, 0x43, 0x03, 0x16, 0x47, 0xcb, 0x82, 0xd6, 0x60, 0x6e, 0xc0, 0x5b,
	0x03, 0xdc, 0x25, 0x6a, 0x6a, 0x37, 0x9b, 0x73, 0xd7, 0xfb, 0xb8, 0x4b, 0xd0, 0x27, 0xa0, 0x1c,
	0x91, 0x00, 0xfb, 0xac, 0xaf, 0x02, 0xe6, 0xb9, 0xb5, 0xa1, 0x5b, 0x77, 0x1b, 0x61, 0x40, 0x7b,
	0xdd, 0x48, 0xe4, 0x8a, 0x68, 0x6a, 0xf4, 0x12, 0xcc, 0x86, 0xfb, 0x24, 0x8e, 0xbd, 0x16, 0x71,
	0x92, 0x48, 0x28, 0x4f, 0x04, 0x4d, 0x8d, 0xd8, 0x56, 0x70, 0xeb, 0xd7, 0x0d, 0x80, 0x54, 0xc8,
	0xdc, 0x68, 0x64, 0xe4, 0xe7, 0x22, 0xcf, 0xc3, 0xb4, 0x1b, 0x06, 0x01, 0x11, 0x89, 0x64, 0x5c,
	0xeb, 0xea, 0x28, 0x32, 0x05, 0x6e, 0xb6, 0x78, 0x57, 0xe6, 0x7a, 0xe4, 0x68, 0x95, 0x6a, 0xc8,
	0x3f, 0x37, 0x5b, 0xe2, 0x20, 0x93, 0x50, 0xae, 0x72, 0x07, 0xfb, 0x9e, 0xda, 0x4b, 0x9a, 0xb4,
	0xa7, 0x14, 0xf0, 0x2a, 0x87, 0x59, 0xdf, 0x2a, 0x42, 0x45, 0xcf, 0x22, 0x86, 0x92, 0x4b, 0x8d,
	0xe1, 0xe4, 0xd2, 0x8b, 0x30, 0x25, 0xb2, 0xd9, 0xf2, 0xe7, 0x15, 0x55, 0x0e, 0xd3, 0xf6, 0x1d,
	0x1e, 0xdd, 0xb2, 0xd9, 0x76, 0xa5, 0x7c, 0xb6, 0x5d, 0xf6, 0x0a, 0xd2, 0x78, 0xfe, 0x0a, 0xd2,
	0x65, 0x95, 0x38, 0x27, 0x12, 0xdb, 0xe5, 0xb0, 0x52, 0x4d, 0xbc, 0x64, 0x2b, 0x92, 0x29, 0x73,
	0xcd, 0x7e, 0x44, 0xd0, 0x4b, 0x80, 0x04, 0x65, 0x3e, 0xa7, 0xb8, 0x2c, 0xaa, 0x9b, 0xe1, 0x98,
	0xcc, 0x95, 0x97, 0x91, 0x37, 0x92, 0x2a, 0x23, 0x6f, 0x24, 0x0d, 0xdd, 0x19, 0x98, 0x1c, 0xbe,
	0x33, 0x30, 0x70, 0x6b, 0x09, 0x86, 0x6f, 0x2d, 0x7d, 0x1a, 0x56, 0x92, 0xe0, 0xcd, 0x42, 0xc7,
	0xc7, 0x94, 0x69, 0x26, 0xbb, 0xfa, 0x1a, 0xc2, 0xa2, 0xa6, 0x68, 0x86, 0x77, 0x31, 0x65, 0x92,
	0xd7, 0x7b, 0xd4, 0xfa, 0x87, 0x12, 0x54, 0xf4, 0xd1, 0x64, 0x66, 0x1a, 0x68, 0x3c, 0x62, 0x1a,
	0x88, 0xce, 0xf2, 0xb9, 0x01, 0x8b, 0xfb, 0x78, 0xc7, 0x27, 0x6a, 0xea, 0x91, 0x02, 0xf8, 0xa4,
	0x04, 0xef, 0x84, 0x31, 0x53, 0x3b, 0x8e, 0xf2, 0x03, 0xad, 0x43, 0x45, 0xe7, 0xf1, 0x0f, 0x9d,
	0xb9, 0xbf, 0x1b, 0x7b, 0x8c, 0xe8, 0x44, 0x7e, 0x3b, 0xa1, 0xe3, 0xd1, 0x11, 0xfb, 0xbc, 0x33,
	0xf6, 0x55, 0xfa, 0xe9, 0xb8, 0x8a, 0x8e, 0x49, 0xf8, 0x95, 0x58, 0x91, 0x81, 0x6a, 0x4f, 0xe1,
	0xcc, 0x17, 0x7a, 0x19, 0x2a, 0xfa, 0xc6, 0xeb, 0x50, 0x5a, 0xe4, 0x75, 0x85, 0xb0, 0x13, 0x12,
	0x74, 0x1d, 0x66, 0x13, 0x43, 0x38, 0xe4, 0x30, 0xf2, 0x62, 0xd2, 0x52, 0x89, 0x91, 0xf5, 0xdc,
	0x64, 0x83, 0x9b, 0xe5, 0x86, 0xc4, 0xdb, 0x33, 0x6e, 0x1e, 0xc0, 0x47, 0x24, 0xee, 0x6e, 0xe9,
	0x69, 0x4d, 0x45, 0xd4, 0x30, 0x9f, 0x3d, 0x94, 0xbf, 0xaf, 0x4e, 0x6e, 0xec, 0x2a, 0x4b, 0x3f,
	0xd0, 0x6d, 0x98, 0x4b, 0xdb, 0x67, 0x21, 0x37, 0x64, 0xdc, 0x96, 0xb7, 0x51, 0xaa, 0xeb, 0xcb,
	0x43, 0x1c, 0x34, 0xc3, 0xf0, 0x2e, 0x27, 0xb0, 0x4d, 0x77, 0x00, 0x82, 0x36, 0xc0, 0x4c, 0x2f,
	0xa1, 0xed, 0x62, 0xcf, 0x27, 0x2d, 0x31, 0xf3, 0xc8, 0x0a, 0x92, 0xdc, 0x42, 0xbb, 0x29, 0xf0,
	0x76, 0x7a, 0x6d, 0x4d, 0x02, 0x78, 0x25, 0xba, 0xab, 0x76, 0x3d, 0xda, 0xc5, 0xcc, 0xed, 0x08,
	0x5f, 0xca, 0x56, 0xa2, 0x72, 0x6c, 0xef, 0x29, 0xbc, 0x3d, 0x13, 0xe5, 0x01, 0xd6, 0xdf, 0x15,
	0x60, 0x3a, 0x67, 0xda, 0xa3, 0x82, 0xd1, 0x79, 0xa8, 0x66, 0xef, 0x79, 0xa8, 0x0c, 0x15, 0x37,
	0xbd, 0xdd, 0x31, 0xdc, 0xef, 0xeb, 0x50, 0xd6, 0xe9, 0xbf, 0xf2, 0x80, 0x52, 0x7f, 0xf2, 0x79,
	0x44, 0x52, 0x59, 0xda, 0xbf, 0x64, 0x00, 0x30, 0x35, 0x26, 0xe9, 0x64, 0xaf, 0xc3, 0x44, 0x4c,
	0x30, 0x0d, 0x03, 0x15, 0x06, 0xce, 0x8d, 0x76, 0xcc, 0x35, 0x5b, 0x10, 0xd9, 0x8a, 0xd8, 0x3a,
	0x80, 0x09, 0x09, 0x41, 0x55, 0x28, 0xbf, 0x13, 0xec, 0x05, 0xe1, 0x41, 0x60, 0x8e, 0xa1, 0x1a,
	0xc0, 0x56, 0xc4, 0x54, 0xc2, 0xb2, 0x69, 0xa0, 0x79, 0x30, 0xb3, 0x77, 0x0a, 0x78, 0x37, 0x31,
	0x0b, 0x08, 0x41, 0xad, 0x41, 0xfc, 0x5d, 0x3b, 0xf4, 0x7d, 0xd2, 0xba, 0x86, 0xdd, 0x3d, 0xb3,
	0x88, 0xa6, 0x61, 0xd2, 0x76, 0x65, 0xb6, 0x32, 0x35, 0x4b, 0x68, 0x09, 0xe6, 0xee, 0xe2, 0x2f,
	0xf5, 0xdf, 0x09, 0xbc, 0xf7, 0x7b, 0x24, 0x20, 0x94, 0x0a, 0x94, 0x39, 0x6e, 0x5d, 0x80, 0xa9,
	0xac, 0xe3, 0x6b, 0xcd, 0x18, 0xe9, 0x92, 0xea, 0xf7, 0x0c, 0xa8, 0x68, 0x27, 0xcf, 0x26, 0x8b,
	0x1b, 0xb9, 0x64, 0x71, 0x1d, 0x37, 0xd3, 0xf5, 0x98, 0x20, 0xbc, 0x43, 0xfa, 0x7c, 0x56, 0xa0,
	0xbb, 0x06, 0x47, 0x3b, 0x1d, 0x4c, 0x3b, 0x2a, 0xfe, 0xcf, 0x68, 0xc4, 0x1d, 0xd2, 0xbf, 0x8d,
	0x69, 0x07, 0xbd, 0x0e, 0x20, 0x6e, 0x57, 0xb9, 0x1d, 0xec, 0x05, 0x6a, 0x6d, 0xbd, 0xb8, 0x96,
	0x5c, 0x37, 0x7f, 0x17, 0x7b, 0xec, 0x66, 0x18, 0xdf, 0x08, 0xf8, 0xac, 0x6a, 0x92, 0x53, 0x6e,
	0x70, 0x42, 0xeb, 0xeb, 0x06, 0xcc, 0x0c, 0x74, 0xa8, 0xa3, 0xfc, 0x63, 0x0d, 0xe6, 0x30, 0x63,
	0xa4, 0x1b, 0xf1, 0x29, 0x55, 0x6a, 0x53, 0xe9, 0x27, 0xb3, 0x09, 0x2a, 0x31, 0xea, 0xb0, 0xbb,
	0x0c, 0xc5, 0xdb, 0xd2, 0x50, 0xbc, 0xb5, 0x36, 0xa1, 0x9a, 0xe9, 0xa2, 0x8f, 0xf0, 0xd7, 0x23,
	0x73, 0xf4, 0xad, 0x2b, 0x60, 0x0e, 0xf6, 0xd6, 0xfc, 0xf1, 0xb8, 0x31, 0x70, 0x3c, 0xfe, 0xd7,
	0x06, 0xcc, 0x0c, 0x74, 0xcc, 0xa3, 0x18, 0x18, 0x3e, 0xc8, 0xfa, 0x38, 0x4c, 0x26, 0xfd, 0x58,
	0x08, 0x5e, 0x5b, 0x47, 0xc3, 0x5d, 0xde, 0x4e, 0x89, 0xb8, 0x99, 0x45, 0x60, 0xf5, 0x82, 0xf6,
	0xe0, 0x85, 0x81, 0x19, 0x8d, 0xd0, 0x57, 0x06, 0x3e, 0x06, 0x28, 0xa1, 0x1d, 0xea, 0x53, 0x1a,
	0x93, 0x28, 0xf2, 0x2a, 0xcc, 0x0c, 0xc4, 0x87, 0x7c, 0xa6, 0xba, 0xf1, 0xc8, 0x4c, 0x75, 0xeb,
	0x6f, 0x0c, 0x00, 0xbe, 0x4a, 0x92, 0x89, 0x3f, 0xe8, 0xa3, 0x30, 0x2b, 0xdc, 0xec, 0x00, 0xfb,
	0xbe, 0x5c, 0x54, 0x75, 0xb5, 0x4e, 0x6a, 0x1c, 0xf1, 0x2e, 0xf6, 0x7d, 0x4e, 0x7e, 0x8f, 0xa2,
	0x2b, 0x30, 0x1f, 0xc5, 0xa1, 0x4b, 0x28, 0xcd, 0x53, 0x2b, 0x67, 0x51, 0xb8, 0x4c, 0x81, 0x35,
	0x98, 0xdf, 0xdb, 0x17, 0x6b, 0x92, 0x7c, 0x01, 0x35, 0xc7, 0xda, 0xdb, 0xe7, 0xab, 0x93, 0x0c,
	0xfd, 0x3a, 0x2c, 0xb2, 0x90, 0x61, 0xdf, 0x89, 0x23, 0x37, 0x53, 0x22, 0xd0, 0xca, 0x43, 0x02,
	0x6b, 0x47, 0xae, 0x2e, 0x73, 0x9f, 0x5a, 0x5f, 0x2d, 0xc0, 0x54, 0x2a, 0xce, 0x83, 0xf5, 0x11,
	0x02, 0x05, 0x23, 0x05, 0xba, 0xff, 0x10, 0x81, 0x82, 0x87, 0x09, 0x74, 0x9f, 0xa2, 0x37, 0xe1,
	0xac, 0x2e, 0x40, 0x7b, 0x34, 0x22, 0x41, 0x2b, 0x5f, 0x50, 0x0a, 0x56, 0x57, 0x34, 0x0d, 0x49,
	0x92, 0x29, 0x3f, 0x52, 0x21, 0x89, 0x78, 0x03, 0x0a, 0xb9, 0x7f, 0x94, 0x42, 0xc6, 0x1f, 0xaa,
	0x90, 0xcf, 0x43, 0x85, 0x2f, 0x6d, 0xc5, 0xd4, 0x70, 0x1e, 0xc6, 0x05, 0x85, 0x90, 0xbf, 0x68,
	0xcb, 0x0f, 0x3e, 0xcf, 0x50, 0x1c, 0x12, 0x39, 0x39, 0x2d, 0xda, 0x29, 0x20, 0xd9, 0xd6, 0xda,
	0xe9, 0x33, 0x22, 0x25, 0x2a, 0xca, 0x6d, 0xad, 0x6b, 0x1c, 0x60, 0xfd, 0x32, 0x9f, 0x07, 0xbb,
	0x38, 0x50, 0xee, 0xf3, 0x22, 0x8c, 0x8b, 0x2b, 0xc2, 0x43, 0x9e, 0xa7, 0x79, 0xb0, 0x25, 0x1e,
	0x5d, 0x82, 0x52, 0x72, 0xf5, 0x69, 0x24, 0x9d, 0x40, 0x73, 0xb2, 0x16, 0x66, 0x78, 0x68, 0x4f,
	0x29, 0x25, 0xe3, 0x68, 0xeb, 0xdf, 0xc7, 0xe5, 0xe3, 0x07, 0x89, 0xd5, 0x5f, 0x06, 0x94, 0x88,
	0xa0, 0xa7, 0xb9, 0xda, 0xec, 0xb3, 0x09, 0x46, 0x4d, 0x76, 0x45, 0x92, 0xb8, 0x54, 0x6c, 0x42,
	0xaa, 0x92, 0xc4, 0x05, 0x34, 0x21, 0xfb, 0x1c, 0x9c, 0x8d, 0xf9, 0x82, 0xb2, 0xb5, 0xe3, 0xb4,
	0xc4, 0xb1, 0x9c, 0x43, 0xf7, 0xbc, 0x28, 0x12, 0xa1, 0xb2, 0x17, 0x30, 0x65, 0xef, 0x65, 0x45,
	0x23, 0x4f, 0xee, 0x1a, 0x92, 0x62, 0x83, 0x13, 0xa0, 0x4f, 0x81, 0x46, 0x8a, 0x78, 0x9f, 0x2f,
	0x2d, 0xad, 0xbe, 0xa8, 0x08, 0xee, 0x90, 0x7e, 0xae, 0xe8, 0x5b, 0x70, 0x4e, 0x17, 0xdd, 0x11,
	0x1d, 0x5c, 0x6c, 0x98, 0x38, 0x1d, 0x3e, 0x24, 0x88, 0xe2, 0xe3, 0xb9, 0xc6, 0xaf, 0x71, 0x1a,
	0xb1, 0x7f, 0x72, 0xdb, 0x63, 0xb2, 0x86, 0x4f, 0x40, 0x3d, 0x5f, 0x83, 0xb0, 0xab, 0x2c, 0x2c,
	0x93, 0x88, 0x16, 0xb2, 0x85, 0xb9, 0xef, 0xc9, 0x82, 0xaf, 0xc3, 0xd2, 0x88, 0x82, 0xdc, 0x21,
	0xd4, 0xf4, 0x7c, 0x7e, 0xb0, 0x1c, 0xf7, 0x0d, 0xf4, 0x06, 0x2c, 0x0d, 0xdb, 0x20, 0xfb, 0x4e,
	0xc1, 0xc2, 0x90, 0x21, 0xc4, 0x92, 0x61, 0x34, 0x9f, 0x01, 0x0e, 0x42, 0x3d, 0x79, 0x1f, 0xe2,
	0xf3, 0x3e, 0x47, 0xf2, 0xd8, 0xd9, 0x26, 0xcc, 0xa1, 0x01, 0x8e, 0x68, 0x27, 0x64, 0xaa, 0x88,
	0x7c, 0xcf, 0xc0, 0x6c, 0x13, 0xd6, 0x50, 0x08, 0x49, 0xcd, 0x15, 0x9a, 0xec, 0xd7, 0x3a, 0x51,
	0x1c, 0x46, 0x21, 0x25, 0x8e, 0x88, 0x15, 0xb2, 0x60, 0x55, 0x29, 0x54, 0x6f, 0xe1, 0x6e, 0x4b,
	0x12, 0x3e, 0xd2, 0x8e, 0xaa, 0x81, 0x4f, 0x78, 0xbc, 0xb8, 0x9b, 0xad, 0x61, 0x6a, 0xa0, 0x86,
	0x0d, 0x49, 0x32, 0x5c, 0x43, 0x14, 0x86, 0xbe, 0x43, 0xdd, 0x0e, 0x69, 0xf5, 0xfc, 0x1c, 0x0f,
	0xd3, 0x69, 0x0d, 0xdb, 0x61, 0xe8, 0x37, 0x14, 0x49, 0x52, 0x83, 0xf5, 0xab, 0x06, 0x54, 0x33,
	0x69, 0x9c, 0x7c, 0x5d, 0x2e, 0x62, 0x82, 0xcc, 0xfa, 0x54, 0xdd, 0x30, 0x5d, 0x97, 0xa7, 0xa1,
	0xd1, 0x06, 0x96, 0x46, 0x7d, 0xbe, 0x9a, 0x77, 0x71, 0xa0, 0x4b, 0x15, 0x06, 0x57, 0xf3, 0x49,
	0xd7, 0xb2, 0x81, 0x26, 0xff, 0x65, 0x9e, 0xb9, 0x5c, 0xd3, 0x5b, 0xff, 0x61, 0xc0, 0x74, 0x2e,
	0x9d, 0xf4, 0x84, 0x9c, 0x7c, 0x06, 0x6a, 0x19, 0x4e, 0x9c, 0xfd, 0x75, 0xc5, 0xcc, 0xc2, 0x08,
	0x66, 0x1e, 0xac, 0xdb, 0x53, 0x34, 0xdb, 0xeb, 0x3f, 0x01, 0x53, 0x22, 0xba, 0xe8, 0x36, 0x8b,
	0x03, 0xeb, 0x02, 0x31, 0xd1, 0x54, 0x8d, 0x56, 0x0f, 0xd2, 0x0f, 0xde, 0x6a, 0x86, 0xd7, 0x34,
	0x61, 0x79, 0x61, 0x04, 0xbb, 0xbc, 0x55, 0x96, 0xf9, 0xb2, 0xbe, 0x5c, 0x86, 0x6a, 0xa6, 0x66,
	0xf4, 0x2a, 0x2c, 0x52, 0x16, 0xc6, 0xc4, 0xd9, 0xe1, 0x03, 0x72, 0xd6, 0x9a, 0x32, 0xfe, 0xcc,
	0x09, 0xac, 0x38, 0xa1, 0x4e, 0x3d, 0xe1, 0x75, 0xd1, 0x59, 0x84, 0x0b, 0x52, 0x39, 0x8e, 0x24,
	0xa5, 0x64, 0x28, 0x9a, 0x57, 0xe8, 0x86, 0x18, 0x42, 0x74, 0xb1, 0x55, 0x98, 0x8d, 0x78, 0xdf,
	0x11, 0xd7, 0xf2, 0xdb, 0xaa, 0x80, 0x9a, 0x41, 0x2a, 0xc4, 0xdd, 0xb0, 0x2d, 0x69, 0x37, 0xe0,
	0x7c, 0x8c, 0x77, 0x99, 0xd3, 0xda, 0x71, 0xa4, 0x96, 0x7c, 0x82, 0x5b, 0x24, 0xce, 0x36, 0x25,
	0x43, 0xd0, 0x0a, 0x27, 0xbb, 0xbe, 0x23, 0x64, 0xba, 0x2b, 0x68, 0xd2, 0x06, 0xd7, 0x61, 0x51,
	0x57, 0xa2, 0x37, 0x65, 0x55, 0x59, 0x35, 0x04, 0xc9, 0xb2, 0x0d, 0xb9, 0x41, 0x2b, 0xcb, 0xbc,
	0x09, 0x67, 0xf3, 0x0d, 0x77, 0x49, 0x97, 0xf1, 0x45, 0xac, 0x2a, 0x29, 0x83, 0x4f, 0x3d, 0xd3,
	0xea, 0x3d, 0x45, 0x20, 0xcb, 0x5f, 0x06, 0xb5, 0xfe, 0xca, 0xb4, 0x26, 0x03, 0x8f, 0xda, 0xe8,
	0x4b, 0x5a, 0x7a, 0x15, 0x16, 0x71, 0x14, 0xf9, 0xfd, 0x61, 0xd5, 0xcb, 0x88, 0x33, 0x27, 0xb0,
	0x03, 0xaa, 0x7f, 0x01, 0x66, 0x64, 0xa1, 0xb4, 0xf6, 0x49, 0x75, 0x8b, 0x96, 0x83, 0x87, 0x2b,
	0xef, 0xf6, 0x18, 0x39, 0x94, 0x57, 0x6e, 0xb3, 0x21, 0x46, 0x56, 0x7e, 0x8f, 0x23, 0xf9, 0x3c,
	0x2b, 0xe9, 0xe1, 0xb2, 0xd0, 0xc3, 0x54, 0xae, 0xa2, 0x8c, 0x20, 0x1a, 0xa9, 0xf1, 0x57, 0x60,
	0x21, 0x5b, 0xc3, 0x01, 0xf6, 0x73, 0xd1, 0x05, 0xa5, 0x25, 0xdf, 0xc5, 0xbe, 0x2c, 0xf2, 0x19,
	0x58, 0xc9, 0x16, 0x19, 0x50, 0xb7, 0x8c, 0x29, 0x4b, 0x69, 0xb9, 0x21, 0x6d, 0xfb, 0x83, 0xda,
	0x93, 0x9b, 0xd5, 0x35, 0x3f, 0xaf, 0xb8, 0xe7, 0x61, 0x5a, 0x4f, 0x7f, 0x24, 0x99, 0xda, 0xa4,
	0x56, 0x40, 0x49, 0xc4, 0x87, 0xd6, 0x4e, 0x1c, 0x32, 0x96, 0xb4, 0x6f, 0xaa, 0xa1, 0x55, 0x41,
	0x25, 0xd9, 0xff, 0x81, 0x33, 0x83, 0x57, 0x54, 0xb3, 0x0c, 0xcc, 0xaa, 0x99, 0xd4, 0xe0, 0x23,
	0x0b, 0x3a, 0x0c, 0xbe, 0x07, 0x13, 0x32, 0x2d, 0x23, 0xcd, 0x0e, 0x37, 0x1e, 0x91, 0x1f, 0x7f,
	0xcc, 0xec, 0x45, 0xeb, 0xcb, 0x06, 0x54, 0xf4, 0xc5, 0x32, 0x74, 0x06, 0x0a, 0x61, 0xa4, 0x1e,
	0x68, 0xc8, 0xed, 0x63, 0x15, 0xc2, 0xe8, 0xd8, 0xf9, 0x90, 0xb9, 0x15, 0x44, 0xe9, 0x18, 0x2b,
	0x08, 0xeb, 0x47, 0x05, 0x98, 0xbc, 0xb7, 0xef, 0xba, 0xc2, 0x5c, 0xe8, 0x7c, 0xee, 0x9d, 0x88,
	0x1c, 0x1b, 0xf2, 0x35, 0x88, 0x23, 0x4e, 0x46, 0xcf, 0x0c, 0xbd, 0x89, 0x90, 0xb9, 0x2f, 0x79,
	0x1e, 0xaa, 0xb4, 0x13, 0xc6, 0xcc, 0xc9, 0xbc, 0x8a, 0x60, 0x83, 0x00, 0x89, 0x17, 0x38, 0xf8,
	0x90, 0xde, 0xc1, 0xd4, 0x09, 0xf7, 0x49, 0xec, 0x63, 0x31, 0x75, 0xd1, 0x77, 0x94, 0x55, 0xce,
	0xe2, 0x42, 0x07, 0xd3, 0xad, 0x04, 0xab, 0x2f, 0xff, 0xa0, 0x0b, 0x30, 0xc5, 0xcb, 0xb5, 0x5d,
	0x67, 0x57, 0xbc, 0x45, 0x21, 0x73, 0x76, 0xa0, 0x83, 0xe9, 0x2d, 0xf7, 0xa6, 0x78, 0x8c, 0x62,
	0x19, 0x2a, 0x09, 0x56, 0xf6, 0xed, 0x72, 0x5b, 0xa1, 0x3e, 0x02, 0x35, 0xb1, 0xdf, 0xe6, 0x76,
	0x70, 0xd0, 0x16, 0x9b, 0x82, 0xb2, 0x33, 0x4f, 0x71, 0xe8, 0x86, 0x00, 0x8a, 0xed, 0x85, 0xa5,
	0x64, 0x8e, 0xa1, 0x77, 0xe8, 0x64, 0x09, 0xd5, 0x9b, 0xe7, 0x35, 0x5a, 0x6e, 0xcf, 0xc9, 0x82,
	0xd6, 0x67, 0xa5, 0x62, 0xa5, 0x78, 0x47, 0xac, 0x03, 0x47, 0x3e, 0xb0, 0x61, 0x7d, 0xbb, 0x08,
	0x15, 0x5e, 0x5c, 0xec, 0xaa, 0x3e, 0x89, 0x59, 0x32, 0x9b, 0x2c, 0xc5, 0xfc, 0x26, 0xcb, 0x23,
	0x6d, 0x32, 0x9c, 0x4d, 0x7b, 0x9c, 0x07, 0x5d, 0xb2, 0x5b, 0xb6, 0xe5, 0xc1, 0x2d, 0xdb, 0xe3,
	0xee, 0xad, 0x0e, 0xec, 0x9b, 0x4e, 0x0e, 0xef, 0x9b, 0x9e, 0x87, 0x6a, 0x72, 0xc5, 0x9d, 0xc9,
	0x9d, 0xd5, 0x92, 0x0d, 0x1a, 0xd4, 0xa4, 0x23, 0x8c, 0x5b, 0x7d, 0x3c, 0xe3, 0x4e, 0x1d, 0x61,
	0xdc, 0xaf, 0x18, 0xd2, 0x3c, 0x62, 0xf1, 0xa3, 0x57, 0x1c, 0xc6, 0x88, 0xd3, 0x59, 0x91, 0x3d,
	0x22, 0x57, 0x1c, 0xab, 0x30, 0x21, 0xa2, 0xa6, 0x4e, 0x13, 0x41, 0x39, 0x42, 0xd1, 0x01, 0x6d,
	0x45, 0xc1, 0x69, 0xd5, 0x2b, 0x21, 0xc5, 0x11, 0xb4, 0xc2, 0x3c, 0xfa, 0xe5, 0x10, 0xeb, 0x55,
	0x28, 0xab, 0xbb, 0x42, 0xc2, 0x62, 0x87, 0x81, 0xf2, 0x30, 0xfe, 0x17, 0x2d, 0xc2, 0x04, 0x15,
	0xf7, 0xe6, 0x95, 0x5f, 0xa8, 0x2f, 0xeb, 0x2d, 0xb1, 0x73, 0x2c, 0x12, 0x16, 0xf2, 0x39, 0x32,
	0xc6, 0xc3, 0x33, 0xc4, 0x0a, 0xb9, 0x0c, 0xb1, 0xbf, 0x34, 0x00, 0xe4, 0x88, 0x22, 0x9a, 0x3e,
	0xf2, 0xbc, 0x79, 0x09, 0xca, 0x11, 0x21, 0x71, 0x7a, 0x46, 0x31, 0xc1, 0x3f, 0x37, 0x5b, 0xc9,
	0x71, 0x71, 0x31, 0x73, 0x5c, 0x3c, 0x78, 0x38, 0x5d, 0x3a, 0xe6, 0xe1, 0xf4, 0x2b, 0x6a, 0x3d,
	0xc9, 0x25, 0x24, 0x6a, 0xab, 0x19, 0x65, 0xce, 0xb3, 0x70, 0xab, 0xc1, 0x31, 0x72, 0x8d, 0x29,
	0xfe, 0x5a, 0x9b, 0x30, 0x99, 0xc0, 0x87, 0x4f, 0x46, 0x8d, 0xd1, 0x27, 0xa3, 0xe2, 0x0a, 0x12,
	0x4b, 0x15, 0x8a, 0x77, 0x49, 0x93, 0x5a, 0x0d, 0x40, 0x32, 0xa5, 0x4b, 0xa8, 0x44, 0x1f, 0x3f,
	0xbe, 0x9c, 0x26, 0xad, 0xc8, 0x2b, 0xc5, 0xe9, 0x34, 0x35, 0xd5, 0x5d, 0x92, 0xb9, 0x82, 0x6a,
	0x50, 0x48, 0x2a, 0x2e, 0x30, 0x6a, 0x7d, 0x0e, 0xe6, 0x72, 0x95, 0xaa, 0x4c, 0x83, 0x7a, 0xbe,
	0xd6, 0xd2, 0xc3, 0x2b, 0xb8, 0x0e, 0xa8, 0xc1, 0xe7, 0x84, 0x0d, 0xce, 0x64, 0x43, 0x73, 0xb5,
	0x06, 0x93, 0x7c, 0x91, 0x28, 0xf2, 0x54, 0x46, 0x8d, 0x66, 0x32, 0x8f, 0xa5, 0xb2, 0xa7, 0xfe,
	0x59, 0x6b, 0x30, 0x97, 0xab, 0x45, 0xb1, 0x91, 0xd1, 0x85, 0x91, 0xd3, 0x85, 0x2b, 0x72, 0x3f,
	0x6f, 0x11, 0xee, 0x40, 0xcd, 0xe6, 0xdd, 0xa7, 0x73, 0x8f, 0xe3, 0xab, 0x86, 0xc8, 0xc7, 0xcc,
	0xb4, 0xf2, 0x14, 0xf2, 0x30, 0xd2, 0x07, 0x20, 0x44, 0xfc, 0x3b, 0xf2, 0x26, 0xc7, 0x8f, 0xe5,
	0x95, 0x87, 0x8d, 0xab, 0x8d, 0xa7, 0x79, 0xe5, 0xe1, 0x63, 0x80, 0xa2, 0x98, 0xec, 0x7b, 0x61,
	0x8f, 0x66, 0xde, 0xf5, 0x90, 0xbc, 0x98, 0x1a, 0x93, 0xbc, 0xea, 0x71, 0x09, 0x6a, 0x09, 0xb5,
	0xac, 0x4c, 0x5e, 0xf5, 0x9c, 0xd6, 0xd0, 0x07, 0x99, 0x7b, 0x14, 0x13, 0x83, 0xf7, 0x28, 0xca,
	0x89, 0xe4, 0xd6, 0x07, 0x32, 0xef, 0x5b, 0x08, 0x77, 0xda, 0x7a, 0xae, 0x43, 0x99, 0xf6, 0x5c,
	0x97, 0xa8, 0x0c, 0xa6, 0x8a, 0xad, 0x3f, 0x9f, 0x8a, 0xb0, 0xd6, 0x75, 0x58, 0xbc, 0x45, 0x98,
	0x9e, 0xe5, 0x89, 0x0e, 0xf8, 0xf8, 0xf6, 0xb2, 0xbe, 0x61, 0xc0, 0xd2, 0x50, 0x35, 0xa7, 0xad,
	0x99, 0x8f, 0xf3, 0xe0, 0xcb, 0xc4, 0x10, 0x58, 0x3c, 0x72, 0x5f, 0x5e, 0x93, 0x59, 0xb7, 0x60,
	0x39, 0xc3, 0xd5, 0x6d, 0x8f, 0xaf, 0x08, 0x4f, 0x92, 0xe7, 0x65, 0x7d, 0xd3, 0x80, 0x95, 0x51,
	0x35, 0xfd, 0xec, 0x45, 0xfc, 0x2b, 0x99, 0x49, 0xbf, 0x11, 0xaa, 0xd5, 0x40, 0x18, 0x9f, 0x30,
	0x2d, 0xda, 0x0d, 0xa3, 0x58, 0x1e, 0xf9, 0x4b, 0x8e, 0x2a, 0x1c, 0x20, 0x4e, 0xfa, 0xc5, 0xba,
	0x30, 0x8a, 0xf5, 0xde, 0x92, 0x13, 0x93, 0xf7, 0x55, 0xe4, 0xa9, 0x71, 0x78, 0x7a, 0x97, 0x2f,
	0x93, 0x0f, 0x58, 0x7a, 0x54, 0x8e, 0x3a, 0x52, 0x3b, 0x8e, 0xd2, 0x29, 0xe5, 0xf6, 0x62, 0x4f,
	0x64, 0xe2, 0xe7, 0x44, 0x39, 0x6d, 0x05, 0xa3, 0xcc, 0x46, 0xa7, 0x6e, 0xf6, 0x3b, 0xf2, 0x86,
	0x92, 0x18, 0x5b, 0x68, 0xaf, 0x7b, 0x12, 0xfd, 0x7d, 0x12, 0x26, 0xb1, 0xdf, 0x0e, 0x63, 0x8f,
	0x75, 0xba, 0xa2, 0xc1, 0xda, 0xfa, 0x4a, 0x4a, 0xad, 0x2a, 0xbe, 0xaa, 0x29, 0xec, 0x94, 0xf8,
	0x71, 0x52, 0x28, 0xff, 0x44, 0xde, 0x22, 0x48, 0xf9, 0x3c, 0x6d, 0xe5, 0xac, 0x40, 0xc5, 0x55,
	0x95, 0x27, 0x6b, 0x16, 0xf5, 0xcd, 0x3d, 0x44, 0x6e, 0xdd, 0xee, 0xed, 0x27, 0x0f, 0xc0, 0x08,
	0xc0, 0x9d, 0x7d, 0x31, 0xfd, 0x94, 0x48, 0xb9, 0x7b, 0x2d, 0xe7, 0xc8, 0x20, 0x40, 0x72, 0xfb,
	0xfa, 0xbb, 0x45, 0x98, 0xda, 0x08, 0xbb, 0x11, 0x76, 0x99, 0x64, 0xe0, 0x3d, 0x58, 0x20, 0x71,
	0xec, 0x78, 0xc1, 0x3e, 0xf6, 0xbd, 0x96, 0x93, 0x9f, 0x71, 0x55, 0xd7, 0x3f, 0x92, 0x3d, 0x23,
	0x4e, 0x4a, 0x6d, 0x4a, 0xea, 0x86, 0x9a, 0x8d, 0xdd, 0x1e, 0xb3, 0x11, 0x89, 0x07, 0xa1, 0xc8,
	0x87, 0xb3, 0xbc, 0xea, 0x48, 0x65, 0x2d, 0x3b, 0x6a, 0x4d, 0x9e, 0x04, 0x4c, 0xb9, 0xd1, 0xb5,
	0x3a, 0xb2, 0x05, 0x9d, 0xea, 0xdc, 0x14, 0xeb, 0x74, 0x15, 0x4a, 0x6f, 0x8f, 0xd9, 0x75, 0x12,
	0x8f, 0xc6, 0x21, 0x07, 0x96, 0x78, 0x6b, 0xae, 0xac, 0xc4, 0xf1, 0x02, 0x27, 0x8a, 0xc3, 0x76,
	0x4c, 0x28, 0x55, 0xdb, 0x62, 0x2f, 0x8c, 0x6c, 0x48, 0xfd, 0xdf, 0x0c, 0xb6, 0x15, 0xf5, 0xed,
	0x31, 0x7b, 0x9e, 0xc4, 0xc3, 0x70, 0xb4, 0x0b, 0x2b, 0xbc, 0x01, 0x16, 0x86, 0x4e, 0x17, 0x07,
	0x7d, 0x27, 0x22, 0x41, 0xcb, 0x0b, 0xda, 0x0e, 0xc3, 0x74, 0x8f, 0xaa, 0xe9, 0xe0, 0xe5, 0x91,
	0x6d, 0x34, 0xc3, 0xf0, 0x1e, 0x0e, 0xfa, 0xdb, 0xb2, 0x40, 0x93, 0xd3, 0xdf, 0x1e, 0xb3, 0x17,
	0x49, 0x3c, 0x0a, 0x73, 0xad, 0xac, 0x5c, 0xc2, 0x3a, 0x07, 0x67, 0x8e, 0x50, 0xba, 0xf5, 0x3c,
	0x5c, 0x7c, 0xa4, 0xc6, 0xac, 0xf3, 0x70, 0xee, 0x48, 0x69, 0xad, 0x8b, 0x70, 0xfe, 0x11, 0xac,
	0xf2, 0x19, 0x44, 0x4d, 0xd1, 0xe8, 0x2e, 0x79, 0xe4, 0xdc, 0x7c, 0x15, 0x66, 0x07, 0x6c, 0xee,
	0xe9, 0x73, 0x96, 0x99, 0x28, 0xcb, 0xe5, 0x66, 0x4b, 0x6c, 0xbe, 0x84, 0xed, 0x3c, 0xa9, 0x3c,
	0x73, 0xa9, 0x29, 0xb8, 0xa6, 0x1c, 0x48, 0x99, 0x2b, 0x1f, 0x2f, 0x65, 0x6e, 0x20, 0x01, 0xac,
	0x32, 0x98, 0x00, 0x66, 0xfd, 0x85, 0x3c, 0x2f, 0x96, 0xc2, 0xa9, 0x7e, 0xfc, 0x52, 0x7e, 0x4b,
	0x65, 0x61, 0xa4, 0x51, 0x75, 0x5f, 0x7d, 0x1e, 0xa6, 0xf9, 0x52, 0x3f, 0x26, 0x5d, 0xec, 0x05,
	0x5e, 0xd0, 0x56, 0xd7, 0x20, 0xf8, 0xfa, 0xdf, 0xd6, 0x30, 0xb4, 0x26, 0xf2, 0x30, 0x78, 0x59,
	0x92, 0xed, 0x63, 0x32, 0xf8, 0xcd, 0x26, 0xa8, 0x46, 0x46, 0x85, 0x29, 0x7d, 0xfe, 0xba, 0xf4,
	0x4c, 0x82, 0xb8, 0x21, 0x57, 0x3c, 0x2f, 0xc3, 0x72, 0xd3, 0x13, 0x37, 0xa0, 0x1b, 0x7d, 0xca,
	0x48, 0x57, 0x28, 0x4c, 0x1b, 0xca, 0x84, 0x22, 0x7d, 0xdf, 0x57, 0xc9, 0x63, 0xfc, 0xaf, 0x15,
	0xc1, 0xca, 0x28, 0x72, 0x25, 0xba, 0xad, 0xc2, 0xb2, 0xb0, 0xe9, 0xb5, 0x37, 0x3f, 0xf8, 0xe9,
	0xf9, 0xb1, 0x1f, 0xff, 0xf4, 0xfc, 0x1b, 0x6d, 0x8f, 0x75, 0x7a, 0x3b, 0x6b, 0x6e, 0xd8, 0xbd,
	0x12, 0x79, 0x41, 0xdb, 0xc5, 0xd1, 0x95, 0xbd, 0x7d, 0xf9, 0x3a, 0x7c, 0xb4, 0xd7, 0xbe, 0x42,
	0x3b, 0x38, 0x26, 0x2d, 0x11, 0x73, 0xd6, 0x1a, 0xe2, 0xbf, 0x88, 0x36, 0x2a, 0xac, 0xff, 0xa4,
	0x00, 0x95, 0xe6, 0x61, 0x20, 0xc6, 0x4b, 0xf4, 0x49, 0xa8, 0x44, 0xea, 0x59, 0x5d, 0xa5, 0xde,
	0x95, 0x6c, 0x1a, 0x8b, 0x20, 0x4a, 0x9e, 0x20, 0xbe, 0x3d, 0x66, 0x27, 0xd4, 0x68, 0x1d, 0x26,
	0xd4, 0xe2, 0xbc, 0x30, 0x90, 0x32, 0x92, 0x94, 0x93, 0xcb, 0xf4, 0xdb, 0x63, 0xb6, 0xa2, 0x5c,
	0x09, 0xa0, 0xa2, 0xeb, 0x1a, 0xce, 0x67, 0x78, 0xc8, 0x23, 0xa2, 0xd9, 0x5d, 0x8b, 0xe2, 0x91,
	0xa7, 0xf3, 0xa5, 0xc1, 0xd3, 0xf9, 0x95, 0x0e, 0x4c, 0xa8, 0xad, 0x82, 0x53, 0x68, 0xed, 0xa8,
	0xa7, 0xbe, 0x44, 0x94, 0xe0, 0x32, 0x5b, 0xff, 0x62, 0xc0, 0x42, 0xc3, 0xc5, 0x81, 0x52, 0x82,
	0x47, 0xe8, 0xb3, 0xbb, 0xc1, 0x37, 0xfa, 0x05, 0x97, 0x23, 0x1e, 0x82, 0xcf, 0x4a, 0x3b, 0x91,
	0x97, 0xf6, 0x32, 0x98, 0xc9, 0x96, 0x47, 0x44, 0xe2, 0xe4, 0x52, 0xe4, 0xb4, 0x5d, 0xd3, 0xf0,
	0x6d, 0x12, 0x73, 0x87, 0x3f, 0x84, 0xc5, 0x41, 0x81, 0x4f, 0x3e, 0x00, 0xbf, 0x94, 0x4e, 0xf4,
	0x06, 0xaf, 0xc9, 0x68, 0xb7, 0x4a, 0xe6, 0x78, 0xab, 0x6f, 0xc3, 0xf2, 0x43, 0x9f, 0xbd, 0x45,
	0xf3, 0x60, 0xa6, 0x5f, 0xf7, 0xc3, 0xb8, 0x8b, 0x7d, 0x73, 0x0c, 0x2d, 0xc1, 0x5c, 0x0a, 0xbd,
	0x19, 0xc6, 0xae, 0xb8, 0x85, 0x64, 0x1a, 0xab, 0x3e, 0x9c, 0x3d, 0xea, 0x9d, 0x5b, 0x5e, 0x9d,
	0xba, 0xe3, 0xd3, 0xf3, 0x59, 0x52, 0xdd, 0x05, 0x38, 0x9b, 0x42, 0xef, 0x0e, 0x3d, 0x57, 0x2b,
	0x13, 0x83, 0x52, 0x0a, 0x99, 0xef, 0x61, 0x16, 0x56, 0x5f, 0x04, 0x48, 0x23, 0x24, 0x9a, 0x80,
	0xc2, 0x83, 0x57, 0xcc, 0x31, 0x34, 0x09, 0xe3, 0x0f, 0x5e, 0x69, 0x36, 0xef, 0x9a, 0x86, 0x00,
	0xad, 0x9b, 0x85, 0xd5, 0x97, 0x00, 0xd2, 0xe4, 0x77, 0x04, 0x30, 0x91, 0x34, 0x5d, 0x86, 0xe2,
	0xdd, 0xf0, 0xc0, 0x34, 0x50, 0x05, 0x4a, 0xb7, 0xbd, 0x76, 0xc7, 0x2c, 0xac, 0x5e, 0x81, 0x5a,
	0x3e, 0xe3, 0x9d, 0x57, 0xd3, 0xd8, 0x34, 0xc7, 0xf8, 0xaf, 0xbd, 0x61, 0x1a, 0x22, 0xf9, 0x68,
	0x43, 0x26, 0x1f, 0x35, 0xcc, 0xc2, 0xea, 0x03, 0xa8, 0x66, 0xb2, 0xa7, 0x39, 0xaf, 0xf7, 0x43,
	0x76, 0xd5, 0xf7, 0xc3, 0x03, 0xd2, 0xda, 0x0a, 0x38, 0x58, 0xaa, 0x2c, 0x01, 0x5d, 0xf5, 0xbb,
	0x21, 0x65, 0x02, 0x61, 0xa0, 0x3a, 0xcc, 0x67, 0x10, 0x22, 0x55, 0x49, 0x60, 0x0a, 0xab, 0x2e,
	0x14, 0xb6, 0x22, 0xce, 0xe1, 0x76, 0x8f, 0x49, 0x56, 0xaf, 0x13, 0x5f, 0xb2, 0x2a, 0xd4, 0x5d,
	0x40, 0x53, 0x50, 0xd1, 0xbb, 0xb3, 0x66, 0x91, 0xcb, 0xb5, 0x19, 0x50, 0x12, 0x33, 0xb3, 0x84,
	0xe6, 0x60, 0x66, 0xc0, 0x10, 0xe6, 0x38, 0x42, 0x50, 0x13, 0x5c, 0xeb, 0x81, 0x94, 0x9a, 0x13,
	0xab, 0x6b, 0x30, 0x99, 0x6c, 0x56, 0xf3, 0x9a, 0xef, 0x87, 0x01, 0x91, 0x4a, 0x14, 0x24, 0xa6,
	0xc1, 0x1b, 0xd1, 0x05, 0xa4, 0x76, 0xf2, 0xef, 0xb2, 0x73, 0xbe, 0xb6, 0x76, 0x77, 0xcd, 0x31,
	0x5e, 0xfa, 0x26, 0x16, 0x45, 0x00, 0x26, 0x1a, 0x2c, 0xe6, 0xa6, 0x2b, 0xac, 0x7e, 0xcb, 0x80,
	0x09, 0xf5, 0x9a, 0xb9, 0xa8, 0x49, 0xfe, 0x37, 0xc7, 0xd0, 0x02, 0xcc, 0x36, 0x9b, 0x77, 0x65,
	0x3a, 0x53, 0x22, 0x85, 0xd0, 0x87, 0x38, 0x78, 0x51, 0x4d, 0x26, 0x98, 0x02, 0x2f, 0x70, 0x2f,
	0xc9, 0x3f, 0x6a, 0x6c, 0xf7, 0x68, 0x87, 0xb4, 0xcc, 0x22, 0xf7, 0x9e, 0xa4, 0x9e, 0x11, 0x2f,
	0xd2, 0x9a, 0x25, 0xb4, 0x0c, 0x0b, 0xd9, 0x2a, 0xaf, 0x87, 0xf7, 0x43, 0xd6, 0xf1, 0x82, 0xb6,
	0x39, 0xbe, 0x7a, 0x09, 0xca, 0x37, 0x0e, 0x59, 0x8c, 0xb7, 0x22, 0x29, 0x7c, 0x18, 0x99, 0x63,
	0xc8, 0x84, 0x29, 0x9b, 0xe0, 0xd6, 0x96, 0xdf, 0x12, 0xab, 0x58, 0xd3, 0x58, 0xb5, 0x60, 0x76,
	0x68, 0x9e, 0xcd, 0xdd, 0x60, 0x23, 0x76, 0xdf, 0x78, 0xcd, 0xf9, 0xbf, 0x61, 0x6c, 0x8e, 0x5d,
	0x7b, 0xe1, 0xef, 0x7f, 0xbf, 0x62, 0x7c, 0xf0, 0xe1, 0x73, 0xc6, 0x0f, 0x3f, 0x7c, 0xce, 0xf8,
	0xc7, 0x0f, 0x9f, 0x33, 0x7e, 0xe7, 0x9f, 0x9e, 0x1b, 0x03, 0x33, 0x8c, 0xdb, 0x6b, 0xcc, 0xdb,
	0xdb, 0x5f, 0x53, 0x63, 0xcb, 0xce, 0x84, 0xf8, 0x79, 0xf5, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff,
	0x4a, 0x81, 0x2e, 0xc1, 0xc2, 0x64, 0x00, 0x00,
}
